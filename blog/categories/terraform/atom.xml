<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Terraform | Marcelo Cavalcante Rocha ~]]></title>
  <link href="https://kalib.github.io/blog/categories/terraform/atom.xml" rel="self"/>
  <link href="https://kalib.github.io/"/>
  <updated>2018-11-24T18:11:03-05:00</updated>
  <id>https://kalib.github.io/</id>
  <author>
    <name><![CDATA[Marcelo Cavalcante Rocha - Kalib]]></name>
    
  </author>
  <generator uri="https://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Terraform: Criando uma infraestrutura no Google Cloud]]></title>
    <link href="https://kalib.github.io/blog/2018/11/24/terraform-criando-uma-infraestrutura-no-google-cloud/"/>
    <updated>2018-11-24T12:39:00-05:00</updated>
    <id>https://kalib.github.io/blog/2018/11/24/terraform-criando-uma-infraestrutura-no-google-cloud</id>
    <content type="html"><![CDATA[<p><img class="center" src="/imgs/terraform_cloud.png" title="&lsquo;Terraform &ndash; Cloud Computing&rsquo;" ></p>

<p><strong>Q</strong>uando se fala em infraestrutura como código imagina-se algo mais complexo do que simplesmente um container docker rodando uma aplicação, certo?! O propósito deste post é justamente criar uma infraestrutura um pouco mais complexa e completa no GCP, <em>Google Cloud Platform</em>. Embora o Terraform possua integração com diversos provedores de computação em nuvem, utilizarei o Google Cloud para este post por estar trabalhando mais com GCP atualmente e estar gostando da experiência.</p>

<p><strong>U</strong>ma vez que não entrarei em tantos detalhes básicos do Terraform neste post, espero que você já possua algum conhecimento básico sobre o mesmo bem como entenda como funcionam seus <em>resources</em>, <em>variables</em>, etc. Do contrário, recomendo <strong>fortemente</strong> que você volte um pouco e leia meus posts anteriores nesta respectiva ordem:</p>

<ul>
<li><a href="/blog/2018/10/22/infraestrutura-como-codigo-com-terraform/">Infraestrutura como Código com Terraform</a></li>
<li><a href="/blog/2018/10/29/introducao-ao-terraform/">Introdução ao Terraform</a></li>
<li><a href="/blog/2018/11/06/terraform-variaveis-e-outputs/">Terraform: Variáveis e Outputs</a></li>
</ul>


<p><strong>A</strong>ssumindo que você já possui algum conhecimento básico sobre Terraform, chegou a hora de inciarmos o nosso pequeno projeto de infraestrutura como código.</p>

<h2>GCP &ndash; Google Cloud Platform</h2>

<p><img class="center" src="/imgs/gcloud.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p><strong>G</strong>oogle Cloud Platform, ou GCP, é uma suíte de computação em nuvem oferecida pelo Google, funcionando na mesma infraestrutura que a empresa utiliza para seus produtos dirigidos aos usuários, dentre eles o buscador Google e o Youtube. Juntamente com um conjunto de ferramentas de gerenciamento modulares, o GCP fornece uma série de serviços incluindo computação, armazenamento de dados, análise de dados, machine learning, containers, etc.</p>

<p><strong>N</strong>ovamente, o motivo pelo qual optei por utilizar GCP para este pequeno projeto foi simplesmente o fato de eu estar trabalhando mais com GCP em meu dia a dia atual, mas nada impede que você utilize AWS ou Microsoft Azure, por exemplo. Embora a sintaxe e o código Terraform deverá ser ajustado para tais plataformas caso decida utilizá-las.</p>

<p><strong>O</strong>utro motivo interessante é o plano gratuito oferecido pelo Google, o que facilita nossos estudos e experimentos. O GCP nos oferece 1 ano de utilização grátis OU $300 dólares em créditos, o que ocorrer primeiro. De uma forma ou de outra, isto será muito mais que o suficiente para a execução deste nosso projeto.</p>

<p><strong>A</strong>lém das duas razões já citadas, a integração e facilidade de criação de uma nova conta no GCP foi levada em conta para esta escolha. O fato de o gmail e demais serviços do Google serem amplamente utilizados, é bem provável que você possua um email do Google (gmail, por exemplo), certo!? Se este é o caso, você já possui uma &ldquo;pré-conta&rdquo; no GCP sem ao menos saber.</p>

<h3>Cadastro</h3>

<p><strong>S</strong>e você possui uma conta do Google, autentique-se com a mesma. Caso não possua uma, você poderá criar uma através do Gmail, por exemplo, ou criar diretamente na interface do Google Cloud durante o cadastro.</p>

<p>1-   Uma vez logado com sua conta do Google, acesse em seu navegador o seguinte endereço: <a href="https://cloud.google.com">https://cloud.google.com</a> ;</p>

<p>2-   Caso esteja logado com sua conta do Google, verá sua foto ou imagem de conta no canto superior direito da página conforme na imagem a seguir. Clique em <em>Try free</em> ou Experimente Gratuitamente;</p>

<p><img class="center" src="/imgs/gcloud1.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p>3-   Você cairá na primeira página do cadastro. Informe seu País, leia e concorde com os termos de uso caso deseje seguir e em seguida clique em Concordar e Continuar;</p>

<p><img class="center" src="/imgs/gcloud2.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p>4-   Após confirmar e validar todas as informações que eles pedem na etapa 2, clique em Iniciar minha avaliação gratuita;</p>

<p><img class="center" src="/imgs/gcloud3.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p><strong>E</strong>m poucos segundos você deverá cair no painel ou <em>dashboard</em> principal do GCP, com um popup de boas vindas com alguma mensagem de boas vindas: &ldquo;Olá, Marcelo, Agradecemos por você se inscrever na avaliação gratuita de 12 meses. Demos US$ 300 de crédito grátis para você gastar. Não se preocupe se o crédito acabar, você só receberá cobranças se tivermos sua permissão.&rdquo;</p>

<p><strong>E</strong>ste é outro fator interessante do GCP. Durante este período de avaliação, você não corre o risco de ser cobrado caso utilize mais do que deveria por descuido. Uma vez que o período de 12 meses, ou o crédito de $300 tenha se esgotado, você será notificado e deverá encerrar sua conta ou confirmar que deseja continuar utilizando os serviços, autorizando assim o Google a lhe efetuar cobranças a partir deste momento.</p>

<p><strong>O</strong> painel principal se parecerá com este:</p>

<p><img class="center" src="/imgs/gcloud4.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p><strong>C</strong>onforme a imagem abaixo, através do Menu principal que se encontra na lateral esquerda, clique em <strong>IAM e Admin</strong>, e em seguida em <strong>Gerenciar recursos</strong>.</p>

<p><img class="center" src="/imgs/gcloud5.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p><strong>V</strong>ocê receberá uma listagem inicial de seus recursos. Por padrão, quando se cria uma nova conta no GCP, apenas um projeto inicial é criado, chamado My First Project, sem qualquer recurso vinculado ou inserido no mesmo.</p>

<h3>Criando uma conta de serviço ou service account</h3>

<p>Embora seja possível e permitido utilizar-se de uma conta pessoal para este tipo de tarefa, não é o mais indicado. O ideal é deixar serviços utilizarem contas específicas, as chamadas service accounts. Uma vez que utilizaremos o Terraform para criar nossos recursos na nuvem, ele não deixa de funcionar como um serviço, não sendo uma pessoa XYZ de um departamento qualquer de uma empresa.</p>

<p>1-   No menu principal da lateral esquerda, clique em <strong>IAM e Admin</strong>, em seguida em <strong>Contas de serviço</strong>, conforme na imagem abaixo:</p>

<p><img class="center" src="/imgs/gcloud7.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p>2-   Na tela de Contas de serviço, clique em <strong>Criar conta de serviço</strong>;</p>

<p>3-   Indique o nome <strong>terraform</strong> para esta conta, conforme imagem abaixo, e clique em <strong>CRIAR</strong>;</p>

<p><img class="center" src="/imgs/gcloud8.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p>4-   No passo 2, daremos um papel para esta conta de serviço. Aqui indicaremos quais permissões ela terá. Para facilitar nosso exercício, utilizaremos <strong>Projeto</strong> > <strong>Proprietário</strong>, significando que nossa conta de serviço terá todas as permissões em nosso projeto, podendo criar ou destruir qualquer tipo de recurso.</p>

<p><img class="center" src="/imgs/gcloud9.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p>5-   Em seguida, clicaremos em <strong>Continuar</strong> para seguir com a criação de nossa conta de serviço;</p>

<p>6-   Na tela seguinte lhe será dada a opção de dar permissões para algum usuário que possa precisar utilizar-se desta conta de serviço para criar recursos. Você pode inserir neste campo o seu usuário principal do google cloud, o qual será o seu email que foi utilizado para criar esta conta no GCP. Insira-o em <em>Papel de usuários da conta de serviço</em>. Em seguida, clique no botão de <em>Criar Chave</em> que se encontra logo abaixo. Esta será a chave criptografada que utilizaremos para comunicação segura com o GCP;</p>

<p><img class="center" src="/imgs/gcloud10.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p>7-   Lhe será perguntado em que formato você deseja slavar a chave. Escolha o formato JSON e clique em <strong>CRIAR</strong>;</p>

<p>8-   Escolha com atenção o local onde salvará esta chave, pois você não poderá baixá-la novamente e precisaremos da mesma posteriormente;</p>

<p><strong>OBS:</strong> Para facilitar este exemplo, estarei salvando a chave no mesmo diretório no qual criaremos o código de nosso projeto. Caso você decida fazer o mesmo, e decida hospedar este código em alguma espécie de repositório git, por exemplo, lembre-se de <strong>sempre</strong> incluir esta e outras chaves ou dados sigilosos em seu <em>.gitignore</em>, para que este tipo de arquivo com informações confidenciais não seja enviado para o repositório juntamente com o código. =) (Sim, já vi pessoas hospedando chaves em repositórios git e tendo sérios problemas. Sim, é você mesmo. :p)</p>

<h3>Google Cloud SDK</h3>

<p><strong>U</strong>m dos nossos pré-requisitos será o Google Cloud SDK, que possui um conjunto de ferramentas via linha de comando que nos permitem interagir com o Google Cloud remotamente através de APIs. O Terraform também fará uso desta ferramenta.</p>

<p><strong>P</strong>ara o funcionamento do gcloud SDK precisaremos também possuir o Python instalado, na versão 2.7. Você poderá confirmar a sua versão do python executando <em>python -V</em> em algum console ou terminal.</p>

<p><strong>I</strong>nformações detalhadas sobre como instalar o Gcloud SDK encontram-se com excelentes detalhes nas páginas oficiais do Google, listadas abaixo:</p>

<ul>
<li><p>Para Linux (genérico): <a href="https://cloud.google.com/sdk/docs/quickstart-linux">https://cloud.google.com/sdk/docs/quickstart-linux</a></p></li>
<li><p>Para Linux (Debian e Ubuntu): <a href="https://cloud.google.com/sdk/docs/quickstart-debian-ubuntu">https://cloud.google.com/sdk/docs/quickstart-debian-ubuntu</a></p></li>
<li><p>Para Linux (Red Hat e CentOS): <a href="https://cloud.google.com/sdk/docs/quickstart-redhat-centos">https://cloud.google.com/sdk/docs/quickstart-redhat-centos</a></p></li>
<li><p>Para Mac OS X: <a href="https://cloud.google.com/sdk/docs/quickstart-macos">https://cloud.google.com/sdk/docs/quickstart-macos</a></p></li>
<li><p>Para Windows: <a href="https://cloud.google.com/sdk/docs/quickstart-windows">https://cloud.google.com/sdk/docs/quickstart-windows</a></p></li>
</ul>


<p><strong>É</strong> importante lembrar de reiniciar o seu terminal ou console após a instalação.</p>

<p><strong>P</strong>ara certificar-se de que a instalação foi realizada com sucesso, execute:</p>

<p>``` yaml
$ gcloud &mdash;version</p>

<p>Google Cloud SDK 225.0.0
bq 2.0.37
core 2018.11.09
gsutil 4.34
```</p>

<p><strong>S</strong>e você recebeu informações referentes à versão do Google Cloud SDK, significa que a instalação foi bem sucedida. O próximo passo é autenticar-se com sua conta do google através do SDK. Execute <em>gcloud init</em>. O seu navegador deverá abrir automaticamente lhe pedindo a autenticação de sua conta do Google após você confirmar com um <em>Y</em> a solicitação no console ou terminal.</p>

<p>``` yaml
$ gcloud init</p>

<p>Welcome! This command will take you through the configuration of gcloud.</p>

<p>Your current configuration has been set to: [default]</p>

<p>You can skip diagnostics next time by using the following flag:
  gcloud init &mdash;skip-diagnostics</p>

<p>Network diagnostic detects and fixes local network connection issues.
Checking network connection&hellip;done.
Reachability Check passed.
Network diagnostic passed (1/1 checks passed).</p>

<p>You must log in to continue. Would you like to log in (Y/n)?
```</p>

<p><strong>C</strong>aso ao inserir um <em>Y</em>, o seu navegador não lhe solicite a autenticação do Google, copie e cole a longa URL que lhe será apresentada.</p>

<p><strong>A</strong> solicitação de autenticação será similar à esta:</p>

<p><img class="center" src="/imgs/gcloud6.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p><strong>A</strong>o finalizar sua autenticação no navegador, você receberá mais uma pergunta em seu terminal ou console. O SDK lhe indicará o seu projeto e lhe perguntará se você quer utilizá-lo ou criar um novo. Vamos escolher a opção <em>1</em>, para utilizar o projeto que foi criado automaticamente e em seguida confirmar com um Enter:</p>

<p>``` yaml
Your browser has been opened to visit:</p>

<pre><code>https://accounts.google.com/o/oauth2/auth?reblablabalblablaba=http%3A%2F%2Flocalhost%3A8085%2F&amp;prompt=select_account&amp;response_typereblablabalblablabauid.apps.googleusercontent.com&amp;scope=https%3A%2F%2Fwww.googleapis.com%reblablabalblablabaemreblablabalblablabaw.gooreblablabalblablaba%2Fauth%2Fclreblablabalblablaba%2Fwwwreblablabalblablabacomreblablabalblablabaappenreblablabalblablabattpsreblablabalblablabaww.reblablabalblablabaleapis.com%2Fauthreblablabalblablabattps%3A%2F%2Fwww.googleapis.com%2Fauthreblablabalblablaba&amp;access_type=offline
</code></pre>

<p>You are logged in as: [<a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#109;&#x61;&#x72;&#99;&#101;&#108;&#111;&#x40;&#x6d;&#x61;&#114;&#99;&#101;&#108;&#111;&#x65;&#x6d;&#97;&#105;&#x6c;&#46;&#x6e;&#101;&#x74;">&#109;&#97;&#x72;&#99;&#x65;&#x6c;&#111;&#64;&#109;&#x61;&#114;&#99;&#x65;&#108;&#x6f;&#101;&#x6d;&#97;&#105;&#108;&#46;&#x6e;&#x65;&#x74;</a>].</p>

<p>Pick cloud project to use:
 [1] possible-sun-meuid
 [2] Create a new project
Please enter numeric choice or text value (must exactly match list
item):
```</p>

<p><strong>O</strong> SDK finalizará o setup e lhe informará que o projeto está pronto para ser utilizado.</p>

<h2>Terraform</h2>

<p><img class="center" src="/imgs/terraform_badge.png" title="&lsquo;Terraform&rsquo;" ></p>

<p><strong>V</strong>amos ao que interessa agora. Antes de iniciarmos nosso código, crie um diretório chamado <em>terraform-gcp</em>, ou algo de sua preferência. Dentro deste diretório apenas teremos por enquanto o arquivo JSON que baixamos do GCP com as credenciais de nossa conta de serviço.</p>

<p><strong>C</strong>riaremos agora nosso primeiro arquivo terraform.</p>

<p><strong>C</strong>omecemos criando nosso arquivo de variáveis, o qual por enquanto conterá apenas 2 variáveis para começarmos nosso código. Crie o arquivo <em>variables.tf</em> com o seguinte conteúdo:</p>

<p>``` py variables.tf
variable &ldquo;project_id&rdquo; {
  type    = &ldquo;string&rdquo;
  default = &ldquo;possible-sun-83482736&rdquo;
}</p>

<p>variable &ldquo;regiao&rdquo; {
  type = &ldquo;string&rdquo;
  default = &ldquo;northamerica-northeast1&rdquo;
}
```</p>

<p><strong>OBS:</strong> Lembre-se de alterar o valor default da variável <em>project_id</em>. Eu inseri aqui o id do projeto que foi criado para mim pelo GCP automaticamente. O id do seu projeto deverá ser o mesmo fornecido a você pelo GCP.</p>

<p><strong>O</strong>utra coisa importante é lembrar que estou assumindo que você já possui algum conhecimento básico sobre como o Terraform funciona, ou que leu meus posts anteriores sobre o assunto, de forma que não estarei aqui entrando em tantos detalhes explicativos sobre cada arquivo, conforme fiz nos anteriores.</p>

<p><strong>E</strong>m nosso arquivo <em>variables.tf</em>, por enquanto, criamos apenas duas variáveis: <em>project_id</em> e <em>regiao</em>. Para quem já utilizou algum serviço de computação em nuvem, seja GCP, AWS, Azure, etc., isto pode soar familiar. Sempre que se deseja criar recursos na nuvem, devemos optar por alguma região disponível no provedor de escolha. Estou optando por utilizar <em>northamerica-northeast1</em> pelo fato de eu morar em Toronto, e esta ser a região mais próxima, mas sinta-se livre para optar por qualquer região disponível no GCP conforme <a href="https://cloud.google.com/compute/docs/regions-zones/">lista fornecida aqui</a>.</p>

<p><strong>E</strong>m seguida criaremos nosso arquivo <em>main.tf</em> que, inicialmente, possuirá apenas o seguinte:</p>

<p>``` py main.tf</p>

<h1>Configura o projeto GCP</h1>

<p>provider &ldquo;google&rdquo; {
  credentials = &ldquo;${file("possible-sun-83482736-sabh45jhb2345ghv.json&rdquo;)}&ldquo;
  project     = &rdquo;${var.project_id}&ldquo;
  region      = &rdquo;${var.regiao}&ldquo;
}
```</p>

<p><strong>A</strong>qui estamos apenas informando ao Terraform que utilizaremos o <em>google</em> como provedor ou <em>provider</em>. Para nos conectarmos com o <em>provider</em> precisamos passar nossas credenciais e para tal estamos apontando o arquivo ou <em>file</em> que baixamos do GCP com as informações de nossa conta de serviço. Aqui estou passando apenas o nome do arquivo, pois o mesmo se encontra no mesmo diretório onde se encontra meu código.</p>

<p><strong>A</strong>lém da credencial, estamos também informando qual o nome do projeto que utilizaremos no GCP bem como a região na qual estaremos trabalhando. Ambos os valores estão sendo trazidos do arquivo <em>variables.tf</em>. Aqui apenas invocamos as variáveis. (Novamente: Se esta invocação das variáveis lhe parece confusa, significa que não leu o post anterior, onde expliquei o básico sobre uso de variáveis no Terraform. Volte uma casa!)</p>

<p><strong>C</strong>om ambos os arquivos criados, podemos iniciar a execução de nosso projeto. Neste momento, nosso código não fará nada além de permitir que o Terraform consiga se conectar ao GCP e validar que nossa conta e projeto de fato existem. Executemos <em>terraform init</em> para ver se está tudo certo:</p>

<p>``` yaml
$ terraform init</p>

<p>Initializing provider plugins&hellip;
&ndash; Checking for available provider plugins on <a href="https://releases.hashicorp.com...">https://releases.hashicorp.com...</a>
&ndash; Downloading plugin for provider &ldquo;google&rdquo; (1.19.1)&hellip;</p>

<p>The following providers do not have any version constraints in configuration,
so the latest version was installed.</p>

<p>To prevent automatic upgrades to new major versions that may contain breaking
changes, it is recommended to add version = &ldquo;&hellip;&rdquo; constraints to the
corresponding provider blocks in configuration, with the constraint strings
suggested below.</p>

<ul>
<li>provider.google: version = &ldquo;~> 1.19&rdquo;</li>
</ul>


<p>Terraform has been successfully initialized!</p>

<p>You may now begin working with Terraform. Try running &ldquo;terraform plan&rdquo; to see
any changes that are required for your infrastructure. All Terraform commands
should now work.</p>

<p>If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
```</p>

<p><strong>A</strong>o que parece, o nosso <em>state</em> do Terraform foi iniciado com sucesso e tudo parece correto. Vamos tentar criar nosso plano de execução agora com <em>terraform plan</em>:</p>

<p>``` yaml
$ terraform plan</p>

<p>Refreshing Terraform state in-memory prior to plan&hellip;
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.</p>

<hr />

<p>No changes. Infrastructure is up-to-date.</p>

<p>This means that Terraform did not detect any differences between your
configuration and real physical resources that exist. As a result, no
actions need to be performed.
```</p>

<p><strong>T</strong>udo parece correto e, assim como dito anteriormente, o Terraform também nos informa que tudo está atualizado e que nenhuma ação precisa ser realizada, afinal não indicamos nada a ser criado, nenhum recurso. Apenas indicamos que utilizaremos um determinado projeto em uma determinada região, e tal projeto já existe no GCP.</p>

<p><strong>V</strong>amos então iniciar a criação de nossa infraestrutura básica. Iniciemos criando uma VM simples.</p>

<p><strong>Q</strong>uando falamos em VMs na nuvem, existem alguns atributos importantes que devemos levar em conta antes de criar a mesma:</p>

<ul>
<li>Nome: Nossa VM precisa ter um nome;</li>
<li>Tipo de máquina: Quando se decide comprar um novo servidor para sua empresa, você terá diversas máquinas disponíveis a venda, algumas com mais memória, outras com menos, CPU, Disco, etc. Da mesma forma funcionam VMs em um ambiente de nuvem como o GCP. Precisamos determinar o tipo de VM que queremos;</li>
<li>Zona: Todo provedor na nuvem ou <em>cloud</em> possui diversas zonas ou regiões disponíveis espalhadas pelo globo, portanto devemos sempre informar onde queremos rodar nossos recursos;</li>
<li>Imagem: Assim como fazemos com um servidor físico, sempre devemos escolher uma imagem ou Sistema Operacional para ser instalado em nossa VM;</li>
</ul>


<p><strong>U</strong>ma vez que tenhamos iuma listagem básica de algumas variáveis importantes para nossa VM, vamos inserí-las em nosso arquivo <em>variables.tf</em>:</p>

<p>``` py variables.tf
variable &ldquo;project_id&rdquo; {
  type    = &ldquo;string&rdquo;
  default = &ldquo;possible-sun-83482736&rdquo;
}</p>

<p>variable &ldquo;regiao&rdquo; {
  type = &ldquo;string&rdquo;
  default = &ldquo;northamerica-northeast1&rdquo;
}</p>

<p>variable &ldquo;nome&rdquo; {
  type = &ldquo;string&rdquo;
  default = &ldquo;vm-webserver&rdquo;
}</p>

<p>variable &ldquo;tipo_maquina&rdquo; {
  type = &ldquo;string&rdquo;
  default = &ldquo;f1-micro&rdquo;
}</p>

<p>variable &ldquo;zona&rdquo; {
  type = &ldquo;string&rdquo;
  default = &ldquo;northamerica-northeast1-a&rdquo;
}</p>

<p>variable &ldquo;imagem&rdquo; {
  type = &ldquo;string&rdquo;
  default = &ldquo;debian-cloud/debian-9&rdquo;
}
```</p>

<p><strong>A</strong>qui criamos 4 novas variáveis. Daremos um nome (vm-webserver) para nossa VM, um tipo de máquina (f1-micro), uma zona (em meu caso utilizarei northamerica-northamerica1-a por ser a mais próxima de mim, mas sinta-se livre para utilizar a que melhor lhe servir) e uma imagem (debian-cloud/debian-9, a qual faz parte da enorme lista de imagens disponíveis no Google).</p>

<p>Agora que temos nossas variáveis definidas, vamos editar o arquivo <em>main.tf</em> para criar nossos recursos para a VM:</p>

<p>``` py main.tf</p>

<h1>Configura o projeto GCP</h1>

<p>provider &ldquo;google&rdquo; {
  credentials = &ldquo;${file("possible-sun-83482736-sabh45jhb2345ghv.json&rdquo;)}&ldquo;
  project     = &rdquo;${var.project_id}&ldquo;
  region      = &rdquo;${var.regiao}&ldquo;
}</p>

<h1>Cria a VM com o Google Compute Engine</h1>

<p>resource &ldquo;google_compute_instance&rdquo; &ldquo;webserver&rdquo; {
  name          = &ldquo;${var.nome}&rdquo;
  machine_type  = &ldquo;${var.tipo_maquina}&rdquo;
  zone          = &ldquo;${var.zona}&rdquo;</p>

<p>  boot_disk {</p>

<pre><code>initialize_params {
  image = "${var.imagem}"
}
</code></pre>

<p>  }</p>

<p>  # Instala o servidor web Apache
  metadata_startup_script = &ldquo;sudo apt-get update; sudo apt-get install apache2 -y; echo Testando > /var/www/html/index.html&rdquo;</p>

<p>  # Habilita rede para a VM bem como um IP público
  network_interface {</p>

<pre><code>network = "default"
access_config {

}
</code></pre>

<p>  }
}
```</p>

<p><strong>A</strong>qui inserimos um <em>resource</em> de tipo <em>google_compute_instance</em> para criar nossa VM e nele passamos os detalhes de nossa VM, tais como nome, tipo de máquina, zona e rede.</p>

<p><strong>E</strong>stamos também utilizando a propriedade <em>metadata_startup_script</em>, na qual o Terraform nos permite utilizar o recurso de script de inicialização do Google Cloud. Este parâmetro nos permite executar um script logo que a VM é criada, portanto podemos automatizar qualquer setup inicial de nossa VM através deste recurso. Neste exemplo estaremos apenas atualizando os repositórios de nosso Debian e instalando um servidor web Apache para nosso teste.</p>

<p><strong>A</strong>gora que temos nossos arquivos <em>variables.tf</em> e <em>main.tf</em> atualizados, vamos executar novamente <em>terraform plan</em> para ver o que aconteceria com nossa infraestrutura:</p>

<p>``` yaml
$ terraform plan
Refreshing Terraform state in-memory prior to plan&hellip;
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.</p>

<hr />

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
 + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li>google_compute_instance.webserver
  id:                                                  <computed>
  boot_disk.#:                                         &ldquo;1&rdquo;
  boot_disk.0.auto_delete:                             &ldquo;true&rdquo;
  boot_disk.0.device_name:                             <computed>
  boot_disk.0.disk_encryption_key_sha256:              <computed>
  boot_disk.0.initialize_params.#:                     &ldquo;1&rdquo;
  boot_disk.0.initialize_params.0.image:               &ldquo;debian-cloud/debian-9&rdquo;
  boot_disk.0.initialize_params.0.size:                <computed>
  boot_disk.0.initialize_params.0.type:                <computed>
  can_ip_forward:                                      &ldquo;false&rdquo;
  cpu_platform:                                        <computed>
  create_timeout:                                      &ldquo;4&rdquo;
  deletion_protection:                                 &ldquo;false&rdquo;
  guest_accelerator.#:                                 <computed>
  instance_id:                                         <computed>
  label_fingerprint:                                   <computed>
  machine_type:                                        &ldquo;f1-micro&rdquo;
  metadata_fingerprint:                                <computed>
  metadata_startup_script:                             &ldquo;sudo apt-get update; sudo apt-get install apache2 -y; echo Testando > /var/www/html/index.html&rdquo;
  name:                                                &ldquo;vm-webserver&rdquo;
  network_interface.#:                                 &ldquo;1&rdquo;
  network_interface.0.access_config.#:                 &ldquo;1&rdquo;
  network_interface.0.access_config.0.assigned_nat_ip: <computed>
  network_interface.0.access_config.0.nat_ip:          <computed>
  network_interface.0.access_config.0.network_tier:    <computed>
  network_interface.0.address:                         <computed>
  network_interface.0.name:                            <computed>
  network_interface.0.network:                         &ldquo;default&rdquo;
  network_interface.0.network_ip:                      <computed>
  network_interface.0.subnetwork_project:              <computed>
  project:                                             <computed>
  scheduling.#:                                        <computed>
  self_link:                                           <computed>
  tags_fingerprint:                                    <computed>
  zone:                                                &ldquo;northamerica-northeast1-a&rdquo;</li>
</ul>


<p>Plan: 1 to add, 0 to change, 0 to destroy.</p>

<hr />

<p>Note: You didn&rsquo;t specify an &ldquo;-out&rdquo; parameter to save this plan, so Terraform
can&rsquo;t guarantee that exactly these actions will be performed if
&ldquo;terraform apply&rdquo; is subsequently run.
```</p>

<p><strong>A</strong>parentemente tudo está conforme o esperado. O Terraform criará um recurso para nossa VM.</p>

<p><strong>A</strong>ntes de aplicarmos nosso plano de fato, volte à sua <em>Dashboard</em> do GCP e, no menu principal do canto esquerdo navegue até o painel de Instâncias (VMs):</p>

<p><img class="center" src="/imgs/gcloud11.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p><strong>C</strong>aso seja a sua primeira vez acessando esta seção, você deverá receber a informação de que o Google esta carregando a API de <em>Compute Engine</em> para seu uso. Este processo costuma levar cerca de 1 ou 2 minutos, mas apenas acontece na primeira vez que você acessa este painel. Para otimizar sua nuvem o Google não carrega todas as APIs por padrão, habilitando-as aos poucos conforme você as utiliza, bem como lhe permitindo habilitar apenas as que você deseja ou desabilitar as que não precisa.</p>

<p><strong>V</strong>ocê provavelmente não terá nenhuma VM ou instância criada, portanto nada será listado para você além de uma tela informando que ali ficarão suas VMs, bem como um botão de <strong>Criar</strong> VMs, através do qual você poderia criar suas VMs e passar todas as suas definições pela interface. Mas o nosso objetivo é automatizar tudo isso e codificar nossa infraestrutura, certo?! Portanto, ignoremos isto por enquanto. O nosso objetivo nesta interface era apenas ver que não temos nossa vm webserver criada (ainda).</p>

<p><strong>D</strong>e volta ao nosso console ou terminal, executemos <em>terraform apply</em>:</p>

<p>``` yaml
$ terraform apply</p>

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li>google_compute_instance.webserver
  id:                                                  <computed>
  boot_disk.#:                                         &ldquo;1&rdquo;
  boot_disk.0.auto_delete:                             &ldquo;true&rdquo;
  boot_disk.0.device_name:                             <computed>
  boot_disk.0.disk_encryption_key_sha256:              <computed>
  boot_disk.0.initialize_params.#:                     &ldquo;1&rdquo;
  boot_disk.0.initialize_params.0.image:               &ldquo;debian-cloud/debian-9&rdquo;
  boot_disk.0.initialize_params.0.size:                <computed>
  boot_disk.0.initialize_params.0.type:                <computed>
  can_ip_forward:                                      &ldquo;false&rdquo;
  cpu_platform:                                        <computed>
  create_timeout:                                      &ldquo;4&rdquo;
  deletion_protection:                                 &ldquo;false&rdquo;
  guest_accelerator.#:                                 <computed>
  instance_id:                                         <computed>
  label_fingerprint:                                   <computed>
  machine_type:                                        &ldquo;f1-micro&rdquo;
  metadata_fingerprint:                                <computed>
  metadata_startup_script:                             &ldquo;sudo apt-get update; sudo apt-get install apache2 -y; echo Testando > /var/www/html/index.html&rdquo;
  name:                                                &ldquo;vm-webserver&rdquo;
  network_interface.#:                                 &ldquo;1&rdquo;
  network_interface.0.access_config.#:                 &ldquo;1&rdquo;
  network_interface.0.access_config.0.assigned_nat_ip: <computed>
  network_interface.0.access_config.0.nat_ip:          <computed>
  network_interface.0.access_config.0.network_tier:    <computed>
  network_interface.0.address:                         <computed>
  network_interface.0.name:                            <computed>
  network_interface.0.network:                         &ldquo;default&rdquo;
  network_interface.0.network_ip:                      <computed>
  network_interface.0.subnetwork_project:              <computed>
  project:                                             <computed>
  scheduling.#:                                        <computed>
  self_link:                                           <computed>
  tags_fingerprint:                                    <computed>
  zone:                                                &ldquo;northamerica-northeast1-a&rdquo;</li>
</ul>


<p>Plan: 1 to add, 0 to change, 0 to destroy.</p>

<p>Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only &lsquo;yes&rsquo; will be accepted to approve.</p>

<p>  Enter a value:
```</p>

<p><strong>T</strong>udo parece correto, inclusive podemos ver nosso script de metadata que deverá ser executado durante a criação da VM para instalar nosso servidor WEB Apache. Confirme com um <em>yes</em>:</p>

<p>``` yaml
Enter a value: yes</p>

<p>google_compute_instance.webserver: Creating&hellip;
boot_disk.#:                                         &ldquo;&rdquo; => &ldquo;1&rdquo;
boot_disk.0.auto_delete:                             &ldquo;&rdquo; => &ldquo;true&rdquo;
boot_disk.0.device_name:                             &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
boot_disk.0.disk_encryption_key_sha256:              &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
boot_disk.0.initialize_params.#:                     &ldquo;&rdquo; => &ldquo;1&rdquo;
boot_disk.0.initialize_params.0.image:               &ldquo;&rdquo; => &ldquo;debian-cloud/debian-9&rdquo;
boot_disk.0.initialize_params.0.size:                &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
boot_disk.0.initialize_params.0.type:                &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
can_ip_forward:                                      &ldquo;&rdquo; => &ldquo;false&rdquo;
cpu_platform:                                        &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
create_timeout:                                      &ldquo;&rdquo; => &ldquo;4&rdquo;
deletion_protection:                                 &ldquo;&rdquo; => &ldquo;false&rdquo;
guest_accelerator.#:                                 &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
instance_id:                                         &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
label_fingerprint:                                   &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
machine_type:                                        &ldquo;&rdquo; => &ldquo;f1-micro&rdquo;
metadata_fingerprint:                                &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
metadata_startup_script:                             &ldquo;&rdquo; => &ldquo;sudo apt-get update; sudo apt-get install apache2 -y; echo Testando > /var/www/html/index.html&rdquo;
name:                                                &ldquo;&rdquo; => &ldquo;vm-webserver&rdquo;
network_interface.#:                                 &ldquo;&rdquo; => &ldquo;1&rdquo;
network_interface.0.access_config.#:                 &ldquo;&rdquo; => &ldquo;1&rdquo;
network_interface.0.access_config.0.assigned_nat_ip: &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
network_interface.0.access_config.0.nat_ip:          &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
network_interface.0.access_config.0.network_tier:    &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
network_interface.0.address:                         &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
network_interface.0.name:                            &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
network_interface.0.network:                         &ldquo;&rdquo; => &ldquo;default&rdquo;
network_interface.0.network_ip:                      &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
network_interface.0.subnetwork_project:              &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
project:                                             &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
scheduling.#:                                        &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
self_link:                                           &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
tags_fingerprint:                                    &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
zone:                                                &ldquo;&rdquo; => &ldquo;northamerica-northeast1-a&rdquo;
google_compute_instance.webserver: Still creating&hellip; (10s elapsed)
google_compute_instance.webserver: Creation complete after 14s (ID: vm-webserver)</p>

<p>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.
```</p>

<p><strong>N</strong>osso código parece ter sido executado com sucesso e o Terraform ao final nos confirma que um <em>resource</em> foi adicionado (o qual esperamos ser nossa VM).</p>

<p>Se atualizarmos nossa página de instâncias no GCP, devemos agora ver nossa <em>vm-webserver</em> criada e rodando:</p>

<p><img class="center" src="/imgs/gcloud12.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p><strong>A</strong>gora que temos a certeza de que nosso código funciona para a criação de nossa VM, precisamos também fazer com que a mesma seja acessível, afinal a principal função de qualquer servidor web é justamente ser acessível para apresentar alguma aplicação ou site. Para isto precisamos habilitar o firewall de nossa VM ou instância. Além disso, precisamos saber qual o endereço IP desta instância. Embora seja possível e simples conseguir este endereço IP através da interface do GCP ao clicarmos em cima de nossa VM, podemos também automatizar isto e receber este valor diretamente através do Terraform. (Lembre-se: O principal objetivo por trás da ideia de infraestrutura como código é automatizar ao máximo, evitando o uso de interfaces ou  dashboards (odeio cliques) :p).</p>

<p><strong>V</strong>amos começar criando um arquivo <em>outputs.tf</em> que será utilizado para nos informar o IP da VM criada pelo Terraform:</p>

<p>``` py outputs.tf</p>

<h1>Retorna o IP da VM criada</h1>

<p>output &ldquo;ip&rdquo; {
  value = &ldquo;${google_compute_instance.webserver.network_interface.0.access_config.0.nat_ip}&rdquo;
}
```</p>

<p><strong>N</strong>ão, eu não estou inventando comandos ou trazendo algo do além. Se você é curioso e atencioso deve ter percebido que aqui estamos apenas puxando informações que o GCP criou através do Terraform. Se você voltar e reparar em seu comando <em>terraform apply</em>, perceberá que um dos atributos listados/criados em sua VM foi justamente o <em>network_interface.0.access_config.0.nat_ip</em>:</p>

<p><code>yaml
...
network_interface.0.access_config.0.assigned_nat_ip: "" =&gt; "&lt;computed&gt;"
--&gt; network_interface.0.access_config.0.nat_ip:          "" =&gt; "&lt;computed&gt;"
network_interface.0.access_config.0.network_tier:    "" =&gt; "&lt;computed&gt;"
network_interface.0.address:                         "" =&gt; "&lt;computed&gt;"
...
</code></p>

<p><strong>P</strong>ara validarmos que isto de fato funcionará, vamos executar novamente <em>terraform apply</em>:</p>

<p>``` yaml
$ terraform apply
google_compute_instance.webserver: Refreshing state&hellip; (ID: vm-webserver)</p>

<p>Apply complete! Resources: 0 added, 0 changed, 0 destroyed.</p>

<p>Outputs:</p>

<p>ip = 35.203.117.191
```</p>

<p><strong>C</strong>onforme o esperado, nenhum <em>resource</em> precisou ser criado, pois não alteramos nada em nosso código indicando a necessidade de alguma mudança. A única coisa que aocnteceu de diferente foi que desta vez recebemos o IP de nossa instância ou VM.</p>

<p><strong>O</strong>utra forma de recebermos este valor a qualquer momento é executando <em>terraform output ip</em>:</p>

<p><code>yaml
$ terraform output ip
35.203.117.191
</code></p>

<p><strong>Ó</strong>timo, já temos nossa instância e sabemos que podemos receber o endereço IP externo dela facilmente para acesso. Só nos resta agora abrir as portas de firewall necessárias para que possamos acessar nossa aplicação. Vamos abrir a porta 80 para nossa VM.</p>

<p><strong>V</strong>amos criar as seguintes variáveis em nosso arquivo <em>variables.tf</em>:</p>

<ul>
<li>nome_fw: precisamos dar um nome para nosso firewall;</li>
<li>portas: precisamos criar uma lista de portas que serão abertas neste firewall.</li>
</ul>


<p>``` py variables.tf
variable &ldquo;project_id&rdquo; {
  type    = &ldquo;string&rdquo;
  default = &ldquo;possible-sun-83482736&rdquo;
}</p>

<p>variable &ldquo;regiao&rdquo; {
  type = &ldquo;string&rdquo;
  default = &ldquo;northamerica-northeast1&rdquo;
}</p>

<p>variable &ldquo;nome&rdquo; {
  type = &ldquo;string&rdquo;
  default = &ldquo;vm-webserver&rdquo;
}</p>

<p>variable &ldquo;tipo_maquina&rdquo; {
  type = &ldquo;string&rdquo;
  default = &ldquo;f1-micro&rdquo;
}</p>

<p>variable &ldquo;zona&rdquo; {
  type = &ldquo;string&rdquo;
  default = &ldquo;northamerica-northeast1-a&rdquo;
}</p>

<p>variable &ldquo;imagem&rdquo; {
  type = &ldquo;string&rdquo;
  default = &ldquo;debian-cloud/debian-9&rdquo;
}</p>

<p>variable &ldquo;nome_fw&rdquo; {
  type = &ldquo;string&rdquo;
  default = &ldquo;webserver-firewall&rdquo;
}</p>

<p>variable &ldquo;portas&rdquo; {
  type = &ldquo;list&rdquo;
  default = [&ldquo;80&rdquo;]
}
```</p>

<p><strong>A</strong> única novidade aqui foi o tipo <em>list</em> que utilizamos para a variável <em>portas</em>. Uma vez que podemos querer abrir múltiplas portas, utilizaremos o tipo <em>list</em>, o qual nos permite ter vários valores, ou uma lista de valores, para esta variável.</p>

<p><strong>A</strong>gora vamos criar o <em>resource</em> para nosso firewall no arquivo <em>main.tf</em>:</p>

<p>``` py main.tf</p>

<h1>Configura o projeto GCP</h1>

<p>provider &ldquo;google&rdquo; {
  credentials = &ldquo;${file("possible-sun-83482736-sabh45jhb2345ghv.json&rdquo;)}&ldquo;
  project     = &rdquo;${var.project_id}&ldquo;
  region      = &rdquo;${var.regiao}&ldquo;
}</p>

<h1>Cria a VM com o Google Compute Engine</h1>

<p>resource &ldquo;google_compute_instance&rdquo; &ldquo;webserver&rdquo; {
  name          = &ldquo;${var.nome}&rdquo;
  machine_type  = &ldquo;${var.tipo_maquina}&rdquo;
  zone          = &ldquo;${var.zona}&rdquo;</p>

<p>  boot_disk {</p>

<pre><code>initialize_params {
  image = "${var.imagem}"
}
</code></pre>

<p>  }</p>

<p>  # Instala o servidor web Apache
  metadata_startup_script = &ldquo;sudo apt-get update; sudo apt-get install apache2 -y; echo Testando > /var/www/html/index.html&rdquo;</p>

<p>  # Habilita rede para a VM bem como um IP público
  network_interface {</p>

<pre><code>network = "default"
access_config {

}
</code></pre>

<p>  }
}</p>

<h1>Cria o Firewall para a VM</h1>

<p>resource &ldquo;google_compute_firewall&rdquo; &ldquo;webfirewall&rdquo; {
  name        = &ldquo;${var.nome_fw}&rdquo;
  network     = &ldquo;default&rdquo;</p>

<p>  allow {</p>

<pre><code>protocol  = "tcp"
ports     = "${var.portas}"
</code></pre>

<p>  }
}</p>

<p>```</p>

<p><strong>I</strong>ncluímos apenas um novo <em>resource</em> para a criação de nosso firewall abrindo as portas que definimos em nosso arquivo <em>variables.tf</em> com o protocolo <em>tcp</em>. Execute novamente <em>terraform plan</em> para ver o que mudaria:</p>

<p>``` yaml
$ terraform plan
Refreshing Terraform state in-memory prior to plan&hellip;
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.</p>

<p>google_compute_instance.webserver: Refreshing state&hellip; (ID: vm-webserver)</p>

<hr />

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li>google_compute_firewall.webfirewall
  id:                       <computed>
  allow.#:                  &ldquo;1&rdquo;
  allow.272637744.ports.#:  &ldquo;1&rdquo;
  allow.272637744.ports.0:  &ldquo;80&rdquo;
  allow.272637744.protocol: &ldquo;tcp&rdquo;
  creation_timestamp:       <computed>
  destination_ranges.#:     <computed>
  direction:                <computed>
  name:                     &ldquo;webserver-firewall&rdquo;
  network:                  &ldquo;default&rdquo;
  priority:                 &ldquo;1000&rdquo;
  project:                  <computed>
  self_link:                <computed>
  source_ranges.#:          <computed></li>
</ul>


<p>Plan: 1 to add, 0 to change, 0 to destroy.</p>

<hr />

<p>Note: You didn&rsquo;t specify an &ldquo;-out&rdquo; parameter to save this plan, so Terraform
can&rsquo;t guarantee that exactly these actions will be performed if
&ldquo;terraform apply&rdquo; is subsequently run.
```</p>

<p><strong>T</strong>udo parece correto. Como a VM já existe e nada foi modificado no código da mesma, o Terraform apenas criará um  novo <em>resource</em> para nosso firewall com os valores que definimos. Execute seu plano com <em>terraform apply</em> e confirme com <em>yes</em>:</p>

<p>``` yaml
$ terraform apply
google_compute_instance.webserver: Refreshing state&hellip; (ID: vm-webserver)</p>

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li>google_compute_firewall.webfirewall
  id:                       <computed>
  allow.#:                  &ldquo;1&rdquo;
  allow.272637744.ports.#:  &ldquo;1&rdquo;
  allow.272637744.ports.0:  &ldquo;80&rdquo;
  allow.272637744.protocol: &ldquo;tcp&rdquo;
  creation_timestamp:       <computed>
  destination_ranges.#:     <computed>
  direction:                <computed>
  name:                     &ldquo;webserver-firewall&rdquo;
  network:                  &ldquo;default&rdquo;
  priority:                 &ldquo;1000&rdquo;
  project:                  <computed>
  self_link:                <computed>
  source_ranges.#:          <computed></li>
</ul>


<p>Plan: 1 to add, 0 to change, 0 to destroy.</p>

<p>Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only &lsquo;yes&rsquo; will be accepted to approve.</p>

<p>  Enter a value: yes</p>

<p>google_compute_firewall.webfirewall: Creating&hellip;
  allow.#:                  &ldquo;&rdquo; => &ldquo;1&rdquo;
  allow.272637744.ports.#:  &ldquo;&rdquo; => &ldquo;1&rdquo;
  allow.272637744.ports.0:  &ldquo;&rdquo; => &ldquo;80&rdquo;
  allow.272637744.protocol: &ldquo;&rdquo; => &ldquo;tcp&rdquo;
  creation_timestamp:       &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  destination_ranges.#:     &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  direction:                &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  name:                     &ldquo;&rdquo; => &ldquo;webserver-firewall&rdquo;
  network:                  &ldquo;&rdquo; => &ldquo;default&rdquo;
  priority:                 &ldquo;&rdquo; => &ldquo;1000&rdquo;
  project:                  &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  self_link:                &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  source_ranges.#:          &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
google_compute_firewall.webfirewall: Still creating&hellip; (10s elapsed)
google_compute_firewall.webfirewall: Creation complete after 14s (ID: webserver-firewall)</p>

<p>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</p>

<p>Outputs:</p>

<p>ip = 35.203.117.191
```</p>

<p><strong>T</strong>udo parece ter funcionado. Um novo resource de <em>firewall</em> foi criado e, conforme visto anteriormente, também recebemos o nosso IP como output.</p>

<p><strong>C</strong>onfirme que tudo funcionou como o esperado copiando este IP e colando-o em seu navegador:</p>

<p><img class="center" src="/imgs/gcloud13.png" title="&lsquo;Google Cloud Platform&rsquo;" ></p>

<p><strong>S</strong>e você recebeu uma página em branco com a palavra <em>Testando</em>, significa que tudo ocorreu conforme o esperado.</p>

<p><strong>A</strong>té agora nossa infraestrutura possui:</p>

<ul>
<li>1 VM como servidor Web básico rodando Apache e uma página de teste;</li>
<li>1 rede default;</li>
<li>1 firewall básico aplicado à nossa VM abrindo a porta 80.</li>
</ul>


<p><strong>E</strong>mbora esta seja uma infraestrutura extremamente simples, o Terraform lhe permite criar infraestruturas muito mais complexas e robustas.</p>

<p><strong>N</strong>o próximo post incrementaremos este código para incluírmos a criação de um cluster Kubernetes em nossa <em>cloud</em>.</p>

<p><strong>P</strong>or hora, para não consumir muito de nossos créditos no GCP, vamos destruir nossa infraestrutura com <em>terraform destroy</em>. É tão simples e rápido criar tudo novamente agora que temos o código pronto, certo?! Então destruir tudo não nos causará problemas.</p>

<p>``` yaml
$ terraform destroy
google_compute_firewall.webfirewall: Refreshing state&hellip; (ID: webserver-firewall)
google_compute_instance.webserver: Refreshing state&hellip; (ID: vm-webserver)</p>

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  &ndash; destroy</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li><p>google_compute_firewall.webfirewall</p></li>
<li><p>google_compute_instance.webserver</p></li>
</ul>


<p>Plan: 0 to add, 0 to change, 2 to destroy.</p>

<p>Do you really want to destroy all resources?
  Terraform will destroy all your managed infrastructure, as shown above.
  There is no undo. Only &lsquo;yes&rsquo; will be accepted to confirm.</p>

<p>  Enter a value: yes</p>

<p>google_compute_firewall.webfirewall: Destroying&hellip; (ID: webserver-firewall)
google_compute_instance.webserver: Destroying&hellip; (ID: vm-webserver)
google_compute_firewall.webfirewall: Still destroying&hellip; (ID: webserver-firewall, 10s elapsed)
google_compute_instance.webserver: Still destroying&hellip; (ID: vm-webserver, 10s elapsed)
google_compute_firewall.webfirewall: Destruction complete after 12s
google_compute_instance.webserver: Destruction complete after 14s</p>

<p>Destroy complete! Resources: 2 destroyed.
```</p>

<p><strong>T</strong>udo certo, sua infra foi completamente removida e seus créditos não mais serão utilizados agora.</p>

<p><strong>H</strong>appy hacking!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Terraform: Variáveis e Outputs]]></title>
    <link href="https://kalib.github.io/blog/2018/11/06/terraform-variaveis-e-outputs/"/>
    <updated>2018-11-06T19:26:00-05:00</updated>
    <id>https://kalib.github.io/blog/2018/11/06/terraform-variaveis-e-outputs</id>
    <content type="html"><![CDATA[<p><img class="center" src="/imgs/devops_code.png" title="&lsquo;Devops &ndash; Infrastructure as Code&rsquo;" ></p>

<h2>Onde paramos</h2>

<p><strong>A</strong>ntes de seguir em frente com esta leitura gostaria de dizer que este post é continuação do anterior, onde dei uma breve introdução ao Terraform, com um exemplo prático em que fizemos o deployment de um jogo web do Mario em um container Docker.</p>

<p><strong>E</strong>ste post na verdade utilizará o mesmo código que escrevemos no post anterior, portanto se você não o leu, recomendo fortemente que o faça <a href="/blog/2018/10/29/introducao-ao-terraform">clicando aqui</a>.</p>

<h2>Variáveis</h2>

<p><strong>E</strong>mbora nosso código tenha funcionado corretamente, ele não estava limpo. Existem algumas boas práticas que devemos sempre tentar seguir, Não apenas para deixar o código limpo, mas também para facilitar a manutenção do mesmo.</p>

<p><strong>I</strong>magine o seguinte código em Ruby:</p>

<p><code>rb
puts "Meu nome é Marcelo."
puts "O Marcelo gosta de escrever códigos."
puts "Mas o Marcelo também gosta de surfar."
puts "Não sendo bom o suficiente a ponto de se tornar um profissional do surf, Marcelo decidiu seguir com a carreira de TI."
puts "Este é o Marcelo."
</code></p>

<p><strong>U</strong>m código extremamente simples que apenas imprime diversas strings na tela. Imagine que você precisa fazer manutenção deste código pois sua empresa agora decidiu que o personagem da história seria Pedro e não mais Marcelo. Claro, você pode ir lendo linha a linha e alterando em cada linha, mas isso leva muito mais tempo do que deveria. Imagine agora que este sistema possua algumas centenas de linhas de código. Ou múltiplos arquivos. Começa a ficar mais complexo e demorado alterar tudo, sem falar que fica fácil cometer o erro de esquecer algum. Por outro lado, se o nosso código utilizasse variáveis, apenas trocaríamos o valor em um local, tendo assim certeza absoluta de que o mesmo estaria correto em todo o código. Por exemplo:</p>

<p>``` rb
nome = &ldquo;Marcelo&rdquo;</p>

<p>puts (&ldquo;Meu nome é &rdquo; + nome + &ldquo;.&rdquo;)
puts (&ldquo;O &rdquo; + nome + &ldquo; gosta de escrever códigos.&rdquo;)
puts (&ldquo;Mas o &rdquo; + nome + &ldquo; também gosta de surfar.&rdquo;)
puts (&ldquo;Não sendo bom o suficiente a ponto de se tornar um profissional do surf, &rdquo; + nome + &ldquo; decidiu seguir com a carreira de TI.&rdquo;)
puts (&ldquo;Este é o &rdquo; + nome + &ldquo;.&rdquo;)
```</p>

<p><strong>N</strong>este código, quando precisarmos trocar o nome da pessoa e utilizar Pedro ao invés de Marcelo, precisaríamos alterar apenas o valor da variável na linha 1. muito mais simples, certo?!</p>

<p><strong>D</strong>a mesma forma que em programação básica utilizamos variáveis, quando pensamos em infraestrutura como código deveríamos pensar da mesma forma, afinal estamos programando, certo?! Nao é um sistema, mas ainda assim estamos programando nossa infraestrutura.</p>

<p><strong>E</strong>ste é o nosso arquivo main.tf completo do post anterior:</p>

<p>``` py main.tf</p>

<h1>Baixar a imagem do Projeto Docker-SuperMario</h1>

<p>resource &ldquo;docker_image&rdquo; &ldquo;image_id&rdquo; {
  name = &ldquo;pengbai/docker-supermario:latest&rdquo;
}</p>

<h1>Inicia o Container</h1>

<p>resource &ldquo;docker_container&rdquo; &ldquo;container_id&rdquo; {
  name  = &ldquo;supermario&rdquo;
  image = &ldquo;${docker_image.image_id.latest}&rdquo;
  ports {</p>

<pre><code>internal = "8080"
external = "80"
</code></pre>

<p>  }
}</p>

<h1>Nos informa o ip e nome do container criado</h1>

<p>output &ldquo;Endereco IP&rdquo; {
  value = &ldquo;${docker_container.container_id.ip_address}&rdquo;
}</p>

<p>output &ldquo;Nome do Container&rdquo; {
  value = &ldquo;${docker_container.container_id.name}&rdquo;
}
```</p>

<p><strong>N</strong>este código não estamos utilizando variáveis, embora tenhamos um pouco de interpolação de valores. Vamos então começar a criar algumas variáveis, mas, seguindo as boas práticas do Terraform, criaremos um arquivo separado para nossas variáveis.</p>

<p><strong>C</strong>rie um arquivo chamado <em>variables.tf</em>. O motivo pelo qual utilizaremos o nome em inglês aqui é por ser este o padrão adotado pelo Terraform. Ao chamarmos uma variável em nosso código, o Terraform saberá onde buscar o valor daquela variável.</p>

<p><strong>P</strong>ara cada variável daremos um nome, uma descrição e um valor <em>default</em>. Nosso arquivo <em>variables.tf</em> ficará assim:</p>

<p>``` py variables.tf
variable &ldquo;nome_container&rdquo; {
  description = &ldquo;Nome do container&rdquo;
  default = &ldquo;supermario&rdquo;
}</p>

<p>variable &ldquo;imagem&rdquo; {
  description = &ldquo;Imagem do container&rdquo;
  default = &ldquo;pengbai/docker-supermario:latest&rdquo;
}</p>

<p>variable &ldquo;porta_interna&rdquo; {
  description = &ldquo;Porta interna do container&rdquo;
  default = &ldquo;8080&rdquo;
}</p>

<p>variable &ldquo;porta_externa&rdquo; {
  description = &ldquo;Porta externa do container&rdquo;
  default = &ldquo;80&rdquo;
}
```</p>

<p><strong>O</strong> que definimos:</p>

<ol>
<li>Criamos 4 variáveis aqui: <em>nome_container</em>, <em>imagem</em>, <em>porta_interna</em> e <em>porta_externa</em>;</li>
<li>Para cada variável nós demos 2 atributos: <em>description</em> (descrição) e <em>default</em> (Valor padrão);</li>
<li>Variáveis não precisam ser sempre declaradas. Existem ocasiões em que podemos criar uma variável sem qualquer valor atribuído à mesma, de forma que o valor será passado durante a execução do código, por exemplo. Por padrão, quando queremos que a variável possua um valor inicial padrão, o terraform utiliza o atributo <em>default</em>;</li>
<li>A <em>description</em>, ou descrição, é um atributo também opcional, mas ajuda a identificar melhor o que se pretende com aquela variável e costuma ser uma boa prática, dando maior legibilidade ao seu código.</li>
</ol>


<p><strong>A</strong>gora que temos um arquivo com estas 4 variáveis, devemos voltar ao nosso arquivo <em>main.tf</em> e alterar um pouco nosso código para que possamos fazer uso destas variáveis. Iremso alterar nosso código bloco a bloco para ficar mais fácil identificarmos as diferenças.</p>

<p><strong>C</strong>omecemos com o resource <em>docker_image</em>, que agora ficará da seguinte forma em nosso arquivo <em>main.tf</em>:</p>

<p>``` py main.tf</p>

<h1>Baixar a imagem do Projeto Docker-SuperMario</h1>

<p>resource &ldquo;docker_image&rdquo; &ldquo;image_id&rdquo; {
  name = &ldquo;${var.imagem}&rdquo;
}
```</p>

<p><strong>O</strong> que alteramos:</p>

<ol>
<li>Nas linhas 1 e 2 não alteramos nada, pois são apenas comentários e a abertura de nosso <em>resource</em>;</li>
<li>Na linha 3 tínhamos <em>name = &ldquo;pengbai/docker-supermario:latest&rdquo;</em> e agora temos <em>name = &ldquo;${var.imagem}&rdquo;</em>. Basicamente indicamos que o valor para <em>name</em> agora deverá ser pego a partir de nossa variável <em>imagem</em> em nosso arquivo <em>variables.tf</em>. Sim, para pegarmos o valor de uma variável, no Terraform, utilizamos sempre esta sintaxe: <em>&ldquo;${}&rdquo;</em>. Dentro das chaves iremos indicar onde se encontra a nossa variável. quando utilizamos o prefixo <em>var</em>, o Terraform busca automaticamente o valor em um arquivo <em>variables.tf</em>. Existem outras formas de declarar variáveis, mas não nos preocuparemos com isso por enquanto. Se checarmos novamente nosso arquivo <em>variables.tf</em> veremos a variável <em>imagem</em> que criamos, cujo valor é exatamente <em>pengbai/docker-supermario:latest</em>;</li>
<li>Novamente, na linha 4, nenhuma alteração foi feita. Estamos apenas fechando nosso bloco de <em>resource</em>.</li>
</ol>


<p><strong>V</strong>amos ao nosso próximo bloco de código, nosso <em>resource</em> <em>docker_container</em>. Alteremos o código para que fique da seguinte forma:</p>

<p>``` py main.tf</p>

<h1>Baixar a imagem do Projeto Docker-SuperMario</h1>

<p>resource &ldquo;docker_image&rdquo; &ldquo;image_id&rdquo; {
  name = &ldquo;${var.imagem}&rdquo;
}</p>

<h1>Inicia o Container</h1>

<p>resource &ldquo;docker_container&rdquo; &ldquo;container_id&rdquo; {
  name  = &ldquo;${var.nome_container}&rdquo;
  image = &ldquo;${docker_image.image_id.latest}&rdquo;
  ports {</p>

<pre><code>internal = "${var.porta_interna}"
external = "${var.porta_externa}"
</code></pre>

<p>  }
}
```</p>

<p><strong>D</strong>a mesma forma que fizemos antes, apenas trouxemos nossas variáveis:</p>

<ol>
<li>Na linha 8 passamos a utilizar a variável <em>nome_container</em> que criamos para dar o nome ao nosso container. Novamente, em nosso arquivo <em>variables.tf</em> você será capaz de encontrar a variável <em>nome_container</em>, cujo valor default é <em>supermario</em>;</li>
<li>Na linha 11 apenas trocamos o valor <em>8080</em> pela variável <em>porta_interna</em>, assim como específicamos em nosso arquivo <em>variables.tf</em>;</li>
<li>Na linha 12, assim como na linha 11, apenas trocamos o valor <em>80</em> pela variável <em>porta_externa</em>.</li>
</ol>


<p><strong>N</strong>osso arquivo <em>main.tf</em> agora deverá estar assim:</p>

<p>``` py main.tf</p>

<h1>Baixar a imagem do Projeto Docker-SuperMario</h1>

<p>resource &ldquo;docker_image&rdquo; &ldquo;image_id&rdquo; {
  name = &ldquo;${var.imagem}&rdquo;
}</p>

<h1>Inicia o Container</h1>

<p>resource &ldquo;docker_container&rdquo; &ldquo;container_id&rdquo; {
  name  = &ldquo;${var.nome_container}&rdquo;
  image = &ldquo;${docker_image.image_id.latest}&rdquo;
  ports {</p>

<pre><code>internal = "${var.porta_interna}"
external = "${var.porta_externa}"
</code></pre>

<p>  }
}</p>

<h1>Nos informa o ip e nome do container criado</h1>

<p>output &ldquo;Endereco IP&rdquo; {
  value = &ldquo;${docker_container.container_id.ip_address}&rdquo;
}</p>

<p>output &ldquo;Nome do Container&rdquo; {
  value = &ldquo;${docker_container.container_id.name}&rdquo;
```</p>

<p><strong>A</strong>cho sempre interessante fazer testes constantes em nosso código para ter certeza de que tudo está funcionando conforme o esperado. Como alteramos um pouco nosso código, criando variáveis em um arquivo <em>variables.tf</em> e removemos de nosso <em>main.tf</em> valores absolutos para fazermos uso de variáveis, é bom termos certeza de que não cometemos nenhum erro. Assumindo que temos o serviço do Docker rodando, vamos ao nosso terminal e, dentro de nosso diretório <em>marioweb</em> criado no posto anterior, vamos nos certificar de que destruímos a aplicação do post anterior para que não tenhamos nenhum container rodando:</p>

<p><code>yaml
$ terraform destroy
</code></p>

<p><strong>A</strong>gora vamos executar nosso <em>plan</em>:</p>

<p>``` yaml
$ terraform plan</p>

<p>Refreshing Terraform state in-memory prior to plan&hellip;
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.</p>

<hr />

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li><p>docker_container.container_id
  id:               <computed>
  attach:           &ldquo;false&rdquo;
  bridge:           <computed>
  container_logs:   <computed>
  exit_code:        <computed>
  gateway:          <computed>
  image:            &ldquo;${docker_image.image_id.latest}&rdquo;
  ip_address:       <computed>
  ip_prefix_length: <computed>
  log_driver:       &ldquo;json-file&rdquo;
  logs:             &ldquo;false&rdquo;
  must_run:         &ldquo;true&rdquo;
  name:             &ldquo;supermario&rdquo;
  network_data.#:   <computed>
  ports.#:          &ldquo;1&rdquo;
  ports.0.external: &ldquo;80&rdquo;
  ports.0.internal: &ldquo;8080&rdquo;
  ports.0.ip:       &ldquo;0.0.0.0&rdquo;
  ports.0.protocol: &ldquo;tcp&rdquo;
  restart:          &ldquo;no&rdquo;
  rm:               &ldquo;false&rdquo;
  start:            &ldquo;true&rdquo;</p></li>
<li><p>docker_image.image_id
  id:               <computed>
  latest:           <computed>
  name:             &ldquo;pengbai/docker-supermario:latest&rdquo;</p></li>
</ul>


<p>Plan: 2 to add, 0 to change, 0 to destroy.</p>

<hr />

<p>Note: You didn&rsquo;t specify an &ldquo;-out&rdquo; parameter to save this plan, so Terraform
can&rsquo;t guarantee that exactly these actions will be performed if
&ldquo;terraform apply&rdquo; is subsequently run.
```</p>

<p><strong>A</strong>parentemente está tudo correto. Na saída de nosso <em>plan</em> podemos ver que os valores estão de acordo com o esperado. Apliquemos então nosso código com <em>terraform apply</em>:</p>

<p>``` yaml
$ terraform apply</p>

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li><p>docker_container.container_id
  id:               <computed>
  attach:           &ldquo;false&rdquo;
  bridge:           <computed>
  container_logs:   <computed>
  exit_code:        <computed>
  gateway:          <computed>
  image:            &ldquo;${docker_image.image_id.latest}&rdquo;
  ip_address:       <computed>
  ip_prefix_length: <computed>
  log_driver:       &ldquo;json-file&rdquo;
  logs:             &ldquo;false&rdquo;
  must_run:         &ldquo;true&rdquo;
  name:             &ldquo;supermario&rdquo;
  network_data.#:   <computed>
  ports.#:          &ldquo;1&rdquo;
  ports.0.external: &ldquo;80&rdquo;
  ports.0.internal: &ldquo;8080&rdquo;
  ports.0.ip:       &ldquo;0.0.0.0&rdquo;
  ports.0.protocol: &ldquo;tcp&rdquo;
  restart:          &ldquo;no&rdquo;
  rm:               &ldquo;false&rdquo;
  start:            &ldquo;true&rdquo;</p></li>
<li><p>docker_image.image_id
  id:               <computed>
  latest:           <computed>
  name:             &ldquo;pengbai/docker-supermario:latest&rdquo;</p></li>
</ul>


<p>Plan: 2 to add, 0 to change, 0 to destroy.</p>

<p>Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only &lsquo;yes&rsquo; will be accepted to approve.</p>

<p>  Enter a value:
```</p>

<p><strong>A</strong>ssim como vimos no post anterior, o <em>terraform apply</em> sempre nos apresenta uma prévia das tarefas que serão executadas e em seguida nos pede uma confirmação de execução. Como tudo parece correto, vamos confirmar com um <em>yes</em>:</p>

<p>``` yaml</p>

<p>  Enter a value: yes</p>

<p>docker_image.image_id: Creating&hellip;
  latest: &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  name:   &ldquo;&rdquo; => &ldquo;pengbai/docker-supermario:latest&rdquo;
docker_image.image_id: Still creating&hellip; (10s elapsed)
docker_image.image_id: Still creating&hellip; (20s elapsed)
docker_image.image_id: Still creating&hellip; (30s elapsed)
docker_image.image_id: Creation complete after 37s (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7&hellip;9c3d62pengbai/docker-supermario:latest)
docker_container.container_id: Creating&hellip;
  attach:           &ldquo;&rdquo; => &ldquo;false&rdquo;
  bridge:           &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  container_logs:   &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  exit_code:        &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  gateway:          &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  image:            &ldquo;&rdquo; => &ldquo;sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62&rdquo;
  ip_address:       &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  ip_prefix_length: &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  log_driver:       &ldquo;&rdquo; => &ldquo;json-file&rdquo;
  logs:             &ldquo;&rdquo; => &ldquo;false&rdquo;
  must_run:         &ldquo;&rdquo; => &ldquo;true&rdquo;
  name:             &ldquo;&rdquo; => &ldquo;supermario&rdquo;
  network_data.#:   &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  ports.#:          &ldquo;&rdquo; => &ldquo;1&rdquo;
  ports.0.external: &ldquo;&rdquo; => &ldquo;80&rdquo;
  ports.0.internal: &ldquo;&rdquo; => &ldquo;8080&rdquo;
  ports.0.ip:       &ldquo;&rdquo; => &ldquo;0.0.0.0&rdquo;
  ports.0.protocol: &ldquo;&rdquo; => &ldquo;tcp&rdquo;
  restart:          &ldquo;&rdquo; => &ldquo;no&rdquo;
  rm:               &ldquo;&rdquo; => &ldquo;false&rdquo;
  start:            &ldquo;&rdquo; => &ldquo;true&rdquo;
docker_container.container_id: Creation complete after 1s (ID: bbe9e8e7b5428532b882e7fbd304fc2b3d71e0bcb29fa099e15162397731e15e)</p>

<p>Apply complete! Resources: 2 added, 0 changed, 0 destroyed.</p>

<p>Outputs:</p>

<p>Endereco IP = 172.17.0.2
Nome do Container = supermario
```</p>

<p><strong>A</strong>parentemente tudo saiu conforme o esperado, com 2 <em>resources</em> adicionados, sendo eles nossa imagem e nosso container.</p>

<p><strong>N</strong>ovamente, podemos verificar que tudo está correto através do comando <em>docker ps</em>, onde deveremos ver que nosso container está rodando:</p>

<p>``` yaml
$ docker ps</p>

<p>CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS                  NAMES
bbe9e8e7b542        49beaba1c5cc        &ldquo;catalina.sh run&rdquo;   About a minute ago   Up About a minute   0.0.0.0:80->8080/tcp   supermario
```</p>

<p><strong>T</strong>ambém podemos tentar acessar em nosso browser ou navegador o seguinte endereço: <em>localhost:80</em>. Nosso jogo do mario deverá estar funcionando.</p>

<p><strong>A</strong>gora que entendemos o básico sobre o uso de variáveis e vimos que nosso código, embora um pouco diferente, continua funcionando, chegou a hora de corrigirmos nossos <em>outputs</em>. Eles continuam funcionando, porém para seguirmos os padrões e melhores práticas, vamos também retirá-los de nosso <em>main.tf</em> e criar um arquivo dedicado para isto.</p>

<h2>Outputs</h2>

<p><strong>C</strong>omecemos criando um arquivo chamado <em>outputs.tf</em> com o seguinte conteúdo:</p>

<p>``` py outputs.tf</p>

<h1>Nos informa o ip e nome do container criado</h1>

<p>output &ldquo;Endereco IP&rdquo; {
  value = &ldquo;${docker_container.container_id.ip_address}&rdquo;
}</p>

<p>output &ldquo;Nome do Container&rdquo; {
  value = &ldquo;${docker_container.container_id.name}&rdquo;
}
```</p>

<p><strong>E</strong>ste foi fácil, certo?! Se prestarmos atenção, não alteramos praticamente nada. Apenas copiamos os dois blocos <em>outputs</em> do arquivo <em>main.tf</em> sem qualquer alteração.</p>

<p><strong>A</strong>pós salvar nosso arquivo <em>outputs.tf</em>, removeremos estes dois <em>outputs</em> do arquivo <em>main.tf</em>. Nosso <em>main.tf</em> ficará assim:</p>

<p>``` py main.tf</p>

<h1>Baixar a imagem do Projeto Docker-SuperMario</h1>

<p>resource &ldquo;docker_image&rdquo; &ldquo;image_id&rdquo; {
  name = &ldquo;${var.imagem}&rdquo;
}</p>

<h1>Inicia o Container</h1>

<p>resource &ldquo;docker_container&rdquo; &ldquo;container_id&rdquo; {
  name  = &ldquo;${var.nome_container}&rdquo;
  image = &ldquo;${docker_image.image_id.latest}&rdquo;
  ports {</p>

<pre><code>internal = "${var.porta_interna}"
external = "${var.porta_externa}"
</code></pre>

<p>  }
}
```</p>

<p><strong>S</strong>imples, não? Nosso código está mais limpo e organizado. Vamos destuir novamente nosso projeto com <em>terraform destroy</em> para que possamos testar estas últimas alterações:</p>

<p>``` yaml
$ terraform destroy</p>

<p>docker_image.image_id: Refreshing state&hellip; (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7&hellip;9c3d62pengbai/docker-supermario:latest)
docker_container.container_id: Refreshing state&hellip; (ID: bbe9e8e7b5428532b882e7fbd304fc2b3d71e0bcb29fa099e15162397731e15e)</p>

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  &ndash; destroy</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li><p>docker_container.container_id</p></li>
<li><p>docker_image.image_id</p></li>
</ul>


<p>Plan: 0 to add, 0 to change, 2 to destroy.</p>

<p>Do you really want to destroy all resources?
  Terraform will destroy all your managed infrastructure, as shown above.
  There is no undo. Only &lsquo;yes&rsquo; will be accepted to confirm.</p>

<p>  Enter a value: yes</p>

<p>docker_container.container_id: Destroying&hellip; (ID: bbe9e8e7b5428532b882e7fbd304fc2b3d71e0bcb29fa099e15162397731e15e)
docker_container.container_id: Destruction complete after 1s
docker_image.image_id: Destroying&hellip; (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7&hellip;9c3d62pengbai/docker-supermario:latest)
docker_image.image_id: Destruction complete after 1s</p>

<p>Destroy complete! Resources: 2 destroyed.
```</p>

<p><strong>A</strong>gora vamos aplicar nosso <em>plan</em> e em seguida, caso tudo esteja correto, vamos executar <em>terraform plan</em>:</p>

<p>``` yaml
$ terraform plan</p>

<p>Refreshing Terraform state in-memory prior to plan&hellip;
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.</p>

<hr />

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li><p>docker_container.container_id
  id:               <computed>
  attach:           &ldquo;false&rdquo;
  bridge:           <computed>
  container_logs:   <computed>
  exit_code:        <computed>
  gateway:          <computed>
  image:            &ldquo;${docker_image.image_id.latest}&rdquo;
  ip_address:       <computed>
  ip_prefix_length: <computed>
  log_driver:       &ldquo;json-file&rdquo;
  logs:             &ldquo;false&rdquo;
  must_run:         &ldquo;true&rdquo;
  name:             &ldquo;supermario&rdquo;
  network_data.#:   <computed>
  ports.#:          &ldquo;1&rdquo;
  ports.0.external: &ldquo;80&rdquo;
  ports.0.internal: &ldquo;8080&rdquo;
  ports.0.ip:       &ldquo;0.0.0.0&rdquo;
  ports.0.protocol: &ldquo;tcp&rdquo;
  restart:          &ldquo;no&rdquo;
  rm:               &ldquo;false&rdquo;
  start:            &ldquo;true&rdquo;</p></li>
<li><p>docker_image.image_id
  id:               <computed>
  latest:           <computed>
  name:             &ldquo;pengbai/docker-supermario:latest&rdquo;</p></li>
</ul>


<p>Plan: 2 to add, 0 to change, 0 to destroy.</p>

<hr />

<p>Note: You didn&rsquo;t specify an &ldquo;-out&rdquo; parameter to save this plan, so Terraform
can&rsquo;t guarantee that exactly these actions will be performed if
&ldquo;terraform apply&rdquo; is subsequently run.
```</p>

<p>``` yaml
$ terraform apply</p>

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li><p>docker_container.container_id
  id:               <computed>
  attach:           &ldquo;false&rdquo;
  bridge:           <computed>
  container_logs:   <computed>
  exit_code:        <computed>
  gateway:          <computed>
  image:            &ldquo;${docker_image.image_id.latest}&rdquo;
  ip_address:       <computed>
  ip_prefix_length: <computed>
  log_driver:       &ldquo;json-file&rdquo;
  logs:             &ldquo;false&rdquo;
  must_run:         &ldquo;true&rdquo;
  name:             &ldquo;supermario&rdquo;
  network_data.#:   <computed>
  ports.#:          &ldquo;1&rdquo;
  ports.0.external: &ldquo;80&rdquo;
  ports.0.internal: &ldquo;8080&rdquo;
  ports.0.ip:       &ldquo;0.0.0.0&rdquo;
  ports.0.protocol: &ldquo;tcp&rdquo;
  restart:          &ldquo;no&rdquo;
  rm:               &ldquo;false&rdquo;
  start:            &ldquo;true&rdquo;</p></li>
<li><p>docker_image.image_id
  id:               <computed>
  latest:           <computed>
  name:             &ldquo;pengbai/docker-supermario:latest&rdquo;</p></li>
</ul>


<p>Plan: 2 to add, 0 to change, 0 to destroy.</p>

<p>Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only &lsquo;yes&rsquo; will be accepted to approve.</p>

<p>  Enter a value: yes</p>

<p>docker_image.image_id: Creating&hellip;
  latest: &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  name:   &ldquo;&rdquo; => &ldquo;pengbai/docker-supermario:latest&rdquo;
docker_image.image_id: Still creating&hellip; (10s elapsed)
docker_image.image_id: Still creating&hellip; (20s elapsed)
docker_image.image_id: Still creating&hellip; (30s elapsed)
docker_image.image_id: Still creating&hellip; (40s elapsed)
docker_image.image_id: Creation complete after 42s (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7&hellip;9c3d62pengbai/docker-supermario:latest)
docker_container.container_id: Creating&hellip;
  attach:           &ldquo;&rdquo; => &ldquo;false&rdquo;
  bridge:           &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  container_logs:   &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  exit_code:        &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  gateway:          &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  image:            &ldquo;&rdquo; => &ldquo;sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62&rdquo;
  ip_address:       &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  ip_prefix_length: &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  log_driver:       &ldquo;&rdquo; => &ldquo;json-file&rdquo;
  logs:             &ldquo;&rdquo; => &ldquo;false&rdquo;
  must_run:         &ldquo;&rdquo; => &ldquo;true&rdquo;
  name:             &ldquo;&rdquo; => &ldquo;supermario&rdquo;
  network_data.#:   &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  ports.#:          &ldquo;&rdquo; => &ldquo;1&rdquo;
  ports.0.external: &ldquo;&rdquo; => &ldquo;80&rdquo;
  ports.0.internal: &ldquo;&rdquo; => &ldquo;8080&rdquo;
  ports.0.ip:       &ldquo;&rdquo; => &ldquo;0.0.0.0&rdquo;
  ports.0.protocol: &ldquo;&rdquo; => &ldquo;tcp&rdquo;
  restart:          &ldquo;&rdquo; => &ldquo;no&rdquo;
  rm:               &ldquo;&rdquo; => &ldquo;false&rdquo;
  start:            &ldquo;&rdquo; => &ldquo;true&rdquo;
docker_container.container_id: Creation complete after 1s (ID: 5619b9c45b2509ca1a67cb1d43ea8e91f156f44245539604ad3dd060793900a4)</p>

<p>Apply complete! Resources: 2 added, 0 changed, 0 destroyed.</p>

<p>Outputs:</p>

<p>Endereco IP = 172.17.0.2
Nome do Container = supermario
```</p>

<p><strong>S</strong>ucesso. Tudo saiu como o esperado e nossa aplicação está novamente no ar. Sinta-se livre para executar <em>docker ps</em> ou mesmo acessar <em>localhost:80</em> em seu navegador para ter certeza de que tudo está funcionando e de que seu jogo Mario está no ar.</p>

<h3>Atenção: Outputs como variáveis de saída</h3>

<p><strong>D</strong>a mesma forma que eu citei que existem outras formas de se declarar e utilizar variáveis, existem outras funções também para os <em>outputs</em>. Não, o Terraform não utiliza <em>outputs</em> apenas para apresentar informações na tela. A principal função dos <em>outputs</em> é na verdade a de variáveis de saída. Ou seja, pegar valores que poderão ser utilizados posteriormente. Este recurso é muito utilizado em projetos maiores com infraestruturas mais complexas mas, novamente, não é o foco deste post abordar isto.</p>

<p><strong>S</strong>e você é um pouco atencioso e curioso, deve ter notado que não definimos os valores dos <em>outputs</em> em nenhum momento, certo? Por exemplo: <em>value = &ldquo;${docker_container.container_id.ip_address}&rdquo;</em></p>

<p><strong>O</strong>u seja, estamos criando um <em>output</em> cujo valor será na verdade uma saída após o processamento de nosso código Terraform. Desta forma, nossos <em>outputs</em> são na verdade variáveis de saída.. mas isso já é uma outra história.</p>

<p><strong>A</strong> propósito, se você além de curioso é também meticuloso, deve ter ficado confuso e questionado: <em>Se outputs são na verdade uma espécie de variáveis, como podemos ter espaços em seus nomes? Como por exemplo &ldquo;Nome do Container&rdquo;?</em></p>

<p><strong>A</strong> resposta é: Você me pegou. As melhores práticas pregam que não devemos criar <em>outputs</em> com espaços. Porque? Porque variáveis não podem conter espaços. Mas, como desde o início nosso objetivo era utilizar os <em>outputs</em> aqui apenas para nos retornar algum valor na tela, resolvi utilizar palavras em portugês e com espaços para facilitar a compreensão.</p>

<p><strong>O</strong> ideal seria termos utilizado <em>nome_do_container</em> ao invés de <em>Nome do Container</em>, ou <em>endereco_ip</em> ao invés de <em>Endereco IP</em> mas, novamente.. isto é uma outra história.</p>

<p><strong>L</strong>embre-se de destuir o seu projeto para não deixar um container rodando desnecessariamente: <em>$ terraform destroy</em></p>

<p><strong>E</strong>m meu próximo post pretendo elevar um pouco o nível e utilizar o Terraform para criarmos uma infraestrutura básica na nuvem.</p>

<p><strong>H</strong>appy Hacking!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introdução ao Terraform]]></title>
    <link href="https://kalib.github.io/blog/2018/10/29/introducao-ao-terraform/"/>
    <updated>2018-10-29T21:35:00-04:00</updated>
    <id>https://kalib.github.io/blog/2018/10/29/introducao-ao-terraform</id>
    <content type="html"><![CDATA[<p><img class="center" src="/imgs/terraform-integrations.png" title="&lsquo;Terraform&rsquo;" ></p>

<h2>Terraform &ndash; Uma robusta opção para Infraestrutura como Código</h2>

<p><strong>A</strong> Hashicorp é uma empresa de bastante destaque no meio DevOps por ter criado várias soluções de automação, que englobam uma série de funcionalidades, como o <a href="https://packer.io">Packer</a> para criação de imagens de forma automatizada, conforme apresentado nestes dois posts  do blog (<a href="https://blog.marcelocavalcante.net/blog/2018/07/30/automatizando-a-criacao-de-imagens-com-packer/">1</a>, <a href="https://blog.marcelocavalcante.net/blog/2018/08/11/criando-uma-imagem-aws-ec2-com-packer-e-puppet/">2</a>), <a href="https://vagrant.io">Vagrant</a>, para provisionamento simples e rápido de máquinas, <a href="https://vaultproject.io">Vault</a>, para gerenciamento de senhas/segredos (<em>secrets</em>), <a href="https://consul.io">Consul</a>, para descoberta de serviços, <a href="nomadproject.io">Nomad</a>, para agendamento e automação de deployments, e o <a href="https://terraform.io">Terraform</a>, foco principal deste post, uma robusta ferramenta para criação de infraestrutura como código, ou <em>infrastructure as cdode</em>.</p>

<p><strong>C</strong>aso você não possua uma ideia muito clara de qual a idea por trás do conceito de infraestrutura como código, ou mesmo quais as vantagens de se utilizar esta metodologia de gerenciamento/criação de infraestrutura, sugiro que leia meu <a href="https://blog.marcelocavalcante.net/blog/2018/10/22/infraestrutura-como-codigo-com-terraform/">post anterior</a>, no qual explico alguns dos principais benefícios desta prática, bem como uma breve apresentação do Terraform.</p>

<p><strong>D</strong>e forma resumida, o Terraform é uma ferramenta disponível em formatos Open Source ou Enterprise, cujo intuito é permitir a criação de infraestrutura como código, possibilitando o controle de versões. Suporta diversos provedores tais como AWS, OpenStack, Azure, GCP, etc.</p>

<p><strong>U</strong>ma de suas principais características é a idempotência, termo muito utilizado na matemática ou em ciência da computação para indicar a propriedade que algumas operações têm de poderem ser aplicadas várias vezes sem que o valor do resultado se altere após a aplicação inicial. Ou seja, uma vez aplicado o seu código terraform, você poderá aplicá-lo quantas vezes desejar e nenhuma alteração será feita em sua infraestrutura, a menos que você tenha de fato alterado algo em seu código.</p>

<p><strong>O</strong> Terraform utiliza uma linguagem de alto nível e fácil de se reutilizar, uma vez que podemos criar módulos e utilizar estes módulos em diversos projetos distintos, mesmo que tenhamos módulos em repositórios também distintos.</p>

<p><strong>A</strong> ideia de possuir um &ldquo;plano&rdquo; de execução nos ajuda a identificar falhas em nosso código mais rapidamente, bem como prevenir problemas em nossa infraestrutura, visto que podemos ter uma visão geral de tudo o que será aplicado em nossa infra antes mesmo da execução real de nosso código, nos permitindo ter a certeza de que todas as alterações serão de fato intencionais.</p>

<p><strong>S</strong>empre digo que a melhor forma de se aprender uma nova tecnologia é colocando a mão na massa, portanto vamos escrever algumas linhas de código para entendermos as funcionalidades básicas bem como a sintaxe de código utilizada pelo Terraform.</p>

<p><strong>A</strong>ntes de pensarmos em cenários mais complexos devemos entender o básico, no entanto eu sempre gostei de ver algum resultado como forma de ter uma motivação real para meus estudos. Nunca gostei de apenas ler e escrever códigos que não resultam em nada, e acredito que todos devam sentir a mesma insatisfação ao não ter um uso real e prático para o que quer que esteja estudando.</p>

<p><strong>S</strong>eguindo esta ideia, antes de pensarmos em cenários mais complexos, vamos iniciar pelo básico, porém com algum resultado prático. A ideia para este post é termos um jogo clássico do Mario rodando em um container Docker que seja acessível através de nosso browser.</p>

<h2>Instalação</h2>

<p><strong>P</strong>ara este post precisaremos ter três aplicativos instalados:</p>

<ol>
<li>Um navegador ou browser qualquer; (Imagino que você já tenha algum&hellip;)</li>
<li>Docker;</li>
<li>Terraform</li>
</ol>


<h3>Docker</h3>

<p><strong>O</strong> processo de instalação do Docker varia de acordo com o seu sistema operacional. Caso queira maiores detalhes sobre sua instalação, bem como uma explicação introdutória de como ele funciona, você pode visitar <a href="https://blog.marcelocavalcante.net/blog/2015/08/20/docker-uma-alternativa-elegante-para-containers-no-linux/">este outro post</a>, embora você não precise ter nenhum conhecimento sobre Docker para seguir as instruções deste tutorial, visto que utilizaremos o Terraform para criar nosso container.</p>

<p><strong>N</strong>o <em>Archlinux</em> a instalação pode ser feita através do pacman:</p>

<p>```</p>

<h1>pacman install docker</h1>

<p>```</p>

<p><strong>N</strong>o <em>Windows</em> a instalação pode ser feita através do binário disponível no site oficial: (<a href="https://store.docker.com/editions/community/docker-ce-desktop-windows">https://store.docker.com/editions/community/docker-ce-desktop-windows</a>)</p>

<p><strong>N</strong>o <em>OS X</em>, você também pode baixar o binário diretamente no site oficial, (<a href="https://store.docker.com/editions/community/docker-ce-desktop-mac">https://store.docker.com/editions/community/docker-ce-desktop-mac</a>) ou através do brew:</p>

<p><code>
brew install docker
</code></p>

<h3>Terraform</h3>

<p><strong>A</strong> instalação do Terraform é tão simples quanto a do Docker.</p>

<p><strong>N</strong>o <em>Archlinux</em> a instalação pode ser feita através do pacman:</p>

<p>```</p>

<h1>pacman -S terraform</h1>

<p>```</p>

<p><strong>N</strong>o <em>Windows</em> e no <em>OS X</em> a instalação pode ser feita através do binário disponível no site oficial do Terraform: (<a href="https://www.terraform.io/downloads.html">https://www.terraform.io/downloads.html</a>)</p>

<p><strong>O</strong>utra opção para OS X é através do brew:</p>

<p><code>
brew install terraform
</code></p>

<h2>Verificando a instalação</h2>

<p><strong>U</strong>ma vez que você tenha instalado ambos, certifique-se de que a instalação foi bem sucedida e de que o serviço Docker esteja rodando em seu sistema. Para isto, abra algum terminal, console ou prompt do CMD (para usuários Windows) e digite o seguinte:</p>

<p>1- Para termos certeza de que o Terraform está instalado e funcionando:
<code>
terraform -version
</code></p>

<p>Você deverá receber algum resultado com a versão do seu Terraform, similar a este:</p>

<p><code>
Terraform v0.11.10
</code></p>

<p>2- Para termos certeza de que o Docker está devidamente instalado e rodando, digite:
<code>
docker ps
</code></p>

<p>Você deverá receber algum resultado parecido com o seguinte:</p>

<p><code>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></p>

<p><strong>N</strong>ão se assuste ou dê importância para este resultado do comando Docker, ele apenas indica o status atual de seu Docker, informando se você possui algum container rodando ou não. Caso você tenha acabado de instalar o mesmo ou iniciado o serviço do Docker, você provavelmente não terá nenhum container rodando.</p>

<p><strong>C</strong>aso o retorno de seu Docker ou Terraform não seja similar aos que apresentei acima, verifique se a instalação foi realmente bem sucedida ou, no caso do Docker, verifique se o mesmo está rodando, afinal ele não apenas precisa ser instalado, mas precisa estar rodando, diferentemente do Terraform que apenas precisa ser instalado.</p>

<h2>Iniciando nosso projeto</h2>

<p><img class="center" src="/imgs/mariodocker.png" title="&lsquo;Super Mario&rsquo;" ></p>

<h3>Escopo</h3>

<p><strong>O</strong> primeiro passo de qualquer projeto é identificar alguma espécie de esboço ou escopo para o mesmo.</p>

<p><strong>O</strong> que queremos para o nosso projeto é:</p>

<ol>
<li>Ter um jogo web do Mario;</li>
<li>Queremos que ele rode em um container, pois queremos uma aplicação em uma infraestrutura moderna e que possa ser capaz de rodar em qualquer local, seja em um servidor físico local, uma VM ou mesmo um provedor na nuvem, como AWS, GCP, Azure, etc.;</li>
<li>Como não sabemos onde ou como iremos fazer o deployment deste container, queremos fazer com que seja algo automatizado e portável para facilitar futuros planos, portanto queremos criar este container com o Terraform, para que possamos gerenciar nosso código, versionar, etc.</li>
<li>Não escreveremos a aplicação em si. O jogo do Mario já existe e uma imagem para Docker já está disponível para o mesmo através do seguinte link: (<a href="https://hub.docker.com/r/pengbai/docker-supermario/">https://hub.docker.com/r/pengbai/docker-supermario/</a>) (Mas nós não precisamos nos precoupar com isto agora, pois o Terraform vai cuidar de baixar a imagem para nós. ;])</li>
<li>A aplicação deverá estar acessível via browser local para que possamos ao menos garantir que o jogo está de fato funcionando.</li>
</ol>


<p><strong>E</strong>ste será o nosso escopo básico, portanto vamos começar nosso código.</p>

<h3>Projeto</h3>

<p><strong>O</strong> recurso mais básico em um código ou módulo Terraform é o <em>resource</em>, ou recurso. O Terraform suporta centenas de recursos diferentes, dentre eles o <em>docker_image</em>, que será o recurso de que precisaremos inicialmente.</p>

<p><strong>A</strong> partir deste momento não mais utilizarei a palavra recurso. Uma vez que o Terraform chama os recursos de <em>resources</em>, devemos nos acostumar com sua nomenclatura.</p>

<p><strong>A</strong>ntes de mais nada, vamos criar um diretório para nosso projeto. Chamaremos nosso projeto de Marioweb, visto que se trata de uma versao open source do jogo Mario.</p>

<p><strong>A</strong>qui estarei criando o diretório via linha de comando, mas sinta-se livre para criar um diretório da forma que você preferir. Após criar o diretório, com algum terminal ou console aberto (ou prompt do CMD para usuários do Windows), navegue até este diretório recém criado:</p>

<p>```
$ mkdir marioweb</p>

<p>$ cd marioweb
```</p>

<p><strong>D</strong>entro do diretório <em>marioweb</em> crie um novo arquivo chamado <em>main.tf</em>.</p>

<p><strong>P</strong>ara manter um padrão, os arquivos de código do Terraform costumam utilizar o sufixo/extensão .tf e o principal arquivo em módulos ou projetos Terraform costuma se chamar <em>main.tf</em>, por se tratar do arquivo principal do módulo ou projeto.</p>

<p><strong>P</strong>ara criar este arquivo você poderá utilizar qualquer editor de textos de sua escolha: vim, emacs, vi, notepad, notepad++, sublime, atom, etc.</p>

<p><strong>E</strong>m nosso arquivo <em>main.tf</em> insira o seguinte conteúdo por enquanto:</p>

<p><strong>main.tf</strong></p>

<p>``` py main.tf</p>

<h1>Baixar a imagem do Projeto Docker-SuperMario</h1>

<p>resource &ldquo;docker_image&rdquo; &ldquo;image_id&rdquo; {
  name = &ldquo;pengbai/docker-supermario:latest&rdquo;
}
```</p>

<p><strong>O</strong> que temos no bloco de código acima:</p>

<ol>
<li>A primeira linha é apenas um comentário. Como boa prática, é importante termos comentários ao longo de nosso código para descrever o que pretendemos com aquele determinado trecho de código. E por hora, o que pretendemos é exatamente apenas isso: <em>Baixar a imagem do Projeto Docker-SuperMario</em> para nosso ambiente.</li>
<li>Na linha 2 estamos especificando que queremos utilizar um <em>resource</em>. Cada <em>resource</em> no Terraform leva dois parâmetros, sendo um deles o <em>tipo de resource</em> e o outro um <em>nome qualquer</em> para este resource. Como dito antes, este trecho de código pretende baixar a imagem do projeto SuperMario, portanto precisamos do tipo de <em>resource</em> chamado <em>docker_image</em>. Este é apenas um dos milhares de <em>resources</em> existentes para o Terraform. Em seguida estamos dando o nome <em>image_id</em> para nosso <em>resource</em> de tipo <em>docker_image</em>. O nome poderia ser qualquer um, até mesmo <em>minha_imagem_do_coracao</em>, mas para ficar mais descritiva e mantendo boas práticas, utilizarei <em>image_id</em>. Uma vez que identificamos o tipo de <em>resource</em> e o nome que queremos dar para ele, devemos encerrar a linha abrindo o bloco de código no qual listaremos os atributos deste <em>resource</em>. Para isto, utilizaremos um <em>{</em> para abrir este bloco.</li>
<li>Na linha 3 começamos a definir os atributos do nosso <em>resource</em>. A documentação do Terraform é excelente e lista todos os <em>resources</em> suportados, bem como todos os <em>atributos</em> suportados por cada <em>resource</em>. Neste caso, o único atributo que precisamos no momento é o <em>name</em>, ou nome da imagem que desejamos baixar. Em seguida, indicamos qual o nome da imagem desejada. Por padrão, o Docker adota a nomenclatura <em>&lt;REPOSITÓRIO/IMAGEM:TAG></em> para indicar a imagem desejada. Em nosso caso, o repositório onde a imagem se encontra se chama <em>pengbai</em> e a imagem em si é chamada de <em>docker-supermario</em>, portanto teremos: <em>name = &ldquo;pengbai/super-mario&rdquo;</em>. A <em>tag</em> não é obrigatória. Mas como desejo garantir que utilizaremos sempre a imagem mais recente, utilizarei a tag <em>latest</em> (última).</li>
<li>Uma vez que concluímos a definição de nosso <em>resource</em>, podemos fechar o nosso bloco de código para o mesmo utilizando um <em>}</em> na linha 4.</li>
</ol>


<p><strong>A</strong>gora que temos o início de nosso código, já podemos começar a testá-lo.</p>

<p><strong>D</strong>e volta ao nosso terminal/console, vamos iniciar o nosso ambiente Terraform para este projeto utilizando o comando <em>terraform init</em>. Este comando inicia nosso ambiente e baixa os plugins necessários para nosso projeto. No nosso caso, o Terraform baixará os plugins necessários para que nosso código possa lidar com o Docker.</p>

<p>``` yaml
$ terraform init</p>

<p>Initializing provider plugins&hellip;
&ndash; Checking for available provider plugins on <a href="https://releases.hashicorp.com...">https://releases.hashicorp.com...</a>
&ndash; Downloading plugin for provider &ldquo;docker&rdquo; (1.1.0)&hellip;</p>

<p>The following providers do not have any version constraints in configuration,
so the latest version was installed.</p>

<p>To prevent automatic upgrades to new major versions that may contain breaking
changes, it is recommended to add version = &ldquo;&hellip;&rdquo; constraints to the
corresponding provider blocks in configuration, with the constraint strings
suggested below.</p>

<ul>
<li>provider.docker: version = &ldquo;~> 1.1&rdquo;</li>
</ul>


<p>Terraform has been successfully initialized!</p>

<p>You may now begin working with Terraform. Try running &ldquo;terraform plan&rdquo; to see
any changes that are required for your infrastructure. All Terraform commands
should now work.</p>

<p>If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
```</p>

<p><strong>S</strong>e você recebeu um retorno parecido com o meu, significa que tudo está como deveria e que seu projeto foi iniciado com sucesso. Caso você liste os arquivos e diretórios ocultos de seu diretório, perceberá que ao rodar o comando <em>terraform init</em>, um diretório oculto chamado <em>terraform</em> foi criado. É nele que ficarão as informações que o Terraform precisa para executar corretamente o seu código, incluindo os plugins que ele necessita. No nosso caso, o plugin para o Docker estará lá.</p>

<p><strong>N</strong>osso próximo passo será executar o <em>planejamento</em> de nosso código. Ao rodar o <em>planejamento</em> o terraform listará exatamente tudo o que fará caso nosso código seja de fato executado. Novamente em nosso console/terminal, execute <em>terraform plan</em>:</p>

<p>``` yaml
$ terraform plan</p>

<p>Refreshing Terraform state in-memory prior to plan&hellip;
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.</p>

<h2>ATENÇÃO AQUI:</h2>

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li>docker_image.image_id
  id:     <computed>
  latest: <computed>
  name:   &ldquo;pengbai/docker-supermario:latest&rdquo;</li>
</ul>


<p>Plan: 1 to add, 0 to change, 0 to destroy.</p>

<hr />

<p>Note: You didn&rsquo;t specify an &ldquo;-out&rdquo; parameter to save this plan, so Terraform
can&rsquo;t guarantee that exactly these actions will be performed if
&ldquo;terraform apply&rdquo; is subsequently run.
```</p>

<p><strong>C</strong>aso você tenha recebido um retorno similar a este, significa que tudo parece correto em seu código e que apenas uma ação será executada, conforme descrito no resumo do plano ao final:</p>

<p><em>Plan: 1 to add, 0 to change, 0 to destroy.</em></p>

<p><strong>O</strong>u seja: Plano: 1 a adicionar, 0 a alterar, 0 a destruir.</p>

<p><strong>E</strong>xatamente o que queremos.</p>

<p><strong>C</strong>aso você tenha recebido uma mensagem de erro, significa que algo em seu código está errado. Por exemplo, se ao invés de utilizarmos <em>docker_image</em> como tipo de resource, utilizarmos <em>docker_images</em>, o resultado de meu <em>terraform plan</em> seria o seguinte:</p>

<p>``` yaml
$ terraform plan</p>

<p>Error: docker_images.image_id: Provider doesn&rsquo;t support resource: docker_images
```</p>

<p><strong>A</strong> mensagem geralmente é clara e nos indica onde está o erro. No caso acima, o Terraform nos diz que o resource <em>docker_images</em> não é suportado. Se checarmos a documentação do Terraform, veremos que o nome correto do <em>resource</em> é <em>docker_image</em> (no singular).</p>

<p><strong>U</strong>ma vez que nosso plano foi executado sem erros, chegou a hora de aplicarmos nosso projeto.</p>

<p><strong>E</strong>xecute o seu código através do comando <em>terraform apply</em>:</p>

<p>``` yaml
$ terraform apply</p>

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li>docker_image.image_id
  id:     <computed>
  latest: <computed>
  name:   &ldquo;pengbai/docker-supermario:latest&rdquo;</li>
</ul>


<p>Plan: 1 to add, 0 to change, 0 to destroy.</p>

<p>Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only &lsquo;yes&rsquo; will be accepted to approve.</p>

<p>  Enter a value:
```</p>

<p><strong>R</strong>epare que mesmo ao utilizar <em>apply</em> ao invés de <em>plan</em>, uma espécie de planejamento também foi realizado antes da aplicação propriamente dita. O Terraform avaliou o código e nos indicou o que será realizado, perguntando-nos ao final se queremos ou não seguir com a execução. Caso tudo nos pareça correto, basta digitarmos <em>yes</em> e pressionar Enter novamente para que ele siga com a execução de fato.</p>

<p>``` yaml</p>

<p>  Enter a value: yes</p>

<p>docker_image.image_id: Creating&hellip;
  latest: &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  name:   &ldquo;&rdquo; => &ldquo;pengbai/docker-supermario:latest&rdquo;
docker_image.image_id: Still creating&hellip; (10s elapsed)
docker_image.image_id: Still creating&hellip; (20s elapsed)
docker_image.image_id: Still creating&hellip; (30s elapsed)
docker_image.image_id: Still creating&hellip; (40s elapsed)
docker_image.image_id: Creation complete after 47s (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7&hellip;9c3d62pengbai/docker-supermario:latest)</p>

<p>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.
```</p>

<p><strong>A</strong>ssim como no <em>plan</em>, o Terraform ao final nos deu um breve relatório do que foi feito:</p>

<p><em>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</em></p>

<p><strong>O</strong>u seja: Aplicação completa! Recursos: 1 adicionado, 0 alterados, 0 destruídos.</p>

<p><strong>S</strong>e quisermos ter certeza de que de fato o Terraform baixou a imagem Docker de que precisamos, basta digitarmos o comando do Docker que lista as imagens que possuímos em nosso ambiente. A nossa nova imagem do supermario deverá estar lá. Digite <em>docker images</em>:</p>

<p><code>
$ docker images
REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
pengbai/docker-supermario   latest              49beaba1c5cc        4 months ago        686MB
</code></p>

<p><strong>Ó</strong>timo, nossa imagem está presente em nosso ambiente.</p>

<p><strong>O</strong> Terraform também nos permite saber o que estamos utilizando em termos de <em>resources</em> através do comando <em>terraform show</em>:</p>

<p>``` yaml
$ terraform show</p>

<p>docker_image.image_id:
  id = sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62pengbai/docker-supermario:latest
  latest = sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62
  name = pengbai/docker-supermario:latest
```</p>

<p><strong>V</strong>oltemos ao nosso código. Agora que já conseguimos fazer com que nosso código baixe a imagem que utilizaremos via Docker, chegou a hora de fazer algo com ela. Precisamos realizar o <em>deployment</em> da mesma em um container, certo?!</p>

<p><strong>V</strong>amos adicionar mais um <em>resource</em> em nosso código, desta vez um <em>resource</em> de tipo <em>docker_container</em>. Como o nome já diz, este <em>resource</em> lida com o container em si, e não mais apenas com a imagem.</p>

<p><strong>S</strong>eu código agora deverá estar da seguinte forma:</p>

<p>``` py main.tf</p>

<h1>Baixar a imagem do Projeto Docker-SuperMario</h1>

<p>resource &ldquo;docker_image&rdquo; &ldquo;image_id&rdquo; {
  name = &ldquo;pengbai/docker-supermario:latest&rdquo;
}</p>

<h1>Inicia o Container</h1>

<p>resource &ldquo;docker_container&rdquo; &ldquo;container_id&rdquo; {
  name  = &ldquo;supermario&rdquo;
  image = &ldquo;${docker_image.image_id.latest}&rdquo;
  ports {</p>

<pre><code>internal = "8080"
external = "80"
</code></pre>

<p>  }
}
```</p>

<p><strong>I</strong>gnorando as linhas já descritas anteriormente, vamos descrever as novas linhas de nosso código:</p>

<ol>
<li>Na linha 6 inserimos apenas mais um comentário, indicando que ali começaremos a descrever o código que criará nosso Container.</li>
<li>Na linha 7 indicamos que queremos mais um <em>resource</em>. Desta vez o tipo de <em>resource</em> que queremos é o <em>docker_container</em>, indicando também que queremos dar o nome <em>container_id</em> a este <em>resource</em>. Novamente, ao fim da linha, abriremos o bloco de código para este <em>resource</em> com uma <em>{</em>.</li>
<li>Dentro de nosso bloco, na linha 8, começaremos a listar os atributos deste <em>resource</em>. O primeiro atributo que listaremos é o <em>name</em>, e para ele daremos o nome <em>supermario</em>.</li>
<li>Na linha 9 indicaremos o atributo <em>image</em> e utilizaremos nossa primeira interpolação, onde reutilizaremos valores de outra parte de nosso código como se fossem variáveis. Em nosso <em>resource</em> anterior, <em>docker_image</em>, demos um nome <em>image_id</em> que será utilizado agora. Incluiremos também a tag <em>latest</em>, pois, conforme pudemos ver na saída de nosso comando <em>terraform show</em>, esta foi a tag utilizada pelo terraform para identificar o último status daquele <em>resource</em>. Portanto, aqui utilizaremos a interpolação inserindo o que queremos entre <em>{}</em> seguidas do símbolo <em>$</em>, conforme prega a sintaxe do Terraform para interpolação de valores, ficando o seguinte: <em>${docker_image.image_id.latest}</em>, onde <em>docker_image</em> é o tipo de resource de onde queremos o valor, <em>image_id</em> é o nome deste resource e <em>latest</em> é a tag para indicar que queremos o último valor daquele <em>resource</em>. O único motivo pelo qual temos um tipo de <em>resource</em> e um nome de <em>resource</em> é facilitar a identificação quando possuímos diversos <em>resources</em> do mesmo tipo. Imagine um projeto em que utilizaremos 5 imagens diferentes do Docker. Teríamos 5 <em>resources</em> do tipo <em>docker_image</em>, porém cada um deles teria um nome diferente, certo?!</li>
<li>Na linha 10 de nosso código iniciamos o bloco de portas, afinal, toda aplicação roda em uma porta específica e com containers não seria diferente.</li>
<li>Nas linhas 11 e 12 indicamos os valores para portas <em>intern</em> e <em>externß</em>, onde a porta <em>intern</em> será a porta utilizada pela aplicação internamente no container, e <em>extern</em> será a porta que o Docker irá mapear em nosso sistema local para que possamos acessar a nossa aplicação. Portanto, em nosso exemplo, a aplicação supermario irá rodar na porta <em>8080</em> internamente no container, e a porta 80 será mapeada para que possamos acessá-la de nosso navegador local.</li>
<li>Nas linhas 13 e 14 apenas fecharemos os dois blocos de código que criamos, sendo estes o bloco <em>ports</em> e o bloco <em>resource</em> do <em>docker_container</em>.</li>
</ol>


<p><strong>N</strong>ovamente, vamos planejar nosso projeto com <em>terraform plan</em>:</p>

<p>``` yaml
$ terraform plan
Refreshing Terraform state in-memory prior to plan&hellip;
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.</p>

<p>docker_image.image_id: Refreshing state&hellip; (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7&hellip;9c3d62pengbai/docker-supermario:latest)</p>

<hr />

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li>docker_container.container_id
  id:               <computed>
  attach:           &ldquo;false&rdquo;
  bridge:           <computed>
  container_logs:   <computed>
  exit_code:        <computed>
  gateway:          <computed>
  image:            &ldquo;sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62&rdquo;
  ip_address:       <computed>
  ip_prefix_length: <computed>
  log_driver:       &ldquo;json-file&rdquo;
  logs:             &ldquo;false&rdquo;
  must_run:         &ldquo;true&rdquo;
  name:             &ldquo;supermario&rdquo;
  network_data.#:   <computed>
  ports.#:          &ldquo;1&rdquo;
  ports.0.external: &ldquo;80&rdquo;
  ports.0.internal: &ldquo;8080&rdquo;
  ports.0.ip:       &ldquo;0.0.0.0&rdquo;
  ports.0.protocol: &ldquo;tcp&rdquo;
  restart:          &ldquo;no&rdquo;
  rm:               &ldquo;false&rdquo;
  start:            &ldquo;true&rdquo;</li>
</ul>


<p>Plan: 1 to add, 0 to change, 0 to destroy.</p>

<hr />

<p>Note: You didn&rsquo;t specify an &ldquo;-out&rdquo; parameter to save this plan, so Terraform
can&rsquo;t guarantee that exactly these actions will be performed if
&ldquo;terraform apply&rdquo; is subsequently run.
```</p>

<p><strong>R</strong>epare que desta vez apenas 1 ação será executada: a criação do container. Não estamos mais recebendo as informações referentes à ação de baixar a imagem. O motivo para isto é a propriedade de idempotência que citei anteriormente. O Terraform sabe que a imagem já foi baixada, portanto a mesma não precisa ser baixada novamente, a menos que tivéssemos mudado a versão da mesma, nome, repositório, etc.</p>

<p><strong>U</strong>ma vez que o plano esteja de acordo com o que queremos, podemos aplicar nosso código com <em>terraform apply</em>:</p>

<p>``` yaml
$ terraform apply
docker_image.image_id: Refreshing state&hellip; (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7&hellip;9c3d62pengbai/docker-supermario:latest)</p>

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li>docker_container.container_id
  id:               <computed>
  attach:           &ldquo;false&rdquo;
  bridge:           <computed>
  container_logs:   <computed>
  exit_code:        <computed>
  gateway:          <computed>
  image:            &ldquo;sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62&rdquo;
  ip_address:       <computed>
  ip_prefix_length: <computed>
  log_driver:       &ldquo;json-file&rdquo;
  logs:             &ldquo;false&rdquo;
  must_run:         &ldquo;true&rdquo;
  name:             &ldquo;supermario&rdquo;
  network_data.#:   <computed>
  ports.#:          &ldquo;1&rdquo;
  ports.0.external: &ldquo;80&rdquo;
  ports.0.internal: &ldquo;8080&rdquo;
  ports.0.ip:       &ldquo;0.0.0.0&rdquo;
  ports.0.protocol: &ldquo;tcp&rdquo;
  restart:          &ldquo;no&rdquo;
  rm:               &ldquo;false&rdquo;
  start:            &ldquo;true&rdquo;</li>
</ul>


<p>Plan: 1 to add, 0 to change, 0 to destroy.</p>

<p>Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only &lsquo;yes&rsquo; will be accepted to approve.</p>

<p>  Enter a value:
```</p>

<p><strong>M</strong>ais uma vez ele nos dá uma visão geral do que será feito e nos perguntará se queremos prosseguir. Digite <em>yes</em> e pressione Enter novamente.</p>

<p>``` yaml
Enter a value: yes</p>

<p>docker_container.container_id: Creating&hellip;
attach:           &ldquo;&rdquo; => &ldquo;false&rdquo;
bridge:           &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
container_logs:   &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
exit_code:        &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
gateway:          &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
image:            &ldquo;&rdquo; => &ldquo;sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62&rdquo;
ip_address:       &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
ip_prefix_length: &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
log_driver:       &ldquo;&rdquo; => &ldquo;json-file&rdquo;
logs:             &ldquo;&rdquo; => &ldquo;false&rdquo;
must_run:         &ldquo;&rdquo; => &ldquo;true&rdquo;
name:             &ldquo;&rdquo; => &ldquo;supermario&rdquo;
network_data.#:   &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
ports.#:          &ldquo;&rdquo; => &ldquo;1&rdquo;
ports.0.external: &ldquo;&rdquo; => &ldquo;80&rdquo;
ports.0.internal: &ldquo;&rdquo; => &ldquo;8080&rdquo;
ports.0.ip:       &ldquo;&rdquo; => &ldquo;0.0.0.0&rdquo;
ports.0.protocol: &ldquo;&rdquo; => &ldquo;tcp&rdquo;
restart:          &ldquo;&rdquo; => &ldquo;no&rdquo;
rm:               &ldquo;&rdquo; => &ldquo;false&rdquo;
start:            &ldquo;&rdquo; => &ldquo;true&rdquo;
docker_container.container_id: Creation complete after 1s (ID: 8c9d35eac2fcdc0c7e530567323167b82e72f33d4645abf20685b99d802e2359)</p>

<p>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.
```</p>

<p><strong>C</strong>onforme o esperado: Aplicaçao completa! <em>Resources</em>: 1 adicionado, 0 alterados, 0 destruídos.</p>

<p><strong>M</strong>ais uma vez podemos verificar se de fato tudo funcionou como o esperado através do Docker. Desta vez, não queremos apenas baixar uma imagem Docker, mas sim criar um container com a mesma abrindo portas específicas que serão mapeadas entre nosso sistema local e nosso container. Execute agora <em>docker ps</em> para ver os containers que estão rodando neste momento:</p>

<p><code>
docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES
8c9d35eac2fc        49beaba1c5cc        "catalina.sh run"   2 minutes ago       Up 2 minutes        0.0.0.0:80-&gt;8080/tcp   supermario
</code></p>

<p><strong>C</strong>omo podemos ver, temos um container rodando. Podemos até ver que existe um mapeamento de portas: <em>80->8080</em></p>

<p><strong>N</strong>ão está convencido ainda?</p>

<p><strong>A</strong>bra seu navegador e acesse o seguinte endereço: <em>localhost:80</em></p>

<p><strong>C</strong>aso o seu resultado seja algo parecido com a imagem, significa que seu código funcionou conforme o esperado.</p>

<p><img class="center" src="/imgs/mariodocker.png" title="&lsquo;Super Mario&rsquo;" ></p>

<p><strong>O</strong> terraform também nos permite destruir a nossa infraestrutura com o comando <em>terraform destroy</em>. Da mesma forma que o <em>apply</em>, o comando <em>destroy</em> também lhe dará uma prévia de o que será destruído e lhe pedirá par aconfirmar com um <em>yes</em> ou <em>no</em>:</p>

<p>``` yaml
$ terraform destroy
docker_image.image_id: Refreshing state&hellip; (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7&hellip;9c3d62pengbai/docker-supermario:latest)
docker_container.container_id: Refreshing state&hellip; (ID: 8c9d35eac2fcdc0c7e530567323167b82e72f33d4645abf20685b99d802e2359)</p>

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  &ndash; destroy</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li><p>docker_container.container_id</p></li>
<li><p>docker_image.image_id</p></li>
</ul>


<p>Plan: 0 to add, 0 to change, 2 to destroy.</p>

<p>Do you really want to destroy all resources?
  Terraform will destroy all your managed infrastructure, as shown above.
  There is no undo. Only &lsquo;yes&rsquo; will be accepted to confirm.</p>

<p>  Enter a value: yes</p>

<p>docker_container.container_id: Destroying&hellip; (ID: 8c9d35eac2fcdc0c7e530567323167b82e72f33d4645abf20685b99d802e2359)
docker_container.container_id: Destruction complete after 0s
docker_image.image_id: Destroying&hellip; (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7&hellip;9c3d62pengbai/docker-supermario:latest)
docker_image.image_id: Destruction complete after 2s</p>

<p>Destroy complete! Resources: 2 destroyed.
```</p>

<p><strong>C</strong>omo podemos ver, o terraform destruiu dois <em>resources</em>, nosso container e nossa imagem. Você poderá confirmar isto tentando acessar novamente o jogo pelo seu navegador ou mesmo através dos comandos <em>docker images</em> e <em>docker ls</em> para ver que tanto o container quanto a imagem foram removidos de nosso sistema:</p>

<p>```
$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</p>

<p>$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
```</p>

<p><strong>D</strong>e volta ao nosso código, vamos incrementá-lo apenas um pouco mais.</p>

<p><strong>O</strong> terraform nos permite especificar também <em>outputs</em>, ou saídas que nos serão apresentadas ao executarmos nosso código. Tratam-se de informações que podem nos ser úteis.</p>

<p><strong>P</strong>or exemplo, supomos que ao executar nosso código, desejamos que o terraform nos informe o IP do container que foi criado e o nome do mesmo, nosso código agora ficaria assim:</p>

<p>``` py main.tf</p>

<h1>Baixar a imagem do Projeto Docker-SuperMario</h1>

<p>resource &ldquo;docker_image&rdquo; &ldquo;image_id&rdquo; {
  name = &ldquo;pengbai/docker-supermario:latest&rdquo;
}</p>

<h1>Inicia o Container</h1>

<p>resource &ldquo;docker_container&rdquo; &ldquo;container_id&rdquo; {
  name  = &ldquo;supermario&rdquo;
  image = &ldquo;${docker_image.image_id.latest}&rdquo;
  ports {</p>

<pre><code>internal = "8080"
external = "80"
</code></pre>

<p>  }
}</p>

<h1>Nos informa o ip e nome do container criado</h1>

<p>output &ldquo;Endereco IP&rdquo; {
  value = &ldquo;${docker_container.container_id.ip_address}&rdquo;
}</p>

<p>output &ldquo;Nome do Container&rdquo; {
  value = &ldquo;${docker_container.container_id.name}&rdquo;
}
```</p>

<p><strong>N</strong>ovamente, ignorando o código que já descrevemos anteriormente, teremos:</p>

<ol>
<li>Na linha 16 inserimos mais um comentário.</li>
<li>Na linha 17 especificamos que desta vez queremos um <em>output</em>, e não mais um <em>resource</em>. Da mesma forma que fizemos com <em>resources</em>, vamos dar um nome a este <em>output</em>, de forma que possamos facilmente identificá-lo posteriormente. No caso, vamos chamar nosso <em>output</em> de <em>Endereco IP</em>. Em seguida abriremos o bloco de código para este <em>output</em> novamente com <em>{</em>.</li>
<li>Na linha 18 daremos o <em>value</em> ou valor deste output. Novamente utilizaremos interpolação de valores para pegar este valor de nossos <em>resources</em>. Para conseguirmos o endereço ip do container, utilizaremos o atributo <em>ip_address</em>, que é um atributo descrito na documentação do Terraform como parte integrante do resource de tipo <em>docker_container</em>. Portanto, nosso <em>value</em> será: ${docker_container.container_id.ip_address}.</li>
<li>Na linha 19, apenas fechamos o bloco deste <em>output</em>.</li>
<li>Na linha 21 iniciamos nosso segundo <em>output</em>, com o nome <em>Nome do Container</em>. Em seguida, abriremos o bloco de código para este <em>output</em> com um <em>{</em>.</li>
<li>Na linha 22, faremos algo similar ao que fizemos com o <em>value</em> do output anterior. Utilizaremos interpolação para buscar o valor do atributo <em>name</em>, que faz parte do <em>resource</em> <em>docker_container</em>. Nosso <em>value</em> será: ${docker_container.container_id.name}</li>
<li>Na linha 23, apenas fechamos nosso <em>output</em>.</li>
</ol>


<p><strong>V</strong>amos então rodar nosso <em>plan</em> para ver o que aconteceria desta vez:</p>

<p>``` yaml
$ terraform plan
Refreshing Terraform state in-memory prior to plan&hellip;
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.</p>

<hr />

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li><p>docker_container.container_id
  id:               <computed>
  attach:           &ldquo;false&rdquo;
  bridge:           <computed>
  container_logs:   <computed>
  exit_code:        <computed>
  gateway:          <computed>
  image:            &ldquo;${docker_image.image_id.latest}&rdquo;
  ip_address:       <computed>
  ip_prefix_length: <computed>
  log_driver:       &ldquo;json-file&rdquo;
  logs:             &ldquo;false&rdquo;
  must_run:         &ldquo;true&rdquo;
  name:             &ldquo;supermario&rdquo;
  network_data.#:   <computed>
  ports.#:          &ldquo;1&rdquo;
  ports.0.external: &ldquo;80&rdquo;
  ports.0.internal: &ldquo;8080&rdquo;
  ports.0.ip:       &ldquo;0.0.0.0&rdquo;
  ports.0.protocol: &ldquo;tcp&rdquo;
  restart:          &ldquo;no&rdquo;
  rm:               &ldquo;false&rdquo;
  start:            &ldquo;true&rdquo;</p></li>
<li><p>docker_image.image_id
  id:               <computed>
  latest:           <computed>
  name:             &ldquo;pengbai/docker-supermario:latest&rdquo;</p></li>
</ul>


<p>Plan: 2 to add, 0 to change, 0 to destroy.</p>

<hr />

<p>Note: You didn&rsquo;t specify an &ldquo;-out&rdquo; parameter to save this plan, so Terraform
can&rsquo;t guarantee that exactly these actions will be performed if
&ldquo;terraform apply&rdquo; is subsequently run.
```</p>

<p><strong>D</strong>esta vez podemos ver que ambas as ações serão executadas: A imagem será baixada e o container será criado, afinal tínhamos removido tudo com <em>terraform destroy</em> anteriormente.</p>

<p><strong>V</strong>amos aplicar nosso código e confirmar com <em>yes</em>:</p>

<p>``` yaml
$ terraform apply</p>

<p>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create</p>

<p>Terraform will perform the following actions:</p>

<ul>
<li><p>docker_container.container_id
  id:               <computed>
  attach:           &ldquo;false&rdquo;
  bridge:           <computed>
  container_logs:   <computed>
  exit_code:        <computed>
  gateway:          <computed>
  image:            &ldquo;${docker_image.image_id.latest}&rdquo;
  ip_address:       <computed>
  ip_prefix_length: <computed>
  log_driver:       &ldquo;json-file&rdquo;
  logs:             &ldquo;false&rdquo;
  must_run:         &ldquo;true&rdquo;
  name:             &ldquo;supermario&rdquo;
  network_data.#:   <computed>
  ports.#:          &ldquo;1&rdquo;
  ports.0.external: &ldquo;80&rdquo;
  ports.0.internal: &ldquo;8080&rdquo;
  ports.0.ip:       &ldquo;0.0.0.0&rdquo;
  ports.0.protocol: &ldquo;tcp&rdquo;
  restart:          &ldquo;no&rdquo;
  rm:               &ldquo;false&rdquo;
  start:            &ldquo;true&rdquo;</p></li>
<li><p>docker_image.image_id
  id:               <computed>
  latest:           <computed>
  name:             &ldquo;pengbai/docker-supermario:latest&rdquo;</p></li>
</ul>


<p>Plan: 2 to add, 0 to change, 0 to destroy.</p>

<p>Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only &lsquo;yes&rsquo; will be accepted to approve.</p>

<p>  Enter a value: yes</p>

<p>docker_image.image_id: Creating&hellip;
  latest: &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  name:   &ldquo;&rdquo; => &ldquo;pengbai/docker-supermario:latest&rdquo;
docker_image.image_id: Still creating&hellip; (10s elapsed)
docker_image.image_id: Still creating&hellip; (20s elapsed)
docker_image.image_id: Still creating&hellip; (30s elapsed)
docker_image.image_id: Still creating&hellip; (40s elapsed)
docker_image.image_id: Still creating&hellip; (50s elapsed)
docker_image.image_id: Creation complete after 59s (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7&hellip;9c3d62pengbai/docker-supermario:latest)
docker_container.container_id: Creating&hellip;
  attach:           &ldquo;&rdquo; => &ldquo;false&rdquo;
  bridge:           &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  container_logs:   &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  exit_code:        &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  gateway:          &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  image:            &ldquo;&rdquo; => &ldquo;sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62&rdquo;
  ip_address:       &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  ip_prefix_length: &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  log_driver:       &ldquo;&rdquo; => &ldquo;json-file&rdquo;
  logs:             &ldquo;&rdquo; => &ldquo;false&rdquo;
  must_run:         &ldquo;&rdquo; => &ldquo;true&rdquo;
  name:             &ldquo;&rdquo; => &ldquo;supermario&rdquo;
  network_data.#:   &ldquo;&rdquo; => &ldquo;<computed>&rdquo;
  ports.#:          &ldquo;&rdquo; => &ldquo;1&rdquo;
  ports.0.external: &ldquo;&rdquo; => &ldquo;80&rdquo;
  ports.0.internal: &ldquo;&rdquo; => &ldquo;8080&rdquo;
  ports.0.ip:       &ldquo;&rdquo; => &ldquo;0.0.0.0&rdquo;
  ports.0.protocol: &ldquo;&rdquo; => &ldquo;tcp&rdquo;
  restart:          &ldquo;&rdquo; => &ldquo;no&rdquo;
  rm:               &ldquo;&rdquo; => &ldquo;false&rdquo;
  start:            &ldquo;&rdquo; => &ldquo;true&rdquo;
docker_container.container_id: Creation complete after 0s (ID: 655604d672af8ff76c10aca4cd169a6aa284dcca17f0e0215374fb18c86660fd)</p>

<p>Apply complete! Resources: 2 added, 0 changed, 0 destroyed.</p>

<p>Outputs:</p>

<p>Endereco IP = 172.17.0.2
Nome do Container = supermario
```</p>

<p><strong>R</strong>epare que tudo o que queríamos foi executado e que, ao final, recebemos duas saídas ou <em>outputs</em>:</p>

<p>``` yaml
Apply complete! Resources: 2 added, 0 changed, 0 destroyed.</p>

<p>Outputs:</p>

<p>Endereco IP = 172.17.0.2
Nome do Container = supermario
```</p>

<p><strong>N</strong>ovamente, se você acessar em seu navegador o endereço <em>localhost:80</em>, ou utilizar os comandos <em>docker ps</em>, perceberá que sua aplicação está novamente rodando.</p>

<p><strong>N</strong>ão é complicado, certo?!</p>

<p><strong>O</strong>bviamente, isto é apenas um exemplo extremamente simplista de uso do Terraform para criar uma pequena infraestrutura como código, o que em nosso caso é apenas um container.</p>

<p><strong>N</strong>o próximo post pretendo alterar um pouco este nosso código para utilizar algumas melhores práticas propostas pelo Terraform, como a utilização de variáveis e outputs em arquivos distintos, já que não utilizamos variáveis neste post.</p>

<p><strong>U</strong>m passo de cada vez, certo?!</p>

<p><strong>H</strong>appy Hacking!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Infraestrutura como Código com Terraform]]></title>
    <link href="https://kalib.github.io/blog/2018/10/22/infraestrutura-como-codigo-com-terraform/"/>
    <updated>2018-10-22T21:26:00-04:00</updated>
    <id>https://kalib.github.io/blog/2018/10/22/infraestrutura-como-codigo-com-terraform</id>
    <content type="html"><![CDATA[<p><img class="center" src="/imgs/terraform.png" title="&lsquo;Terraform&rsquo;" ></p>

<h2>Infraestrutura como Código (IAC &ndash; Infrastructure as Code)</h2>

<p><strong>I</strong>nfraestrutura como código &ndash; IaC (ou infrastructure as code em inglês) &ndash; é o processo de gerenciamento e provisionamento de recursos de infraestrutura através de códigos ou arquivos de configuração que descrevem o estado desejado para tal infraestrutura ou recursos de infraestrutura. A principal característica de IaC é o uso de scripts ou definições declarativas ao invés de processos manuais, mas o termo é utilizado com mais frequência para promover abordagens declarativas. Como se tratam de arquivos de código, as definições podem ser armazenadas em um sistema de controle de versões, tal como o Git.</p>

<p><strong>A</strong>bordagens IaC são comumente promovidas para computação em nuvem e, às vezes, são comercializadas como infraestrutura como serviço (infrastructure as a service, IaaS). IaC suporta IaaS, mas os dois conceitos não devem ser confundidos.</p>

<h2>IaC e DevOps</h2>

<p><strong>I</strong>aC, ou Infraestrutura como Código, é um conceito bastante ligado à filosofia DevOps, visto que com práticas de implementação de uma infraestrutura baseada em códigos declarativos podemos aproximar as equipes de Operações e Desenvolvimento, fazendo com que os desenvolvedores tornem-se mais envolvidos nas configurações de máquinas ou recursos de infraestrutura como um todo, enquanto que os profissionais de Operações se envolvem mais cedo no processo de desenvolvimento. Além disso, agora ambas as equipes podem armazenar seu código em um mesmo ambiente, como por exemplo repositórios Git.</p>

<p><strong>I</strong>nfraestrutura como código mostrou-se uma excelente solução para livrar equipes de tarefas enfadonhas do cotidiano realizadas manualmente. Além de tomarem muito tempo e serem tarefas extremamente repetitivas, os corriqueiros processos manuais estão sujeitos a erros e podem colocar as operações em risco.</p>

<h4>Algumas vantagens da utilização de IaC</h4>

<ul>
<li><p><strong>Elimina tarefas repetitivas</strong> &ndash; Se você precisa criar 3 clusters Kubernetes em seu provedor de cloud (GCP ou AWS, por exemplo), você não precisa repetir os mesmos passos 3 vezes. Escreve um bloco de código que define a criação de um cluster e poderá aplicar este mesmo código quantas vezes forem necessárias;</p></li>
<li><p><strong>Documentação simplificada</strong> &ndash; Não há necessidade de logar-se em um servidor ou provedor de cloud para tentar vasculhar tudo o que foi configurado (está tudo no código);</p></li>
<li><p><strong>Reaproveitamento</strong> &ndash; Uma vez que tudo está codificado e separado em módulos, fica fácil reaproveitar módulos e código para futuras implementações;</p></li>
<li><p><strong>Simples manutenção</strong> &ndash; Mudanças na configuração, versões, regras e demais definições podem ser implementadas e aplicadas rapidamente com pequenas alterações no código;</p></li>
<li><p><strong>Versionamento</strong> &ndash; Ao abordar nossa infraestrutura como código passamos a ter diversos benefícios já rotineiros para desenvolvedores, como por exemplo a possibilidade de gerenciar nosso código em sistemas de versionamento como o Git, de forma a facilitar o trabalho em equipes, controle de versões, mudanças, etc;</p></li>
<li><p><strong>Agilidade</strong> &ndash; Se preciso trocar a faixa de endereços IP de uma VPC ou subnet, alterar uma linha de código é muito mais rápido do que logar em uma dashboard, procurar tal recurso e alterar manualmente os valores desejados;</p></li>
<li><p><strong>Possibilidade de soluções agnósticas</strong> &ndash; Em um mundo tecnológico que muda constantemente não são raras as ocasiões em que temos de mudar completamente nossa infraestrutura, seja deixando de usar servidores físicos para passar a utilizar VMs, ou migrando de VMs locais para a nuvem, ou de VMs na nuvem para containers, etc. Independente de qual seja o cenário de mudança, uma vez que sua infraestrutura está definida em código, dependendo das ferramentas escolhidas para codificar sua infra, o mesmo código poderia ser utilizado para um ambiente VMWare, AWS, Azure, GCP, etc, com poucas modificações. (Já citei agilidade e Simples manutenção, certo?!);</p></li>
<li><p><strong>Fácil replicar</strong> &ndash; Em um ambiente não codificado ou automatizado, geralmente repetimos as mesmas configurações para criarmos ambientes distintos como Produção, Teste, Desenvolvimento, etc. Uma vez que sua infra está codificada, você aplica o mesmo código para criar quantos ambientes desejar;</p></li>
<li><p><strong>Recuperação de Desastres ou Disaster Recovery</strong> &ndash; Desastres acontecem. Imagine um problema grande em sua infraestrutura. Em um cenário de virtualização, imagine que seu host VMWare simplesmente parou de funcionar pois seu disco queimou. Ou que o storage onde se encontravam as suas VMs simplesmente foi destruído. Ou, em um ambiente de cloud, imagine que sua senha de administrador da nuvem vazou e seu ambiente foi completamente excluído. Ou mesmo que o próprio data center ou região na qual se encontra a sua infra estrutura teve algum problema sério e toda a sua infra caiu. Claro, as boas práticas já pregam há muito tempo que sempre devemos ter backups de todos os servidores e sistemas, mas backups nada mais são do que arquivos. E a infraestrutura de fato? Você precisa ter uma infraestrutura ativa antes de conseguir restaurar backups, certo? Rede, firewall, VPCs, Clusters, Servidores, etc.. Se você possui toda a sua infraestrutura em código, recuperar tudo isso é tão simples quanto executar um único comando.</p></li>
<li><p><strong>Planejamento (plan) e Testes</strong> &ndash; Práticas como planejamento e testes fazem parte (ou ao menos deveríam fazer) da rotina de praticamente qualquer desenvolvedor. Profissionais de infraestrutura sempre tiveram uma desvantagem em relação a isso, pois era complicado fazer testes de infraestrutura. Teste basicamente significava instalar exatamente a mesma infraestrutura em um ambiente isolado para testes. Ainda possível, porém pouco confiável e com altas chances de falhas, pois, por ser um processo manual e lento, não há qualquer garantia de que todos os mesmos passos serão executados no ambiente de produção tal como foram executados no ambiente de teste. Com infraestrutura como código, fica fácil utilizar-se das mesmas técnicas de planejamento e testes automatizados há muito utilizadas por desenvolvedores. Agora você consegue executar testes no código de sua infraestrutura que, literalmente, irão avaliar cada bloco de seu código e simular a execução de cada expressão ou descrição, dando-lhe assim uma visão geral sobre o que acontecerá, o que funcionará e o que falhará, garantindo uma integradade fiel entre teste e implantação em produção ou demais ambientes.</p></li>
</ul>


<p><strong>L</strong>indo, não? Lembro de meus tempos de faculdade, quando costumava dizer a meus colegas que todos os profissionais de TI deveríam saber programar, independente de desejarem ou não trabalhar com programação. Na ocasião, em meados de 2006, a maioria deles dizia que isso era loucura. &ldquo;Porque aprender a programar se vou trabalhar com infraestrutura?&rdquo; Bom, tudo o que posso dizer hoje é: Bem vindos à era DevOps.</p>

<p><strong>Q</strong>uando falamos em infraestrutura como código, existem diversas ferramentas que trabalham em cima deste conceito, e muitas delas atuam juntas para englobar soluções mais completas, mas uma de minhas favoritas é o <a href="https://www.terraform.io">Terraform</a>, da <a href="https://www.hashicorp.com/">Hashicorp</a>.</p>

<h2>Escolha da ferramenta ideal para IAC</h2>

<p><strong>C</strong>om uma simples busca no Google pelo termo &ldquo;ïnfraestrutura como código&rdquo; ou &ldquo;IAC&rdquo;, será extremamente fácil encontrar diversas ferramentas, dentre as mais populares estão Chef, Puppet, Ansible, SaltStack, Terraform, CloudFormation, etc.</p>

<p><strong>U</strong>m problema comum para quem inicia no mundo DevOps ou simplesmente deseja começar a utilizar infraestrutura como código é justamente a escolha. Qual a melhor ferramenta? Qual devo utilizar?</p>

<p><strong>E</strong>esta é uma dificuldade comum e inerante ao fato de se ter muitas opções. Se em uma sorveteria você só possui os sabores chocolate e baunilha, é extremamente simples optar por um, outro ou nenhum dos dois. No entanto, em uma sorveteria com 50 sabores, você provavelmente perderá alguns minutos apenas lendo todas as opções, do contrário irá apostar na sorte e escolher o primeiro que lhe parecer apetitoso, correndo o risco de descartar algum que não chegou a ver, mas que poderia ser muito melhor e refrescante para um dia quente como os do nordeste cearense.</p>

<p><strong>O</strong> mais importante é sempre realizar uma pesquisa sobre pontos fortes e fracos de cada uma delas antes de tomar uma decisão, tendo em mente alguns aspectos:</p>

<ul>
<li><p>A escolha não deve (ou não deveria) ser puramente pessoal. A melhor ferramenta dificilmente será a que você gostou mais de utilizar. A melhor ferramenta será a que melhor atende as necessidades do seu projeto ou negócio;</p></li>
<li><p>A análise deve ser feita em diversos aspectos, e não apenas em um ou dois. Supondo que você pesquise por exemplo quais possuem mais módulos gratuitos e quais delas possuem uma comunidade mais ativa na internet para dúvidas, mas esqueceu de ponderar o preço para ter acesso a suporte corporativo, você pode ter feito uma boa ou uma má escolha. Em caso de ser uma pequena empresa, com prazos relativamente longos para entregas de projetos e maior flexibilidade em termos de tempo fora do ar (downtime), o suporte corporativo pode não ser um fator decisivo. No entanto, em uma empresa de ambiente mais crítico, como um banco, demais sistemas financeiros, governamentais, etc., o suporte corporativo se torna um fator mais importante, portanto escolher uma ferramenta sem ponderar o valor de seu suporte corporativo acaba sendo um tiro no pé, o que reforça a ideia de que sempre devemos avaliar o máximo de aspectos possíveis e relevantes ao nosso projeto ou ambiente;</p></li>
<li><p>Outro fator fundamental e, em meu ver o mais importante, é entender que não necessariamente a escolha será exclusiva. Imagine que você precisa montar uma mesa que veio toda desmontada: tábuas, parafusos, gavetas, etc. Você tem algumas ferramentas a disposição, como chave de fendas, martelo, régua, serra, furadeira, etc. Você pode ser uma espécie de rambo e gostar de resolver as coisas com uma ferramenta só e, sinceramente, você pode até ser capaz de conseguir montar a mesa inteira apenas utilizando o martelo, parabéns por isso. Mas será que essa é a forma mais eficiente de resolver o problema? Será que não seria mais rápido e organizado utilizando um martelo e uma chave de fendas? Afinal, temos parafusos também, certo?!</p></li>
</ul>


<p><strong>C</strong>onforme descrito acima, o ideal é sempre avaliar o projeto ou ambiente no qual se irá trabalhar, sem a necessidade de escolher apenas uma ferramenta.</p>

<p><strong>S</strong>im, Chef, Puppet e Ansible são ferramentas de Infraestrutura como Código, no entanto elas possuem tarefas mais específicas, nas quais possuem mais desempenho, como por exemplo o gerenciamento de configurações, para não listar todas as suas funções.</p>

<p><strong>E</strong>, claro, o CloudFormation é uma excelente ferramenta da Amazon para criação de infraestrutura como código, no entanto ela fica restrita ao ambiente de cloud da Amazon, o AWS. E se meu projeto estiver utilizando VMs em um ambiente VMWare? Ou se eu utilizar Google Cloud? Ou mesmo um ambiente mais heterogênio, com VMWare, Google Cloud e Amazon AWS? O CloudCloudFormation não seria a melhor opção, por ser restrito ao ambiente AWS.</p>

<p><strong>S</strong>empre fui a favor de utilizar as ferramentas corretas para cada tarefa em específico, portanto porque utilizar apenas uma se tenho outras disponíveis?</p>

<p><strong>O</strong> <a href="https://www.terraform.io">Terraform</a>, por outro lado, é específico para a criação da infraestrutura base, se saindo muito melhor do que Chef, Ansible ou Puppet nesta tarefa, mas nada impede (e eu encorajo e o faço) que você utilize Chef, Puppet ou Ansible, para gerenciar configurações, bootstraping ou deployments na infraestrutura criada pelo Terraform.</p>

<p><strong>A</strong>lém do mais, diferente do CloudFormation, o Terraform é uma solução agnóstica, permitindo-lhe criar infraestrutura em praticamente qualquer ambiente, seja ele em Cloud (Amazon AWS, Microsoft Azure, Google GCP, IBM Cloud, Digital Ocean, etc.), ambiente virtualizado, local ou em Data Centers (VMWare, Xen, Virtual Box, etc.), Docker, Kubernetes, além de recursos diversos de infraestrutura e softwares, tais como Redes (CloudFlare, DNS, DNSimple, F5 BIG-IP, Palo Alto Networks,etc.), Bancos de Dados (InfluxDB, MySQl ou PostgreSQL), dentre muitas outras coisas.</p>

<h2>Terraform</h2>

<p><strong>O</strong> Terraform, da Hashicorp, lhe permite criar, alterar e melhorar sua infraestrutura de forma segura e previsível. É uma ferramenta Open Source que codifica APIs em arquivos de configuração declarativos que podem ser compartilhados entre membros de um time, tratados como código, editados, revisados e versionados.</p>

<p><img class="center" src="/imgs/terraform-flow.png" title="&lsquo;Terraform Flow&rsquo;" ></p>

<p><strong>A</strong> imagem acima descreve bem o fluxo básico da utilização de Terraform para codificar sua infraestrutura, na qual o fluxo mais simplista é:</p>

<ul>
<li>Escrever o código de sua infraestrutura;</li>
<li>Planejar a execução do seu código, de forma que você receba informações antecipadamente de tudo o que acontecerá quando você aplicar o seu código;</li>
<li>Crie uma infraestrutura reproduzível ao aplicar seu código.</li>
</ul>


<p><strong>A</strong>pesar de este ser o fluxo mais simplista, com a utilização de infraestrutura como código você pode melhorar seu fluxo inserindo colaboração e compartilhamento, armazenando e gereciando seu código em um repositório git, por exemplo, além de ter assim um registro completo das mudanças e evoluções de sua infraestrutura, facilitando a automação em fluxos mais complexos, como por exemplo em pipelines de Integração Contínua.</p>

<p><strong>O</strong> Terraform funciona basicamente através de recursos, ou resources, que definem o tipo de infraestrutura você estará criando bem como seus atributos. Além disso, conforme dito anteriormente, o Terraform também pode ser utilizado em paralelo com diversas outras ferramentas de automação em forma de provedores, ou providers, como Puppet, Chef, Ansible, etc.</p>

<p><strong>P</strong>or estarmos tentando aplicar para a infraestrutura um conceito que seja mais próximo do que já era utilizado por desenvolvedores há muito tempo, o Terraform possui também uma abordagem que lhe permite reaproveitamento de código, através de módulos. Existem diversos módulos criados e disponibilizados gratuitamente, mas você pode também criar seus próprios módulos de forma a melhor organizar e reaproveitar seu próprio código em diversos projetos.</p>

<p><strong>A</strong>rquivos de configuração descrevem ao Terraform os componentes necessários para rodar uma única aplicação que representa todo o seu datacenter. O Terraform gera um plano de execução descrevendo o que fará para alcançar o estado desejado, e em seguida, caso aprovado, o executará para criar a infraestrutura desejada. Conforme a configuração muda, o Terraform será capaz de determinar o que mudou e criará planos de execução incrementais que podem ser aplicados.</p>

<p><strong>V</strong>ejamos o seguinte diagrama que descreve uma simples infraesturura. Imaginemos que esta é a infraestrutura que queremos rodar em nossa conta no Google Cloud para termos um site de e-commerce:</p>

<p><img class="center" src="/imgs/diagrama-ecommerce.png" title="&lsquo;Kalib Ecommerce&rsquo;" ></p>

<p>O diagrama acima possui diversos elementos:</p>

<ol>
<li>Uma organização no Google Cloud chamada Kalib Avante;</li>
<li>Um diretório ou Folder (como chamado no Google Cloud) chamado Projetos;</li>
<li>Um projeto chamado E-Commerce;</li>
<li>Um projeto chamado Zebra Feliz;</li>
<li>Dentro do projeto E-Commerce temos dois ambientes: Produção e Teste</li>
<li>Repare que o projeto Zebra Feliz está incompleto e sem ambientes distintos, como Produção, teste, etc. Bom, trata-se de um projeto piloto ainda em desenvolvimento e planejamento, portanto os recursos não foram ainda criados por completo. Mas o Terraform nos permite incrementar recursos quando necessário, certo? Portanto, sem problemas com isto por enquanto.</li>
</ol>


<p><strong>E</strong>sta é a estrutura básica, já em termos de recursos temos Firewalls, clusters kubernetes com Nodes, buckets de storage para conservar o status ou state do Terraform e por consequência de sua infraestrutura, Discos persistentes, Container Registry (repositório de imagens Docker), VPCs, Load Balancer, VMs, etc.</p>

<p><strong>C</strong>aso esteja se perguntando, sim o Terraform lhe permite criar esta infraestrutura inteira, bem como outras bem mais complexas, com mais projetos, mais ambientes, mais recursos, etc.</p>

<p><strong>D</strong>esta forma podemos ter um código terraform dividido em alguns módulos, armazenado em um repositório Git, por exemplo, e criar toda essa infraestrutura, desde a Organização vazia, ao diretório de projetos, aos 2 projetos em si, buckets, clusters kubernetes, DNS, IAM, load balancer, VMs por trás do Load Balancer, etc. Tudo isto com um único comando:</p>

<p><code>
terraform apply
</code></p>

<p><strong>L</strong>embrando um pouco do que falamos lá em cima, sobre ser simples reproduzir, ou se recuperar de desastres&hellip; imagine que uma região inteira caiu no Google, onde temos nossa infraestrutura. Sim, eu sei que isso é extremamente raro, mas vamos imaginar os cenários mais absurdos e raros também. Imagine que perdi toda a minha infraestrutura. Imagine ter que recriar tudo isso (projetos, diretórios, storages, DNS, IAM, clusters, Load Balancer, VMs, etc, etc..) manualmente..? Demoraria bastante, certo?! Mas, como fomos espertos e criamos tudo via terraform, um simples <strong>terraform apply</strong> irá criar tudo novamente para nós, exatamente como era antes.</p>

<p><strong>O</strong> mesmo se dá caso precisemos recriar toda essa mesma infraestrutura em uma nova região do Google, ou caso queiramos destruir nossa infra e recriá-la em outra zona, por algum motivo.</p>

<p><strong>A</strong>qui estamos lidando apenas com a Infraestrutura pois, conforme dito antes, o Terraform é excelente para criar a infraestrutura, mas o ideal ainda é utilizar outros softwares para provisionamento e deployment. Por exemplo, uma vez que temos nossa infraestrutura inteira criada, podemos começar a provisionar os sistemas e softwares através de outras ferrmentas, como Helm (para deployment dentro dos clusters Kubernetes), Chef, Puppet, Ansible, etc.</p>

<p><strong>A</strong> ideia deste post é apenas dar uma introdução teórica, uma ideia de como infraestrutura como código funciona, e de como o Terraform é capaz de fazer tudo isso de forma segura e robusta. (Embora eu já veja uma enorme barra de rolagem aqui ao lado e sei que lhe fiz ler bastante, supondo que leu até aqui. :p)</p>

<p><strong>E</strong>m meu próximo post pretendo fazer uma abordagem mais prática e com mão na massa, utilizando de fato o Terraform para criar uma simples infraestrutura via código.</p>

<p><strong>H</strong>appy Hacking!</p>
]]></content>
  </entry>
  
</feed>
