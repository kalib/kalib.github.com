<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Software Livre | Marcelo Cavalcante Rocha ~]]></title>
  <link href="http://blog.marcelocavalcante.net/blog/categories/software-livre/atom.xml" rel="self"/>
  <link href="http://blog.marcelocavalcante.net/"/>
  <updated>2013-10-30T10:47:14-03:00</updated>
  <id>http://blog.marcelocavalcante.net/</id>
  <author>
    <name><![CDATA[Marcelo Cavalcante Rocha - Kalib]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lynis - Segurança e Auditoria de Sistemas Linux]]></title>
    <link href="http://blog.marcelocavalcante.net/blog/2013/10/30/lynis-seguranca-e-auditoria-de-sistemas-linux/"/>
    <updated>2013-10-30T10:00:00-03:00</updated>
    <id>http://blog.marcelocavalcante.net/blog/2013/10/30/lynis-seguranca-e-auditoria-de-sistemas-linux</id>
    <content type="html"><![CDATA[<p><img class="left" src="/imgs/auditing.jpg" title="&lsquo;Auditando&rsquo;" >
<strong>P</strong>rocurando uma ferramenta de uso simples e rápido que seja capaz de realizar uma auditoria em sistemas Unix like? Talvez o <em>Lynis</em> seja exatamente o que você procura.</p>

<p><strong>O</strong> Lynis é uma ferramenta para (especialistas) Unix com foco em <em>segurança</em> e <em>auditoria</em>, porque não dizer <em>hardening</em>, de sistemas. Ele escaneia o sistema e vários softwares disponíveis no mesmo com o fim de detectar vulnerabilidades. Além de informações relacionadas a segurança, ele também buscará diversas informações sobre o sistema, pacotes instalados e erros de configuração diversos.</p>

<p><strong>E</strong>ste software ainda é útil e utilizado por outros softwares para ajudar em auditorias automatizadas, gerenciamento de patches de sistemas e escaneamento por vulnerabilidades e malwares. O público alvo do mesmo é composto por especialistas em segurança, pentesters, auditores de sistemas, administradores de redes/sistemas, etc.</p>

<p><strong>D</strong>entre suas verificações estão a avaliação dos métodos de autenticação disponíveis, certificados SSL expirados, softwares desatualizados, contas de usuários sem senhas, permissões incorretas em arquivos, erros de configuração, auditoria de firewall, etc.</p>

<p><strong>Instalação:</strong></p>

<p><strong>N</strong>o Arch Linux, o pacote se encontra disponível no <a href="https://aur.archlinux.org/packages/lynis/">AUR.</a>, portanto o processo de instalação consiste nos seguintes passos:</p>

<p><strong>1.</strong> Download do <a href="https://aur.archlinux.org/packages/ly/lynis/lynis.tar.gz">Tarball</a> disponibilizado no AUR.
<strong>2.</strong> Descompactação do tarball:
<code>
 $ tar -xvzf lynis.tar.gz
</code>
<strong>3.</strong> Entrar no diretório lynis que foi criado e em seguida iniciar a compilação/criação do pacote em si:
<code>
 $ cd lynis
 $ makepkg
</code>
<strong>4.</strong> Instalação do pacote que foi criado (Apenas este passo com usuário root ou utilizando sudo):
<code>
 # pacman -U lynis-1.3.3-1-any.pkg.tar.xz
</code></p>

<p><strong>C</strong>aso você utilize o yaourt ou algum outro gerenciador de pacotes do Arch Linux que possua acesso direto aos pacotes do AUR, pode utilizá-los ao invés de utilizar os passos acima:</p>

<p><code>
 $ yaourt -S lynis
</code></p>

<p><strong>H</strong>appy Hacking!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BleachBit - Limpeza de Disco no Linux]]></title>
    <link href="http://blog.marcelocavalcante.net/blog/2013/10/23/bleachbit-limpeza-de-disco-no-linux/"/>
    <updated>2013-10-23T09:02:00-03:00</updated>
    <id>http://blog.marcelocavalcante.net/blog/2013/10/23/bleachbit-limpeza-de-disco-no-linux</id>
    <content type="html"><![CDATA[<p><img class="left" src="/imgs/disk-cleanup.jpg" title="&lsquo;Limpeza de Disco&rsquo;" >
<strong>Q</strong>uando o assunto é segurança da informação, muitas vezes o óbvio é deixado de lado. Se pensa em anti-vírus, firewall, IDS (Intrusion Detection System), etc. Mas e o básico e óbvio? Raramente vejo profissionais preocupados com o lixo existente nos discos rígidos. Com <em>lixo</em> eu quero dizer aqueles arquivos temporários, antigos arquivos de cache que já não são necessários, ou mesmo rastros de informações de arquivos que já foram deletados. Sim, o fato de você deletar arquivos não significa que as informações daqueles arquivos foram completamente apagadas do disco. A <em>&ldquo;deleção regular de arquivos&rdquo;</em> não está apagando <em>os dados deletados</em>. Ela está apenas removendo os links dos inodes de arquivos, tornando assim possível a recuperação dos arquivos <em>deletados</em> com algum software forense.</p>

<p><strong>E</strong>xistem várias alternativas para remover seus arquivos de forma segura. As alternativas poderão variar de acordo com o sistema de arquivos utilizado em seu disco, é claro. Uma das formas mais simples que conheço é através da ferramenta <strong>BleachBit</strong>.</p>

<p><strong>B</strong>leachBit é um software livre criado para limpar e liberar espaço em disco, gerenciando assim melhor a sua privacidade e otimizando sistemas computacionais. Criado em 2008 para sistemas GNU/Linux, partiu de um controverso e polêmico debate sobre a necessidade de o GNU/Linux necessitar de uma ferramenta para limpeza de registros. Posteriormente o BleachBit passou a suportar também sistemas Microsoft Windows.</p>

<p><strong>C</strong>om esta ferramenta você poderá não apenas limpar seu espaço em disco, mas também limpar vários arquivos típicos do sistema que não são necessários na maioria dos casos a longo prazo, arquivos estes que podem dar ao intruso informações desnecessárias sobre suas atividades. Não desejamos isto&hellip;</p>

<p><strong>A</strong> instalação do mesmo é feita de forma simples e convencional. No caso do archlinux, o pacote se encontra disponível no repositório [community], portanto pode ser instalado regularmente através do pacman.</p>

<p>```
 [kalib@tuxcaverna ~]$ sudo pacman -Ss bleachbit
 [sudo] password for kalib:
 community/bleachbit 0.9.6-1</p>

<pre><code>Deletes unneeded files to free disk space and maintain privacy
</code></pre>

<p> [kalib@tuxcaverna ~]$ sudo pacman -S bleachbit
```</p>

<p><strong>N</strong>a maioria das distribuições baseadas em Debian, tal como o Ubuntu, o pacote poderá ser instalado através do aptitude ou apt-get:</p>

<p><code>
 $ sudo apt-get update
 $ sudo apt-get install bleachbit
</code></p>

<p><strong>O</strong> BleachBit possui uma interface gráfica simples, na qual você poderá selecionar o que você deseja destruir. Lembre-se que algumas funções são experimentais e podem causar problemas em seu sistema. Mas não há necessidade de se preocupar: O BleachBit lhe informa sobre isto e lhe dá a chance de cancelar a operação selecionada. ;]</p>

<p><strong>O</strong> BleachBit possui uma vasta lista de <em>cleaners</em>, como ele chama as ferramentas internas de limpeza. Dentre a longa lista, podemos citar alguns como: <em>Adanaxis, Adobe Reader, aMSN, aMule, APT, Audacious, Bash, Beagle, Chromium, Downloader for X, Deep scan, Easytag, ELinks, emesene, Epiphany, Evolution, Exaile, Filezilla, Firefox, Flash, gedit, gFTP, GIMP, etc.</em> A lista é realmente longa. <a href="http://bleachbit.sourceforge.net/features">Lista completa de cleaners e demais recursos.</a></p>

<p><strong>P</strong>ara executar o programa, basta procurar o mesmo através do menu de aplicativos de seu sistema, ou através do comando:</p>

<p><code>
 [kalib@tuxcaverna ~]$ bleachbit
</code></p>

<p><strong>H</strong>ave fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dica Rápida - Linux - Como Limpar o Conteúdo de um Arquivo Texto Sem Abrir o Mesmo]]></title>
    <link href="http://blog.marcelocavalcante.net/blog/2013/09/11/dica-rapida-linux-como-limpar-o-conteudo-de-um-arquivo-texto-sem-abrir-o-mesmo/"/>
    <updated>2013-09-11T11:05:00-03:00</updated>
    <id>http://blog.marcelocavalcante.net/blog/2013/09/11/dica-rapida-linux-como-limpar-o-conteudo-de-um-arquivo-texto-sem-abrir-o-mesmo</id>
    <content type="html"><![CDATA[<p><img class="left" src="/imgs/erase.jpg" title="&lsquo;Erasing text&rsquo;" >
<strong>A</strong>rquivos de log, por vezes, podem ser muito extensos. Tão extensos que torna-se praticamente impossível a leitura de seu conteúdo com um editor de textos como o vim ou vi. Além disso, muitos deles podem chegar a ocupar Gigas e mais Gigas de seu espaço em disco, o que pode acabar sendo um desperdício de espaço em seu sistema de arquivos.</p>

<p><strong>H</strong>oje passei por um problema deste tipo. Ao atualizar meu Arch Linux, percebi que comecei a receber erros devido ao meu espaço em disco o qual era apontado como &ldquo;insuficiente&rdquo;. O fato é que é muito comum em distribuições Linux utilizarmos um particionamento de forma a isolarmos um pouco cada partição para fins específicos. No meu caso, verifiquei que a minha partição raíz estava mesmo completamente cheia.</p>

<p><code>
 [kalib@tuxcaverna ~]$ df -h /
 Sist. Arq.      Tam. Usado Disp. Uso% Montado em
 /dev/sda3        30G   30G   0M  100% /
</code></p>

<p><strong>P</strong>ara resolver meu problema comecei limpando os pacotes que ficam em cache desnecessariamente através do pacman:</p>

<p><code>
 [kalib@tuxcaverna ~]$ pacman -Sc
</code></p>

<p><strong>E</strong>m seguida resolvi verificar quanto de espaço eu estava consumindo com logs de sistema:</p>

<p><code>
 [root@tuxcaverna ~]# cd /var/log
 [root@tuxcaverna ~]# du -h .
</code></p>

<p><strong>O</strong> comando acima me mostrou que meu diretório de logs estava consumindo mais de 13G. Insano, certo? Na verdade, não. É comum que ao longo dos meses, ou mesmo anos, o sistema acumule logs e mais logs. Uma quantia absurda e, muitas vezes, desnecessária de informações. Como trata-se de meu notebook pessoal e não estou tendo qualquer erro em meu sistema, resolvi limpar estes logs, portanto o primeiro passo é identificar os maiores arquivos. No meu caso foram os arquivos:</p>

<p><code>
 everything.log    kernel.log    daemon.log
</code></p>

<p><strong>U</strong>ma vez que cada um destes arquivos possuía mais de 3G, resolvi limpá-los completamente. A saída mais rápida e KISS? <em>/dev/null neles</em>.</p>

<p><code>
 [root@tuxcaverna ~]# cat /dev/null &gt;everything.log
</code></p>

<p><strong>I</strong>sto limpará completamente o conteúdo do arquivo de texto informado. Vejamos o simples exemplo a seguir:</p>

<p><strong>V</strong>amos criar um arquivo de texto vazio chamado <em>teste.txt</em>.</p>

<p><code>
 [root@tuxcaverna ~]# touch teste.txt
</code></p>

<p><strong>E</strong>m seguida, vamos inserir algum conteúdo no mesmo:</p>

<p><code>
 [root@tuxcaverna ~]# echo "Testando" &gt;teste.txt
</code></p>

<p><strong>V</strong>erifiquemos se meu texto realmente foi inserido no arquivo:</p>

<p><code>
 [root@tuxcaverna ~]# cat teste.txt
 Testando
</code></p>

<p><strong>T</strong>udo certo. Agora vamos limpar o mesmo:</p>

<p><code>
 [root@tuxcaverna ~]# cat /dev/null &gt;teste.txt
</code></p>

<p><strong>A</strong>gora, vamos confirmar se o mesmo foi mesmo zerado:</p>

<p><code>
 [root@tuxcaverna ~]# cat teste.txt
 [root@tuxcaverna ~]#
</code></p>

<p><strong>M</strong>issão cumprida. Apenas para constar a diferença:</p>

<p><code>
 [kalib@tuxcaverna ~]$ df -h /
 Sist. Arq.      Tam. Usado Disp. Uso% Montado em
 /dev/sda3        30G   16G   13G  56% /
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Correção do Bug entre Kernel Linux e Placas Broadcom]]></title>
    <link href="http://blog.marcelocavalcante.net/blog/2013/09/03/correcao-do-bug-entre-kernel-linux-e-placas-broadcom/"/>
    <updated>2013-09-03T20:33:00-03:00</updated>
    <id>http://blog.marcelocavalcante.net/blog/2013/09/03/correcao-do-bug-entre-kernel-linux-e-placas-broadcom</id>
    <content type="html"><![CDATA[<p><img class="left" src="/imgs/catchbug.jpg" title="&lsquo;Catching Big&rsquo;" >
<strong>B</strong>ug capturado e tratado!</p>

<p><strong>D</strong>iversas pessoas se depararam com intermináveis erros de <em>kernel panic</em> após atualizar seu kernel para a versão <em>3.10.6</em> (e posteriores) quando utilizavam placas wireless da <em>Broadcom</em>. O erro reportado foi tratado e, apesar de ainda não estar resolvido no último kernel lançado, <em>3.10.10</em>, já se encontra na árvore de <em>Linus Torvalds</em>, conforme código e correção podem ser vistos através do seguinte link:</p>

<p><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=2dfca312a91631311c1cf7c090246cc8103de038">mac80211: add a flag to indicate CCK support for HT clients</a></p>

<p><strong>O</strong> problema se dava com o módulo brcm80211 que não conseguia lidar adequadamente com o envio de frames com taxas CCK como parte de uma sessão A-MPDU. Apesar de outros drivers/módulos da broadcom conseguirem conectar-se sem o kernel panic logo na inicialização do sistema, estes ainda podem enfrentar problemas em outros momentos sem esta correção. O patch corrige o erro reportado com módulos brcmsmac bem como outros.</p>

<p><strong>A</strong>tualmente estou utilizando o último kernel disponibilizado, o <em>3.10.10</em>. Apesar de a correção ainda não ter saído nesta versão, estou utilizando uma versão do kernel com o patch já aplicado.</p>

<p><strong>E</strong>speremos pelo kernel <em>3.11</em> que deverá ser lançado nos próximos dias e que, por sua vez, deverá resolver este problema definitivamente.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tornando Seu SSH Mais Seguro]]></title>
    <link href="http://blog.marcelocavalcante.net/blog/2013/08/28/tornando-seu-ssh-mais-seguro/"/>
    <updated>2013-08-28T11:20:00-03:00</updated>
    <id>http://blog.marcelocavalcante.net/blog/2013/08/28/tornando-seu-ssh-mais-seguro</id>
    <content type="html"><![CDATA[<p><img class="left" src="/imgs/openssh.png" title="&lsquo;OpenSSH&rsquo;" >
<strong>O</strong> <em>SSH</em> (Secure Shell) é um dos protocolos mais utilizados atualmente para transferência de arquivos ou mesmo conexão remota, principalmente em ambientes Linux/Unix e, por si só, já tem se provado ser confiável e seguro. O mesmo passou a ser o principal substituto ao <em>TELNET</em> por possuir a vantagem da criptografia na conexão entre o cliente e o servidor, além da possibilidade de criação de túneis, o que chamamos de <em>tunneling</em>, oferecendo assim a capacidade de redirecionar pacotes de dados. Mas não é por isso que devemos nos descuidar&hellip;</p>

<p><strong>S</strong>empre existe espaço para melhorias.</p>

<p><strong>A</strong>s configurações do servidor SSH, geralmente, ficam localizadas em <em>/etc/ssh/sshd_config</em>. Vale lembrar que a cada alteração feita neste arquivo será necessário reiniciar o serviço SSH para que suas alterações possam ser efetivadas.</p>

<p><strong>I</strong>ndo ao que interessa:</p>

<p><strong>1- Altere a porta de escuta do SSH</strong></p>

<p><strong>P</strong>or padrão o SSH aceita conexões na porta 22, portanto é importante alterar esta porta para dificultar as tentativas de ataques aleatórios de brute-force que buscam máquinas que disponibilizam o SSH através da porta padrão. Preferivelmente, é interessante optar por uma porta posterior a 1024, visto que a maioria dos softwares de escaneamento de portas e serviços não fazem uma varredura por portas muito altas. Esta é geralmente uma das primeiras configurações no arquivo <em>/etc/ssh/sshd_config</em>, conforme pode ser visto abaixo:</p>

<p><code>
 Port 22
</code></p>

<p><strong>2- Permita apenas o protocolo SSH 2</strong></p>

<p><strong>D</strong>ependendo de sua distribuição Linux, o padrão poderá ser a utilização de ambos os protocolos, 1 e 2. A versão 1 do protocolo SSH possui vulnerabilidades bastante conhecidas, portanto é preferível que utilize apenas o protocolo de versão 2, diminuindo assim suas chances de um ataque de inserção, por exemplo, conforme possível com a versão 1 do protocolo. Procure pela seguinte linha de configuração e altere-a mantendo apenas a opção <em>2</em>:</p>

<p><code>
 Protocol 2,1
</code></p>

<p><strong>3- Decida quais usuários poderão logar-se via SSH</strong></p>

<p><strong>P</strong>ermitir que qualquer usuário possa logar-se via SSH não é aconselhável, da mesma forma que permitir que o usuário root efetue login via SSH também é extremamante desencorajado devido às vulnerabilidades envolvidas. Por possuírem determinados (ou todos, no caso do root) privilégios no sistema, alguns usuários simplesmente não devem ter permissão de login via SSH, evitando assim que alguém utilize ferramentas de brute-force e consiga, por quebra de senha, logar-se em seu servidor com um usuário privilegiado. Para proibir o login do usuário root via SSH, altere a seguinte linha para <em>no</em>:</p>

<p><code>
 PermitRootLogin yes
</code></p>

<p><strong>P</strong>ara definir quais usuários poderão ter acesso via SSH, insira o nome dos mesmos na seguinte linha, conforme exemplo abaixo:</p>

<p><code>
 AllowUsers usuario1 usuario2 usuario3
</code></p>

<p><strong>4- Utilize uma chave pública DSA como mecanismo de autenticação</strong></p>

<p><strong>A</strong>o invés de utilizar nomes de usuários e senhas para autenticar-se via SSH, você pode utilizar chaves públicas DSA. Outra opção é utilizar ambos os mecanismos, usuário e senha + chave. Uma das maiores vantagens de se utilizar chaves como mecanismo de autenticação é que você impossibilitará o acesso indevido através de ataques de força bruta ou brute force, pois você não precisará de um login e senha para logar-se ao servidor ou estação. Ao invés disso, você utilizará um par de chaves &ndash; uma pública e uma privada. No cenário de chaves DSA, a chave privada fica em sua máquina e uma cópia da chave pública fica no servidor que você deseja acessar via SSH.</p>

<p><strong>A</strong>o tentar logar-se em um servidor configurado para autenticação via chave DSA, o mesmo verifica as chaves de ambos os lados e, se elas combinarem, autoriza seu login, caso contrário nega sua conexão.</p>

<p><strong>N</strong>o arquivo de configuração do servidor SSH você irá procurar os seguintes parâmetros e deixá-los da seguinte forma:</p>

<p><code>
 RSAAuthentication yes
 PubkeyAuthentication yes
 AuthorizedKeysFile %h/.ssh/authorized_keys
</code></p>

<p><strong>C</strong>aso você deseje utilizar <em>apenas</em> a autenticação por chaves DSA, você precisará desabilitar a autenticação por senha, deixando como <em>no</em> o seguinte parâmetro:</p>

<p><code>
 PasswordAuthentication no
</code></p>

<p><strong>A</strong>gora que as regras de configuração para a autenticação via chaves foram criadas, vamos criar as chaves em si.</p>

<p><strong>E</strong>m sua máquina, vamos digitar o seguinte comando para a criação de suas chaves pública e privada:</p>

<p><code>
 $ ssh-keygen -t dsa -C "$(whoami)@$(hostname)-$(date -I)"
</code></p>

<p><strong>O</strong> sistema lhe perguntará se você deseja escolher um diretório no qual salvar suas chaves. Caso você não especifique nenhum, ele salvará no diretório .ssh que se encontra no home de seu usuário <em>(~/.ssh/id_dsa)</em>. Em seguida lhe perguntará se você deseja criar uma senha para sua chave (não é obrigatório).</p>

<p><strong>A</strong>o finalizar este procedimento você receberá a confirmação de que o procedimento foi realizado. Algo similar a isto:</p>

<p><code>
 Your identification has been saved in /home/username/.ssh/id_dsa.
 Your public key has been saved in /home/username/.ssh/id_dsa.pub.
 The key fingerprint is:
 dd:15:ee:24:20:14:11:01:b8:72:a2:0f:99:4c:79:7f username@localhost-2013-08-28
 The key's randomart image is:
 +--[DSA  1024]---+
 |     ..oB=.   .  |
 |    .    . . . . |
 |  .  .      . +  |
 | oo.o    . . =   |
 |o+.+.   S . . .  |
 |=.   . E         |
 | o    .          |
 |  .              |
 |                 |
 +-----------------+
</code></p>

<p><strong>O</strong> próximo passo é copiar a sua chave pública para o servidor que você deseja acessar via SSH. Você pode copiar de algumas formas diferentes:</p>

<p><strong>4.1 &ndash; Copiando manualmente</strong></p>

<p><strong>C</strong>opie o conteúdo retornado através do seguinte comando:</p>

<p><code>
 $ cat ~/.ssh/id_dsa.pub
</code></p>

<p><strong>O</strong> retorno será algo similar a isto:</p>

<p><code>
 ssh-dss AAAAB3NzaC1kc3MAAACBAKWJtlUANTuqKy1NN4bb5qBJLZVMnR+nr84hk7EWnHmpJgipRZ8Y/tUDJTpCab
 GwoMNYmPZaz62Nm5/F5Nl9yzgMmxfGja8OYt3bwir6A379NOWFM2NBq7Q107uH4L+MFszXKoCVn6rM9SddkAJL1V66
 eGX+Y+r1o/8wG773h9P5AAAAFQDh09qovWFzKJk0E58c0oRz9S4UAQAAAIBuVxw+LZDrWVVCLr4WMubRPJuFzXqqHN
 re9RUZ2kMrUENnAenYyJgjcBg7uJJA/wMfn7Oe32e4hvpU7SsXEUf7xT1sKb/UFyX9qTr5G0kkU6t8IYPjIQaqRIOQ
 mnRiqm7JCDd1GTAFU9n/ocK4sNPZDL8KeEEquZmk+ihKcu9FLwAAAIBlz+K7fcZSlA5hKewHOF7fA9IdwdMsbc2Ri7
 bSw4Fv70rQeMnYYUDeHQQJHeJJyScmuHswordGXYKe2tsf7fYn11CW46P9WxCRcargojxJNrRHlF5WiK15fhNMLtfx
 7/+CSmoXnEUCw8uCCBVduGLyevZ3WC+FEx7/aqJjuUCNJg== username@localhost-2013-08-28
</code></p>

<p><strong>É</strong> exatamente este conteúdo que precisa ser copiado.</p>

<p><strong>E</strong>m seguida você precisará colar este conteúdo no servidor desejado, porém incrementando dentro do seguinte arquivo (no servidor): <em>~/.ssh/authorized_keys</em></p>

<p><strong>P</strong>ara facilitar, você poderá já ter copiado o arquivo da chave completo para o servidor. Veja nos próximos métodos algumas formas de o fazer.</p>

<p><strong>4.2 &ndash; Método Simples &ndash; Deve ser usado antes de configurar o servidor para permitir autenticação por chaves</strong></p>

<p><strong>S</strong>e o seu arquivo de chave é <em>~/.ssh/id_dsa</em>, você poderá simplesmente digitar o seguinte comando para enviar a chave para o servidor:</p>

<p><code>
 $ ssh-copy-id servidor-remoto.com.br
</code></p>

<p><strong>C</strong>aso o nome de usuário em sua máquina seja diferente do nome de usuário no servidor, lembre-se de adicionar o nome do usuário do servidor antes do endereço do mesmo:</p>

<p><code>
 $ ssh-copy-id nome-de-usuario@servidor-remoto.com.br
</code></p>

<p><strong>C</strong>aso o servidor esteja recebendo as conexões SSH em uma porta diferente da padrão (22), utilize (supondo que estamos utilizando a 221):</p>

<p><code>
 $ ssh-copy-id -p 221 nome-de-usuario@servidor-remoto.com.br
</code></p>

<p><strong>4.3 &ndash; Método Tradicional &ndash; Deve ser usado antes de configurar o servidor para permitir autenticação por chaves</strong></p>

<p><strong>P</strong>or padrão a chave pública precisa ser concatenada no arquivo <em>~/.ssh/authorized_keys</em>. Comece copiando a chave pública para o servidor remoto:</p>

<p><code>
 $ scp ~/.ssh/id_dsa.pub nome-do-usuario@servidor-remoto.com.br:
</code></p>

<p><strong>O</strong> comando acima copiará a chave pública para o diretório home do usuário citado para o servidor via scp. Não esqueça de inluir o <em>:</em> ao final do endereço do servidor.</p>

<p><strong>C</strong>aso o diretório <em>~/.ssh</em> ainda não exista no servidor, você precisará criá-lo. O mesmo com o arquivo <em>authorized_keys</em>:</p>

<p><code>
 $ ssh nome-do-usuario@servidor-remoto.com.br
 nome-do-usuario@servidor-remoto's password:
 $ mkdir ~/.ssh
 $ cat ~/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys
 $ rm ~/id_dsa.pub
 $ chmod 600 ~/.ssh/authorized_keys
</code></p>

<p><strong>O</strong>s últimos dois comandos removem a chave pública do diretório do servidor e definem as permissões para o arquivo <em>authorized_keys</em> de forma que ele apenas possa ser lido ou escrito por você, o dono.</p>

<p><strong>P</strong>ronto, sua chave já está no servidor após seguir uma das dicas acima.</p>

<p><strong>L</strong>embre-se sempre de reiniciar o serviço ssh após efetuar qualquer alteração de configuração.</p>

<p><strong>D</strong>icas simples de serem implementadas mas que irão melhorar bastante a segurança de seu servidor SSH. ;]</p>
]]></content>
  </entry>
  
</feed>
