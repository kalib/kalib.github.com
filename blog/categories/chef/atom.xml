<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chef | Marcelo Cavalcante Rocha ~]]></title>
  <link href="http://kalib.github.io/blog/categories/chef/atom.xml" rel="self"/>
  <link href="http://kalib.github.io/"/>
  <updated>2018-07-29T11:27:56-04:00</updated>
  <id>http://kalib.github.io/</id>
  <author>
    <name><![CDATA[Marcelo Cavalcante Rocha - Kalib]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Chef: Uso de Condicionais not_if e only_if]]></title>
    <link href="http://kalib.github.io/blog/2018/04/14/chef-uso-de-condicionais-not-if-e-only-if/"/>
    <updated>2018-04-14T19:33:00-04:00</updated>
    <id>http://kalib.github.io/blog/2018/04/14/chef-uso-de-condicionais-not-if-e-only-if</id>
    <content type="html"><![CDATA[<p>{% img center /imgs/chef-logo2.png &lsquo;Chef&rsquo; %}</p>

<h2>Pare e volte uma casa</h2>

<p>{% img center /imgs/volte1casa.jpeg &lsquo;Volte1Casa&rsquo; %}
<strong>S</strong>e você nunca utilizou ou sabe pouco sobre o <em>Chef</em> é importante que você pare aqui mesmo e volte uma casa. Sugiro que leia o post <a href="http://blog.marcelocavalcante.net/blog/2018/04/01/chef-aautomacao-e-gerenciamento-de-configuracao/">Chef: Automação e Gerenciamento de Configuração</a> antes de seguir este, uma vez que através dele você entenderá o que é, e como funciona o Chef, bem como sua instalação básica.</p>

<h2>Resources</h2>

<p><strong>C</strong>onforme dito no post anterior, resource é uma descrição de estado que:</p>

<ul>
<li>Descreve o estado desejado para um item de configuração</li>
<li>Declara os passos necessários para levar o item especificado ao estado desejado</li>
<li>Especifica o tipo de resource &ndash; por exemplo, <code>package</code>, <code>template</code> ou <code>service</code></li>
<li>Lita detalhes adicionais (também conhecidos como propriedades de resources), conforme necessário</li>
<li>São agrupados em <em>recipes</em>, que descrevem configurações em geral</li>
</ul>


<h2>Utilizando (Guardas) not_if e only_if</h2>

<p><strong>T</strong>odos os resources (incluindo os personalizados) no Chef compartilham um conjunto de opções comuns: ações, propriedades, condicionais, notificações e paths relativos.</p>

<p><strong>Guards</strong></p>

<p><strong>P</strong>ropriedades de <em>guarda</em>, ou <code>guards</code>, como são chamadas no Chef, podem ser utilizadas para avaliar o estado de um node durante a fase de execução do chef-client. Esta avaliação funciona como uma condicional e, baseando-se nos resultados da mesma, a propriedade guard é então utilizada para indicar ao chef-client se ele deve ou não continuar a execução de um resource. Uma propriedade guard aceita tanto um valor string quanto um bloco de código Ruby.</p>

<ul>
<li>A string é executada como um comando shell. Caso o comando retorne <code>0</code> (true), a propriedade guard é aplicada. Caso o comando retorne qualquer outro valor a propriedade guard não será aplicada.</li>
<li>Um bloco é executado como um código Ruby que deve retornar <code>true</code> ou <code>false</code>. Da mesma forma, caso o comando retorne <code>true</code>, a propriedade guard é aplicada. Caso o comando retorne <code>false</code> a propriedade guard não será aplicada.</li>
</ul>


<p><strong>U</strong>ma <strong>guard</strong> é importante para garantir que um resource seja idempotente ao permitir um teste no próprio resource certificando-se de que o mesmo se encontra no estado desejado de forma que o chef-client não faça nada.</p>

<p><strong>Atributos</strong></p>

<p><strong>O</strong>s seguintes atributos podem ser utilizados para definir uma guard que é avaliada durante a fase de execução do chef-client:</p>

<p><code>not_if</code> &ndash; <strong>Impede</strong> a execução de um resource quando a condição retornar <code>true</code>.</p>

<p><code>only_if</code> &ndash; Permite a execução de um resource <strong>apenas</strong> quando a condição retornar <code>true</code>.</p>

<h2>Mãos à obra</h2>

<p><strong>P</strong>ara simplificar seguirei utilizando a recipe utilizada no post anterior. Não sabe o que é uma recipe? <code>-&gt;</code> Novamente, caso não entenda o que estou dizendo, volte uma casa e leia o <a href="http://blog.marcelocavalcante.net/blog/2018/04/01/chef-aautomacao-e-gerenciamento-de-configuracao/">post anterior</a>, no qual explico o que é uma recipe, bem como cada elemento da mesma, visto que a utilizaremos aqui.</p>

<p><strong>N</strong>ossa recipe era a seguinte:</p>

<p>```
package &lsquo;apache&rsquo; do</p>

<pre><code>    package_name 'httpd'
    action :install
</code></pre>

<p>end</p>

<p>service &lsquo;httpd&rsquo; do</p>

<pre><code>    action [:enable, :start]
</code></pre>

<p>end</p>

<p>file &lsquo;/var/www/html/index.html&rsquo; do</p>

<pre><code>    content 'Hello World!'
    mode '0755'
    owner 'root'
    group 'apache'
</code></pre>

<p>end
```</p>

<p><strong>C</strong>omo primeira alteração vamos editar o arquivo <code>/etc/motd</code>. Este arquivo nada mais é do que a definição de um baner que será apresentado sempre que alguém se logar em seu servidor.</p>

<p><strong>P</strong>or padrão, este arquivo costuma vir vazio. Este é o caso da máquina utilizada para este exemplo:</p>

<p><code>
[root@kalib6 ~]# cat /etc/motd
[root@kalib6 ~]#
</code></p>

<p><strong>C</strong>omeçaremos definindo o conteúdo que deverá existir em nosso arquivo <code>/etc/motd</code> incluindo um resource do tipo <code>file</code> no final de nossa recipe <code>exemplo.rb</code>:</p>

<p>```
package &lsquo;apache&rsquo; do</p>

<pre><code>    package_name 'httpd'
    action :install
</code></pre>

<p>end</p>

<p>service &lsquo;httpd&rsquo; do</p>

<pre><code>    action [:enable, :start]
</code></pre>

<p>end</p>

<p>file &lsquo;/var/www/html/index.html&rsquo; do</p>

<pre><code>    content 'Hello World!'
    mode '0755'
    owner 'root'
    group 'apache'
</code></pre>

<p>end</p>

<p>file &lsquo;/etc/motd&rsquo; do</p>

<pre><code>    content 'Bem Vindo!'
</code></pre>

<p>end
```</p>

<p><strong>A</strong>té aqui nenhuma novidade (caso você tenha lido de fato o post anterior ou já tenha utilizado Chef anteriormente), apenas incluímos mais um resource em nossa recipe <code>exemplo.rb</code> informando que o arquivo <code>/etc/motd</code> deve existir e que seu conteúdo deverá ser <em>Bem Vindo!</em>.</p>

<p><strong>V</strong>alidando e executando localmente nossa recipe conforme feito anteriormente veremos que todos os demais passos ou resources serão ignorados por já estarem estarem no estado desejado (idempotência), restando apenas a inclusão do conteúdo no <code>/etc/motd</code>:</p>

<p><strong>Validando</strong></p>

<p><code>
[root@kalib6 ~]# ruby -c exemplo.rb &amp;&amp; foodcritic exemplo.rb
Syntax OK
Checking 1 files
x
FC011: Missing README in markdown format: ../README.md:1
FC031: Cookbook without metadata.rb file: ../metadata.rb:1
FC071: Missing LICENSE file: ../LICENSE:1
</code></p>

<p><strong>Executando</strong></p>

<p>```
[root@kalib6 ~]# chef-client &mdash;local-mode exemplo.rb
[2018-04-15T22:03:26+00:00] WARN: No config file found or specified on command line, using command line options.
[2018-04-15T22:03:26+00:00] WARN: No cookbooks directory found at or above current directory.  Assuming /root.
Starting Chef Client, version 13.8.5
resolving cookbooks for run list: []
Synchronizing Cookbooks:
Installing Cookbook Gems:
Compiling Cookbooks&hellip;
[2018-04-15T22:03:29+00:00] WARN: Node kalib6.test.com has an empty run list.
Converging 4 resources
Recipe: @recipe_files::/root/exemplo.rb
  * yum_package[apache] action install (up to date)
  * service[httpd] action enable (up to date)
  * service[httpd] action start (up to date)
  * file[/var/www/html/index.html] action create (up to date)
  * file[/etc/motd] action create</p>

<pre><code>- update content in file /etc/motd from e3b0c4 to f13843
--- /etc/motd       2018-04-15 20:51:00.411479476 +0000
+++ /etc/.chef-motd20180415-1681-1p1fm7m    2018-04-15 22:03:42.142091791 +0000
@@ -1 +1,2 @@
+Bem Vindo!
- restore selinux security context
</code></pre>

<p>Running handlers:
Running handlers complete
Chef Client finished, 1/5 resources updated in 15 seconds
```</p>

<p><strong>P</strong>ara termos certeza de que o nosso arquivo foi corretamente alterado&hellip;</p>

<p><code>
[root@kalib6 ~]# cat /etc/motd
Bem Vindo!
</code></p>

<p><strong>N</strong>ovamente, nenhuma novidade até aqui.</p>

<p><strong>V</strong>amos agora utilizar o tipo de resource <code>execute</code>, o qual nos permite executar um comando a cada execução do chef-client. Vale lembrar que uma das características do Chef é a idempotência, portanto o <code>execute</code> pode ser considerado uma exceção, já que o comando será executado sempre, mesmo que já tenha sido executado anteriormente. E é neste tipo de situação que os <code>guards</code> se mostram importantes.</p>

<p><strong>C</strong>omecemos inserindo um resource do tipo <code>execute</code> em nossa recipe:</p>

<p>```
package &lsquo;apache&rsquo; do</p>

<pre><code>    package_name 'httpd'
    action :install
</code></pre>

<p>end
<a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet</a>
service &lsquo;httpd&rsquo; do</p>

<pre><code>    action [:enable, :start]
</code></pre>

<p>end</p>

<p>file &lsquo;/var/www/html/index.html&rsquo; do</p>

<pre><code>    content 'Hello World!'
    mode '0755'
    owner 'root'
    group 'apache'
</code></pre>

<p>end</p>

<p>file &lsquo;/etc/motd&rsquo; do</p>

<pre><code>    content 'Bem Vindo!'
</code></pre>

<p>end</p>

<p>execute &lsquo;meu-comando&rsquo; do</p>

<pre><code>    command 'echo " Obrigado!" &gt;&gt; /etc/motd'
    only_if 'test -r /etc/motd'
</code></pre>

<p>end
```</p>

<p><strong>O</strong> que adicionamos aqui?</p>

<ul>
<li>Resource Type: execute (Para que possamos executar um comando)</li>
<li>Resource Name: meu-comando (Poderíamos ter utilizado qualquer nome)</li>
<li>Command: &lsquo;echo &ldquo; Obrigado!&rdquo; >> /etc/motd&rsquo; (O comando que desejamos executar. Estou utilizando <code>echo</code> para inserir * Obrigado!* ao meu arquivo <code>/etc/motd</code>)</li>
<li>Guard: only_if &lsquo;test -r /etc/motd&rsquo; (<code>only_if</code> implica que meu resource <em>meu-comando</em> será executado <strong>apenas</strong> caso o resultado de <code>test -r /etc/motd</code> seja positivo. <em>test -r</em> irá verificar se o arquivo <code>/etc/motd</code> existe no sistema. Caso sim, meu comando <code>echo " Obrigado!" &gt;&gt; /etc/motd</code> será executado conforme planejado, do contrário será ignorado)</li>
</ul>


<p><strong>N</strong>ós já sabemos que o arquivo existe, portanto esperamos que * Obrigado!* seja adicionada ao mesmo após execução do chef-client.</p>

<p><strong>Verificando nosso código</strong></p>

<p><code>
[root@kalib6 ~]# ruby -c exemplo.rb &amp;&amp; foodcritic exemplo.rb
Syntax OK
Checking 1 files
x
FC011: Missing README in markdown format: ../README.md:1
FC031: Cookbook without metadata.rb file: ../metadata.rb:1
FC071: Missing LICENSE file: ../LICENSE:1
</code></p>

<p><strong>Tudo ok. Executando&hellip;</strong></p>

<p>```
[root@kalib6 ~]# chef-client &mdash;local-mode exemplo.rb
[2018-04-15T23:08:54+00:00] WARN: No config file found or specified on command line, using command line options.
[2018-04-15T23:08:54+00:00] WARN: No cookbooks directory found at or above current directory.  Assuming /root.
Starting Chef Client, version 13.8.5
resolving cookbooks for run list: []
Synchronizing Cookbooks:
Installing Cookbook Gems:
Compiling Cookbooks&hellip;
[2018-04-15T23:09:03+00:00] WARN: Node kalib6.test.com has an empty run list.
Converging 5 resources
Recipe: @recipe_files::/root/exemplo.rb
  * yum_package[apache] action install (up to date)
  * service[httpd] action enable (up to date)
  * service[httpd] action start (up to date)
  * file[/var/www/html/index.html] action create (up to date)
  * file[/etc/motd] action create (up to date)
  * execute[meu-comando] action run</p>

<pre><code>- execute echo " Obrigado!" &gt;&gt; /etc/motd
</code></pre>

<p>Running handlers:
Running handlers complete
Chef Client finished, 1/6 resources updated in 31 seconds
```</p>

<p><strong>R</strong>epare que o Chef executou o comando para inserir <code>Obrigado!</code>.</p>

<p><code>
[root@kalib6 ~]# cat /etc/motd
Bem Vindo! Obrigado!
</code></p>

<p><strong>C</strong>onforme dito anteriormente, o resource <code>execute</code> irá executar o meu comando SEMPRE que o chef-client rodar. Vejamos o que acontece ao executar novamente o chef-client sem alterar a recipe.</p>

<p>```
[root@kalib6 ~]# chef-client &mdash;local-mode exemplo.rb
[2018-04-15T23:18:10+00:00] WARN: No config file found or specified on command line, using command line options.
[2018-04-15T23:18:10+00:00] WARN: No cookbooks directory found at or above current directory.  Assuming /root.
Starting Chef Client, version 13.8.5
resolving cookbooks for run list: []
Synchronizing Cookbooks:
Installing Cookbook Gems:
Compiling Cookbooks&hellip;
[2018-04-15T23:18:20+00:00] WARN: Node kalib6.test.com has an empty run list.
Converging 5 resources
Recipe: @recipe_files::/root/exemplo.rb
  * yum_package[apache] action install (up to date)
  * service[httpd] action enable (up to date)
  * service[httpd] action start (up to date)
  * file[/var/www/html/index.html] action create (up to date)
  * file[/etc/motd] action create</p>

<pre><code>- update content in file /etc/motd from 201ddf to f13843
--- /etc/motd       2018-04-15 23:16:13.705005377 +0000
+++ /etc/.chef-motd20180415-2432-zhtjnq     2018-04-15 23:18:42.138379629 +0000
@@ -1,2 +1,2 @@
-Bem Vindo! Obrigado!
+Bem Vindo!
- restore selinux security context
</code></pre>

<ul>
<li>execute[meu-comando] action run

<ul>
<li>execute echo &ldquo; Obrigado!&rdquo; >> /etc/motd</li>
</ul>
</li>
</ul>


<p>Running handlers:
Running handlers complete
Chef Client finished, 2/6 resources updated in 31 seconds
```</p>

<p><strong>C</strong>omo em nossa recipe temos o resource <code>file</code> que determina o conteúdo do arquivo <code>/etc/motd</code> como sendo <code>Bem Vindo!</code>, o chef percebeu que o arquivo se encontrava diferente, pois acrescentamos o <code>Obrigado!</code> no passo anterior. O arquivo foi corrigido, voltando a ter seu conteúdo original, em seguida o Chef inseriu novamente <code>Obrigado!</code>, pois assim está determinado em nossa recipe.</p>

<p><strong>É</strong> fácil perceber isto nas linhas a seguir, retiradas do resultado de nossa última execução do chef-client:</p>

<p><code>
* file[/etc/motd] action create
  - update content in file /etc/motd from 201ddf to f13843
  --- /etc/motd       2018-04-15 23:16:13.705005377 +0000
  +++ /etc/.chef-motd20180415-2432-zhtjnq     2018-04-15 23:18:42.138379629 +0000
  @@ -1,2 +1,2 @@
  -Bem Vindo! Obrigado!
  +Bem Vindo!
  - restore selinux security context
* execute[meu-comando] action run
  - execute echo " Obrigado!" &gt;&gt; /etc/motd
</code></p>

<p><strong>S</strong>e verificarmos nosso arquivo, veremos que ele está da mesma forma:</p>

<p><code>
[root@kalib6 ~]# cat /etc/motd
Bem Vindo! Obrigado!
</code></p>

<p><strong>P</strong>ara percebermos a diferença, vamos comentar as linhas do resource file <code>/etc/motd</code>:</p>

<p>```
&hellip;</p>

<h1>file &lsquo;/etc/motd&rsquo; do</h1>

<h1>content &lsquo;Bem Vindo!&rsquo;</h1>

<h1>end</h1>

<p>&hellip;
```</p>

<p><strong>A</strong>o comentar estas linhas, nossa recipe não mais indicará que o conteúdo do arquivo <code>/etc/motd</code> deve ser <code>Bem Vindo!</code>, portanto vejamos o que acontece quando executamos novamente o chef-client.</p>

<p>```
[root@kalib6 ~]# chef-client &mdash;local-mode exemplo.rb
[2018-04-15T23:28:32+00:00] WARN: No config file found or specified on command line, using command line options.
[2018-04-15T23:28:33+00:00] WARN: No cookbooks directory found at or above current directory.  Assuming /root.
Starting Chef Client, version 13.8.5
resolving cookbooks for run list: []
Synchronizing Cookbooks:
Installing Cookbook Gems:
Compiling Cookbooks&hellip;
[2018-04-15T23:28:42+00:00] WARN: Node kalib6.test.com has an empty run list.
Converging 4 resources
Recipe: @recipe_files::/root/exemplo.rb
  * yum_package[apache] action install (up to date)
  * service[httpd] action enable (up to date)
  * service[httpd] action start (up to date)
  * file[/var/www/html/index.html] action create (up to date)
  * execute[meu-comando] action run</p>

<pre><code>- execute echo " Obrigado!" &gt;&gt; /etc/motd
</code></pre>

<p>Running handlers:
Running handlers complete
Chef Client finished, 1/5 resources updated in 32 seconds
```</p>

<p><strong>U</strong>ma vez que nosso arquivo <code>/etc/motd</code> já possuía o conteúdo <code>Bem Vindo! Obrigado!</code> e desta vez não tentou garantir que o conteúdo do mesmo fosse apenas <code>Bem Vindo!</code>, vejamos como ele se encontra:</p>

<p><code>
[root@kalib6 ~]# cat /etc/motd
Bem Vindo! Obrigado!
 Obrigado!
</code></p>

<p> <strong>C</strong>omo esperado, inserimos mais um <code>Obrigado!</code> ao arquivo. Se executarmos novamente o chef-client, estaremos acrescentando novamente um <code>Obrigado!</code> ao arquivo, pois o mesmo existe e não estamos mais tentando validar seu conteúdo.</p>

<p> <strong>E</strong> se removermos manualmente o arquivo <code>/etc/motd</code>?</p>

<p> <code>
[root@kalib6 ~]# rm /etc/motd
rm: remove regular file ‘/etc/motd’? y
[root@kalib6 ~]# cat /etc/motd
cat: /etc/motd: No such file or directory
</code></p>

<p><strong>V</strong>ejamos o que o chef-client fará:</p>

<p><code>
... (Ignorando linhas desnecessárias)
  * execute[meu-comando] action run (skipped due to only_if)
...
</code></p>

<p><strong>C</strong>omo já tínhamos comentado as linhas que garantem que o <code>/etc/motd</code> existe e possui o conteúdo <code>Bem Vindo!</code>, o resource que incluiría <code>Obrigado!</code> foi ignorado, pois em nossa guard temos a condição <code>only_if</code>, que indica que o comando só será executado SE o arquivo /etc/motd existir. Para ter certeza disto, vamos verificar:</p>

<p><code>
[root@kalib6 ~]# cat /etc/motd
cat: /etc/motd: No such file or directory
</code></p>

<p><strong>A</strong>proveitando a situação, vamos alterar nossa recipe e utilizar <code>not_if</code> ao invés de <code>only_if</code>:</p>

<p>```
package &lsquo;apache&rsquo; do</p>

<pre><code>    package_name 'httpd'
    action :install
</code></pre>

<p>end</p>

<p>service &lsquo;httpd&rsquo; do</p>

<pre><code>    action [:enable, :start]
</code></pre>

<p>end</p>

<p>file &lsquo;/var/www/html/index.html&rsquo; do</p>

<pre><code>    content 'Hello World!'
    mode '0755'
    owner 'root'
    group 'apache'
</code></pre>

<p>end</p>

<h1>file &lsquo;/etc/motd&rsquo; do</h1>

<h1>content &lsquo;Bem Vindo!&rsquo;</h1>

<h1>end</h1>

<p>execute &lsquo;meu-comando&rsquo; do</p>

<pre><code>    command 'echo " Obrigado!" &gt;&gt; /etc/motd'
    not_if 'test -r /etc/motd'
</code></pre>

<p>end
```</p>

<p><strong>J</strong>á sabemos que o arquivo não existe, portanto a nossa regra agora será satisfeita, visto que queremos adicionar o conteúdo <code>Obrigado!</code> APENAS caso o arquivo NÃO exista.</p>

<p><strong>V</strong>ale lembrar que, por padrão, o comando <code>echo ' Obrigado!' &gt;&gt; /etc/motd</code> irá adicionar o conteúdo ao arquivo e, caso o mesmo não exista, ele será criado com o determinado conteúdo. Isto não é um recurso do Chef, mas sim do próprio linux/echo. Executando nosso chef-client:</p>

<p>```
&hellip; (Ignorando linhas desnecessárias)
* execute[meu-comando] action run
  &ndash; execute echo &ldquo; Obrigado!&rdquo; >> /etc/motd</p>

<p>Running handlers:
Running handlers complete
```</p>

<p><strong>R</strong>epare que o arquivo foi criado apenas com o conteúdo <code>Obrigado!</code>, conforme descrito em nossa recipe.</p>

<p><code>
[root@kalib6 ~]# cat /etc/motd
 Obrigado!
</code></p>

<p><strong>C</strong>aso o chef-client seja executado novamente, nada acontecerá, uma vez que o resource atual indica que o comando APENAS deverá ser executado caso o arquivo NÃO exista.</p>

<p><code>
... (Ignorando linhas desnecessárias)
  * execute[meu-comando] action run (skipped due to not_if)
...
</code></p>

<p><strong>S</strong>imples, certo?! É importante lembrar que o Chef executará os resources na devida ordem em que forem listados na recipe, portanto é importante alinhar todas as instruções e resources de acordo com o resultado desejado.</p>

<p><strong>H</strong>appy hacking!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chef: Automação e Gerenciamento de Configuração]]></title>
    <link href="http://kalib.github.io/blog/2018/04/01/chef-aautomacao-e-gerenciamento-de-configuracao/"/>
    <updated>2018-04-01T11:22:00-04:00</updated>
    <id>http://kalib.github.io/blog/2018/04/01/chef-aautomacao-e-gerenciamento-de-configuracao</id>
    <content type="html"><![CDATA[<p>{% img center /imgs/cheflogo.png &lsquo;Chef&rsquo; %}</p>

<h2>Uma coisa de cada vez</h2>

<p><strong>C</strong>hef é uma popular ferramenta de Gerenciamento de Configurações criado pela empresa de mesmo nome, Chef. O <a href="https://www.chef.io">Chef</a> é desenvolvido em <a href="http://www.ruby-lang.org">Ruby</a> e <a href="https://www.erlang.org">Erlang</a>, e utiliza uma linguagem DSL (domain-specific language) em Ruby puro para escrever arquivos de configuração de sistemas chamados &ldquo;recipes&rdquo; (receitas).</p>

<p><strong>A</strong>ntes de falarmos sobre o Chef é importante entender primeiramente o conceito e a utilidade de ferramentas de Gerenciamento de Configuração.</p>

<h2>Gerenciamento de Configuração</h2>

<p><strong>G</strong>erenciamento de Configuração, ou CM (Configuration Management), é um processo de engenharia de sistemas que visa garantir a consistência entre ativos físicos e lógicos em um ambiente operacional. O processo de gerenciamento de configuração busca identificar e rastrear itens individuais de configuração, documentando capacidades funcionais e interdependências. Administradores, técnicos e desenvolvedores de sistemas podem utilizar ferramentas de Gerenciamento de Configuração para verificar o efeito que uma mudança em um item de configuração terá em outros sistemas.</p>

<p><strong>E</strong>m palavras simples, o objetivo de uma ferramenta de gerenciamento de configuração é simplificar a vida de quem administra serviços e sistemas garantindo uma uniformidade no quesito configuração.</p>

<p><strong>C</strong>omo exemplo prático e simplista, imagine um servidor web que será responsável por hospedar um pequeno site em php. Este servidor possuirá alguns atributos/aplicativos/configurações, tais como:</p>

<ul>
<li>Apache instalado;</li>
<li>Alterações específicas nos arquivos de configuração do Apache;</li>
<li>Serviço do Apache ativo e iniciado;</li>
<li>Arquivos referentes ao site em si em um diretório específico;</li>
<li>Permissões específicas atribuídas ao diretório específico do site;</li>
<li>etc&hellip;</li>
</ul>


<p><strong>C</strong>onfigurar tudo isso manualmente em um único servidor é simples. Você poderia conectar-se via SSH no servidor, instalar o apache com o gerenciador de pacotes da distribuição utilizada, configurar o que for necessário no apache, iniciar o serviço, etc, etc, etc. Mas o que fazer quando sua infraestrutura cresce? Quando se quer maior disponibilidade do site, quando agora você roda este site em um cluster com 5 servidores?</p>

<p><strong>B</strong>asicamente a mesma coisa, certo? Você pode se conectar em cada um dos servidores e repetir os mesmos passos. O problema se dá justamente nessa repetição de passos, onde você pode cometer erros, perder tempo, etc. Além disso, o que acontece se um colega seu modificar algo em um dos servidores e não lhe avisar? E se ele esquecer de replicar esta mudança nos demais?</p>

<p><strong>É</strong> fácil achar diversas razões pelas quais torna-se difícil administrar e gerenciar configurações em ambientes mais complexos. A ideia por trás de uma ferramenta de Gerenciamento de Configuração é justamente reduzir esta complexidade, eliminando a necessidade de conectar-se manualmente à diversos servidores para aplicar as mesmas rotinas, passos e configurações.</p>

<p><strong>A</strong>través de arquivos de texto podemos literalmente descrever o estado e as ações desejadas para nossos serviços e sistemas. Por exemplo: Posso dizer que possuo um grupo de servidores chamado WebServer, o qual contém 10 servidores com o Sistema Operacional CentOS 7. Posso incluir a informação de que preciso que todos eles estejam com a versão X do Apache instalada e que o serviço esteja ativo e rodando. Além disso, posso dizer que desejo que exista no diretório /var/www/meusite/ todo o conteúdo que está em um mapeamento de rede específico, ou mesmo em um repositório que possuo no github.</p>

<p><strong>A</strong>o invés de me conectar em cada um dos 10 servidores para fazer tudo isso, um simples comando será o suficiente. O comando em específico dependerá da solução adotada, visto que existem diversas ferramentas de CM (Gerenciamento de Configuração). Mas, basicamente, ele irá ler o(s) arquivo(s) de &ldquo;instruções&rdquo; que nós definimos e saberá em quais servidores ele deverá instalar o Apache e configurar de acordo com o especificado, nos dando apenas o resultado final em forma de relatório simples.</p>

<p><strong>E</strong> se alguém da equipe alterar um arquivo de configuração diretamente em um dos servidores? A ferramenta, em sua próxima execucação, irá identificar que o estado desejado para aquele meu grupo de servidores está diferente em um dos servidores. Ela então modificará aquele arquivo específico naquele servidor para que ele volte ao seu estado desejado.</p>

<p><strong>A</strong>lém desta segurança, nós agora passamos a ter um ponto único de modificação. Ao desejarmos mudar algo, o faremos apenas no nosso &ldquo;código&rdquo;, ao invés de o fazer nos 10 servidores manualmente.</p>

<p><strong>O</strong> mesmo benefício se dá em caso de erros e falhas: um ponto único de correção.</p>

<p><strong>C</strong>om este mecanismo de descrever o estado de nossa infraestrutura em arquivos de texto/código, entramos em um novo conceito: Infrastructure as Code, ou Infraestrutura como Código. Uma vez que temos nossa infraestrutura em formato de código, podemos literalmente versionar e gerenciar nossa infraestrutura com repositórios Git, por exemplo.</p>

<h2>O que é Chef?</h2>

<p><strong>C</strong>onforme dito mais acima, Chef é uma das mais populares ferramentas de Gerenciamento de Configuração disponíveis atualmente. É compatível e facilmente integrado à plataformas de computação em nuvem, tais como Internap, Amazon EC2, Google Cloud Platform, OpenStack, SoftLayer, Microsoft Azure e Rackspace, provendo e configurando servidores automaticamente.</p>

<p><strong>O</strong> usuário escreve &ldquo;recipes&rdquo; (receitas) que descrevem como o Chef deve gerenciar aplicações, servidores e utilitários. Estas &ldquo;recipes&rdquo;, as quais podem ser agrupadas em &ldquo;cookbooks&rdquo; (livros de receitas) descrevem uma série de recursos que devem estar em um determinado estado. Este recursos podem ser pacotes, serviços ou mesmo arquivos.</p>

<p><strong>C</strong>hef pode rodar em um modo cliente/servidor ou standalone, com o chamado &ldquo;chef-solo&rdquo;. No modo cliente/servidor, o cliente Chef envia uma série de atributos sobre o node ou cliente/host para o Chef server. O Chef server utiliza-se da ferramenta <a href="https://lucene.apache.org/solr">Solr</a> para indexar estes atributos e provê uma API na qual os clientes podem fazer consultas. As recipes podem fazer requisições à esta base de atributos e utilizar os dados resultantes para configurar o cliente ou node.</p>

<p><strong>E</strong>mbora inicialmente o Chef fosse utilizado para gerenciar exclusivamente máquinas Linux, as versões mais atuais também suportam máquinas Windows.</p>

<p><strong>A</strong> ideia para este post é dar uma breve introdução ao Chef, portanto não vou entrar em maiores detalhes do funcionamento por hora.</p>

<h3>Resources</h3>

<p><strong>C</strong>omo dito antes, um Resource é uma descrição de estado desejado para um determinado item. Estes resources são gerenciados através de recipes.</p>

<p><strong>U</strong>m resource possui basicamente 4 componentes fundamentais que são definidos em um bloco de código Ruby:</p>

<ul>
<li>Resource Type &ndash; Tipo de resource (Pode ser um pacote, serviço, arquivo&hellip;)</li>
<li>Resource Name &ndash; Nome do resource</li>
<li>Resource Properties &ndash; Propriedades do resource</li>
<li>Actions &ndash; Ações a serem aplicadas ao resource</li>
</ul>


<p><strong>U</strong>m exemplo de recipe para instalar o Apache em um servidor Ubuntu, por exemplo, seria o seguinte:</p>

<p>```
package &lsquo;httpd&rsquo; do</p>

<pre><code>action :install
</code></pre>

<p>end
```</p>

<p>No exemplo acima temos o tipo de resource como sendo &ldquo;package&rdquo;, o nome do resource como sendo &ldquo;httpd&rdquo; e a ação &ldquo;install&rdquo;.</p>

<p><strong>O</strong> que vai acontecer aqui? Simples de entender, certo? O pacote httpd (Apache) será instalado. Mas o que acontece caso o pacote httpd já esteja instalado?</p>

<p><strong>N</strong>ada. Uma das características do Chef é a <strong>idempotência</strong>. Na matemática e ciência da computação, a idempotência é a propriedade que algumas operações têm de poderem ser aplicadas várias vezes sem que o valor do resultado se altere após a aplicação inicial. Ou seja, O Chef primeiramente confere se o estado desejado já está aplicado e, caso sim, ignora aquela instrução.</p>

<p><strong>N</strong>ovamente&hellip; A ideia para este post é dar uma breve introdução ao Chef, portanto não vou entrar em maiores detalhes sobre os tipos de resources e suas possíveis ações. Vamos ao que interessa&hellip;</p>

<h2>Instalando o Chef</h2>

<p><strong>C</strong>onforme explicado acima, o Chef pode ser utilizado em modo cliente/servidor ou standalone. Para esta introdução utilizaremos o modo standalone ou local para simplificar as coisas.</p>

<p><strong>P</strong>ara instalar podemos utilizar o gerenciador de pacotes da distribuição Linux que utilizamos ou baixando o chefdk (Development Kit) através da página de <a href="https://downloads.chef.io/chefdk">downloads do chef</a>.</p>

<h3>Arch Linux</h3>

<p><strong>N</strong>o meu caso, utilizarei o pacote <a href="https://aur.archlinux.org/packages/chef-dk/">chef-dk</a> existente para o Arch Linux, mas sinta-se livre para baixar diretamente no site e executar o pacote de acordo com sua distribuição.</p>

<p><strong>1- Baixar o pacote do AUR:</strong></p>

<p><code>
$ wget https://aur.archlinux.org/cgit/aur.git/snapshot/chef-dk.tar.gz
</code></p>

<p><strong>2- Descompactar e Compilar:</strong></p>

<p>```
$ tar -xvzf chef-dk.tar.gz</p>

<p>$ cd chef-dk</p>

<p>$ makepkg
```</p>

<p><strong>3- Instalar o pacote:</strong></p>

<p><code>
$ sudo pacman -U chef-dk-2.5.3-1-x86_64.pkg.tar.xz
</code></p>

<p><strong>4- Confirmar que deu tudo certo:</strong>*</p>

<p>```
$ chef &mdash;version</p>

<p>Chef Development Kit Version: 2.5.3
chef-client version: 13.8.5
delivery version: master (73ebb72a6c42b3d2ff5370c476be800fee7e5427)
berks version: 6.3.1
kitchen version: 1.20.0
inspec version: 1.51.21
```</p>

<h3>Centos, Debian, Ubuntu&hellip;</h3>

<p><strong>N</strong>o CentOS, Ubuntu, Debian ou outras distribuições, o procedimento será relativamente parecido, portanto vejamos como seria no caso do CentOS baixando o arquivo diretamente do site de downloads:</p>

<p><strong>1- Baixar o arquivo .rpm para Red Hat:</strong> <a href="https://downloads.chef.io/chefdk">Aqui</a></p>

<p><code>
$ wget https://packages.chef.io/files/stable/chefdk/2.5.3/el/7/chefdk-2.5.3-1.el7.x86_64.rpm
</code></p>

<p><strong>2- Instalar via RPM:</strong></p>

<p><code>
$ sudo rpm -ivh chefdk-2.5.3-1.el7.x86_64.rpm
</code></p>

<p><strong>3- Confirmar que deu tudo certo:</strong></p>

<p>```
$ chef &mdash;version</p>

<p>Chef Development Kit Version: 2.5.3
chef-client version: 13.8.5
delivery version: master (73ebb72a6c42b3d2ff5370c476be800fee7e5427)
berks version: 6.3.1
kitchen version: 1.20.0
inspec version: 1.51.21
```</p>

<h2>Testando o Chef Localmente</h2>

<p><strong>P</strong>ara facilitar o entendimento, vamos criar uma recipe simples para aplicarmos localmente.</p>

<p><strong>V</strong>amos começar criando um arquivo chamado <strong>exemplo.rb</strong> com o seguinte conteúdo:</p>

<p>```
package &lsquo;apache&rsquo; do</p>

<pre><code>    package_name 'httpd'
    action :install
</code></pre>

<p>end
```</p>

<p><strong>O</strong> que temos aqui?</p>

<ul>
<li>Resource Type: package (Pois queremos instalar o pacote httpd)</li>
<li>Resource Name: apache (Embora o nome do pacote no CentOS seja httpd, o nome do nosso resource aqui é apache, mas poderia ser qualquer coisa que desejarmos)</li>
<li>Resource Properties: Aqui temos apenas <em>package_name</em> como propriedade, no qual damos o nome do pacote desejado. OBS: Caso não utilizemos a propriedade <em>package_name</em>, ele buscará por um pacote com mesmo nome do resource. No nosso caso, demos o nome <em>apache</em> para nosso resource, portanto ele buscaria por um pacote chamado <em>apache</em> e falharia, pois no CentOS este pacote não existe.</li>
<li>Actions: install (Temos apenas uma ação para esta recipe, que é justamente a de instalar o pacote, caso já não esteja instalado (idempotência))</li>
</ul>


<p><strong>S</strong>alve o arquivo e verifique o mesmo com os dois passos a seguir:</p>

<p><strong>1-</strong> Verifique se a sintaxe ruby está correta:</p>

<p>```</p>

<h1>ruby -c exemplo.rb</h1>

<p>Syntax OK
```</p>

<p><strong>2-</strong> Utilize uma ferramenta do chef para verificar se a recipe está de acordo com o esperado pelo Chef:</p>

<p>```</p>

<h1>foodcritic exemplo.rb</h1>

<p>Checking 1 files
x
FC011: Missing README in markdown format: ../README.md:1
FC031: Cookbook without metadata.rb file: ../metadata.rb:1
FC071: Missing LICENSE file: ../LICENSE:1
```</p>

<p>PS: Não se espante por enquanto com estes Warnings. Ele apenas está indicando que não possuímos um metadata, um readme e uma licença, pois não os criamos para este exemplo.</p>

<p><strong>V</strong>erificado o código e aprovado, vamos executar esta recipe localmente.
<em>(Repare no retorno que será apresentado, onde ele verifica o tipo de resource e identifica que estamos rodando em uma máquina CentoOS, portanto utiliza por padrão o yum para instalar o pacote desejado.)</em></p>

<p>```</p>

<h1>chef-client &mdash;local-mode exemplo.rb</h1>

<p>[2018-04-01T19:18:00+00:00] WARN: No config file found or specified on command line, using command line options.
[2018-04-01T19:18:00+00:00] WARN: No cookbooks directory found at or above current directory.  Assuming /root.
Starting Chef Client, version 13.8.5
resolving cookbooks for run list: []
Synchronizing Cookbooks:
Installing Cookbook Gems:
Compiling Cookbooks&hellip;
[2018-04-01T19:18:03+00:00] WARN: Node kalib6.test.com has an empty run list.
Converging 1 resources
Recipe: @recipe_files::/root/exemplo.rb
  * yum_package[apache] action install</p>

<pre><code>- install version 2.4.6-67.el7.centos.6 of package httpd
</code></pre>

<p>Running handlers:
Running handlers complete
Chef Client finished, 1/1 resources updated in 16 seconds
[2018-04-01T19:18:17+00:00] WARN: No config file found or specified on command line, using command line options.
```</p>

<p><strong>S</strong>imples, certo? O pacote httpd (Apache) foi instalado em nosso CentOS. Verificando o status do serviço httpd, veremos que o serviço não está rodando e também não está ativo.</p>

<p>```</p>

<h1>systemctl status httpd</h1>

<p>● httpd.service &ndash; The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled)
   Active: inactive (dead)</p>

<pre><code> Docs: man:httpd(8)
       man:apachectl(8)
</code></pre>

<p>```</p>

<p><strong>I</strong>sto está correto, afinal o Chef vai deixar a máquina no estado que determinamos. O determinado foi apenas instalar o pacote httpd. Mas de nada ele serve sem estar rodando como serviço, portanto vamos editar nossa recipe <em>exemplo.rb</em> e incluir nela um novo resource, desta vez um resource do tipo <em>service</em>, ou serviço. Sim, podemos ter diversos resources em uma mesma recipe. ;]</p>

<p><strong>E</strong>dite sua recipe para que ela possua o seguinte conteúdo:</p>

<p>```
package &lsquo;apache&rsquo; do</p>

<pre><code>    package_name 'httpd'
    action :installchef_httpd_default.png
</code></pre>

<p>end</p>

<p>service &lsquo;httpd&rsquo; do</p>

<pre><code>    action [:enable, :start]
</code></pre>

<p>end
```</p>

<p><strong>O</strong> que adicionamos aqui?</p>

<ul>
<li>Resource Type: service (Pois queremos gerenciar o serviço httpd)</li>
<li>Resource Name: httpd (Poderíamos ter utilizado qualquer nome, mas para simplificar e não precisarmos utilizar uma propriedade de nome, deixaremos o resource com o nome do serviço, <em>httpd</em>)</li>
<li>Actions: enable e start (Como nosso objetivo é não apenas iniciar o serviço, mas também deixá-lo habilitado para ser iniciado automaticamente após reinicialização, utilizaremos o <em>enable</em> e o <em>start</em>) &ndash;> equivalente aos comandos <em>systemctl enable httpd</em> e <em>systemctl start httpd</em></li>
</ul>


<p><strong>N</strong>ovamente vamos verificar nosso código via ruby e foodcritic:</p>

<p>```</p>

<h1>ruby -c exemplo.rb &amp;&amp; foodcritic exemplo.rb</h1>

<p>```</p>

<p><strong>E</strong> executando nossa recipe. (Novamente, o pacote httpd já está instalado, esta parte da recipe será ignorada automaticamente pelo Chef.)</p>

<p>```</p>

<h1>chef-client &mdash;local-mode exemplo.rb</h1>

<p>[2018-04-01T19:32:26+00:00] WARN: No config file found or specified on command line, using command line options.
[2018-04-01T19:32:26+00:00] WARN: No cookbooks directory found at or above current directory.  Assuming /root.
Starting Chef Client, version 13.8.5
resolving cookbooks for run list: []
Synchronizing Cookbooks:
Installing Cookbook Gems:
Compiling Cookbooks&hellip;
[2018-04-01T19:32:28+00:00] WARN: Node kalib6.test.com has an empty run list.
Converging 2 resources
Recipe: @recipe_files::/root/exemplo.rb
  * yum_package[apache] action install (up to date)
  * service[httpd] action enable</p>

<pre><code>- enable service service[httpd]
</code></pre>

<ul>
<li>service[httpd] action start

<ul>
<li>start service service[httpd]</li>
</ul>
</li>
</ul>


<p>Running handlers:
Running handlers complete
Chef Client finished, 2/3 resources updated in 06 seconds
[2018-04-01T19:32:33+00:00] WARN: No config file found or specified on command line, using command line options.
```</p>

<p><strong>A</strong>gora podemos verificar que nosso serviço httpd está de fato rodando.</p>

<p>```</p>

<h1>systemctl status httpd &amp;&amp; ps aux | grep httpd</h1>

<p>● httpd.service &ndash; The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor preset: disabled)
   Active: active (running) since Sun 2018-04-01 19:32:33 UTC; 1min 17s ago</p>

<pre><code> Docs: man:httpd(8)
       man:apachectl(8)
</code></pre>

<p> Main PID: 2409 (httpd)
   Status: &ldquo;Total requests: 0; Current requests/sec: 0; Current traffic:   0 B/sec&rdquo;
   CGroup: /system.slice/httpd.service</p>

<pre><code>       ├─2409 /usr/sbin/httpd -DFOREGROUND
       ├─2410 /usr/sbin/httpd -DFOREGROUND
       ├─2411 /usr/sbin/httpd -DFOREGROUND
       ├─2412 /usr/sbin/httpd -DFOREGROUND
       ├─2413 /usr/sbin/httpd -DFOREGROUND
       └─2414 /usr/sbin/httpd -DFOREGROUND
</code></pre>

<p>Apr 01 19:32:33 kalib6.test.com systemd[1]: Starting The Apache HTTP Server&hellip;
Apr 01 19:32:33 kalib6.test.com systemd[1]: Started The Apache HTTP Server.
root      2409  0.0  0.2 226040  4948 ?        Ss   19:32   0:00 /usr/sbin/httpd -DFOREGROUND
apache    2410  0.0  0.1 226040  2872 ?        S    19:32   0:00 /usr/sbin/httpd -DFOREGROUND
apache    2411  0.0  0.1 226040  2872 ?        S    19:32   0:00 /usr/sbin/httpd -DFOREGROUND
apache    2412  0.0  0.1 226040  2872 ?        S    19:32   0:00 /usr/sbin/httpd -DFOREGROUND
apache    2413  0.0  0.1 226040  2872 ?        S    19:32   0:00 /usr/sbin/httpd -DFOREGROUND
apache    2414  0.0  0.1 226040  2872 ?        S    19:32   0:00 /usr/sbin/httpd -DFOREGROUND
root      2425  0.0  0.0 112660   976 pts/0    R+   19:33   0:00 grep &mdash;color=auto httpd
```</p>

<p><strong>A</strong>lém disso, você pode testar seu novo servidor web diretamente em seu navegador. Caso esteja executando tudo em localhost, pode utilizar <em>localhost</em> como endereço. Caso contrário, pode utilizar o endereço ip da máquina em questão.</p>

<p>{% img center /imgs/chef_httpd_default.png &lsquo;Chef&rsquo; %}</p>

<p><strong>A</strong> página padrão do Apache não é algo que queremos, portanto vamos criar nosso próprio site (Hello World) para exemplificar melhor. Para isto editaremos novamente nossa recipe e incluiremos mais um resource, do tipo <em>file</em>, ou arquivo. O conteúdo de sua recipe deverá ficar assim:</p>

<p>```
package &lsquo;apache&rsquo; do</p>

<pre><code>    package_name 'httpd'
    action :install
</code></pre>

<p>end</p>

<p>service &lsquo;httpd&rsquo; do</p>

<pre><code>    action [:enable, :start]
</code></pre>

<p>end</p>

<p>file &lsquo;/var/www/html/index.html&rsquo; do</p>

<pre><code>    content 'Hello World!'
    mode '0755'
    owner 'root'
    group 'apache'
</code></pre>

<p>end
```</p>

<p><strong>O</strong> que adicionamos aqui?</p>

<ul>
<li>Resource Type: file (Pois queremos gerenciar o nosso arquivo index.html, o qual, caso não exista, será criado)</li>
<li>Resource Name: /var/www/html/index.html (Poderíamos ter utilizado qualquer nome, mas para simplificar e não precisarmos utilizar uma propriedade de nome, deixaremos o resource com o nome do arquivo que vamos utilizar, <em>/var/www/html/index.html</em>)</li>
<li>Content: Hello World! (Para simplificar teremos uma simples string <em>Hello World!</em> como conteúdo de nosso site)</li>
<li>Mode: Permissão que desejamos atribuir ao arquivo index.html</li>
<li>Owner: Dono que deve ser atribuído ao arquivo index.html</li>
<li>Group: Grupo que deve ser atribuído ao arquivo index.html</li>
</ul>


<p><strong>N</strong>ovamente vamos verificar nosso código via ruby e foodcritic:</p>

<p>```</p>

<h1>ruby -c exemplo.rb &amp;&amp; foodcritic exemplo.rb</h1>

<p>```</p>

<p><strong>E</strong> executaremos novamente nossa recipe. (Assim como anteriormente, o Chef ignorará as instruções referentes aos resources que já se encontram no estado desejado)</p>

<p>```</p>

<h1>chef-client &mdash;local-mode exemplo.rb</h1>

<p>[2018-04-01T19:48:00+00:00] WARN: No config file found or specified on command line, using command line options.
[2018-04-01T19:48:00+00:00] WARN: No cookbooks directory found at or above current directory.  Assuming /root.
Starting Chef Client, version 13.8.5
resolving cookbooks for run list: []
Synchronizing Cookbooks:
Installing Cookbook Gems:
Compiling Cookbooks&hellip;
[2018-04-01T19:48:02+00:00] WARN: Node kalib6.test.com has an empty run list.
Converging 3 resources
Recipe: @recipe_files::/root/exemplo.rb
  * yum_package[apache] action install (up to date)
  * service[httpd] action enable (up to date)
  * service[httpd] action start (up to date)
  * file[/var/www/html/index.html] action create</p>

<pre><code>- create new file /var/www/html/index.html
- update content in file /var/www/html/index.html from none to 7f83b1
--- /var/www/html/index.html        2018-04-01 19:48:06.829566745 +0000
+++ /var/www/html/.chef-index20180401-2631-164958p.html     2018-04-01 19:48:06.829566745 +0000
@@ -1 +1,2 @@
+Hello World!
- change mode from '' to '0755'
- change owner from '' to 'root'
- change group from '' to 'apache'
- restore selinux security context
</code></pre>

<p>Running handlers:
Running handlers complete
Chef Client finished, &frac14; resources updated in 06 seconds
[2018-04-01T19:48:07+00:00] WARN: No config file found or specified on command line, using command line options.
```</p>

<p><strong>P</strong>odemos verificar que o Chef criou o nosso arquivo index.html, atribuindo o dono, grupo e permissão que indicamos:</p>

<p>```</p>

<h1>ls -lh /var/www/html/</h1>

<p>total 4.0K
-rwxr-xr-x. 1 root apache 12 Apr  1 19:48 index.html
```</p>

<p><strong>T</strong>ambém podemos voltar em nosso navegador e atualizar a página para que vejamos o nosso Hello World ao invés da página padrão do Apache.</p>

<p>{% img center /imgs/chef_httpd_hw.png &lsquo;Chef&rsquo; %}</p>

<h2>Vale a pena?</h2>

<p><strong>R</strong>ealizar este processo manualmente na mesma máquina CentoOS seria mais rápido do que utilizando o Chef. Vamos rever:</p>

<p><strong>O</strong> que precisamos?</p>

<ul>
<li>Instalar o pacote httpd</li>
<li>Habilitar e Iniciar o serviço httpd</li>
<li>Criar o arquivo index.html com o conteúdo &ldquo;Hello World!&rdquo;</li>
</ul>


<p><strong>F</strong>azendo manualmente seria apenas uma questão de executarmos 4 comandos:</p>

<p>```</p>

<h1>yum install httpd</h1>

<h1>systemctl enable httpd &amp;&amp; systemctl start httpd</h1>

<h1>echo &ldquo;Hello World!&rdquo; > /var/www/html/index.html</h1>

<h1>chmod 0755 /var/www/html/index.html &amp;&amp; chown root:apache /var/www/html/index.html</h1>

<p>```</p>

<p><strong>S</strong>im, é verdade que fazendo manualmente neste caso seria MUITO mais rápido. O importante é lembrar do que falamos anteriormente: E se não for apenas 1 servidor? E se for um grupo? E se ao invés de apenas 3 resources, tiver 15? ou 40? E se alguém modificar algo em algum dos resources? Como você saberá qual foi? Vai verificar todos um a um para identificar o que precisa ser corrigido?</p>

<h1>Vantagens:</h1>

<p><strong>I</strong>magine que algum membro de sua equipe alterou a permissão do arquivo index.html sem lhe avisar, por exemplo ele foi lá e&hellip;</p>

<p>```</p>

<h1>chmod 0666 /var/www/html/index.html</h1>

<p>```</p>

<p><strong>L</strong>embrando que em nossa recipe exemplo.rb, definimos a permissão 0755. Neste caso, sempre que executarmos a recipe, o Chef irá verificar todos os resources e corrigir o que quer que tenha sido alterado.</p>

<p>```</p>

<h1>chef-client &mdash;local-mode exemplo.rb</h1>

<p>[2018-04-01T20:04:08+00:00] WARN: No config file found or specified on command line, using command line options.
[2018-04-01T20:04:08+00:00] WARN: No cookbooks directory found at or above current directory.  Assuming /root.
Starting Chef Client, version 13.8.5
resolving cookbooks for run list: []
Synchronizing Cookbooks:
Installing Cookbook Gems:
Compiling Cookbooks&hellip;
[2018-04-01T20:04:10+00:00] WARN: Node kalib6.test.com has an empty run list.
Converging 3 resources
Recipe: @recipe_files::/root/exemplo.rb
  * yum_package[apache] action install (up to date)
  * service[httpd] action enable (up to date)
  * service[httpd] action start (up to date)
  * file[/var/www/html/index.html] action create</p>

<pre><code>- change mode from '0666' to '0755'
- restore selinux security context
</code></pre>

<p>Running handlers:
Running handlers complete
Chef Client finished, &frac14; resources updated in 06 seconds
[2018-04-01T20:04:14+00:00] WARN: No config file found or specified on command line, using command line options.
```</p>

<p><strong>R</strong>epare na linha <em>&ndash; change mode from &lsquo;0666&rsquo; to &lsquo;0755&rsquo;</em>. O Chef acabou de corrigir automaticamente sem que nós tenhamos de vasculhar cada componente e arquivo em nosso servidor para saber o que foi alterado ou o que está diferente do estado desejado. Novamente, aqui tratamos de um servidor único, com apenas um arquivo. Imagine ter que varrer manualmente diversos servidores e diversos arquivos e diretórios?</p>

<p><strong>N</strong>este exemplo, provavelmente o site poderia continuar funcionando, pois foi alterada apenas a permissão de um único arquivo, certo? Mas imagine que sem querer ele acabou parando o serviço httpd, ou até desinstalou o mesmo? Em uma instalação padrão com Chef Server, existem agendamentos que fazem com que o Chef execute as recipes a cada X minutos, portanto o serviço seria inicializado novamente automaticamente, ou mesmo instalado caso necessário.</p>

<p><strong>É</strong> fácil imaginar diversos cenários nos quais seria útil ter a sua infraestrutura em formato de código.</p>

<p><strong>I</strong>magine uma catástrofe em que seu servidor simplesmente parou de funcionar e você precisará criar outro. Novamente você teria que executar aqueles comandos. Se desde o início tivesse utilizado Chef, ou outra ferramenta de Gerenciamento de Configuração, você poderia ter a sua recipe armazenada em um repositório Git, por exemplo, conforme mencionado no início deste post, e bastaria apenas executar o seu chef-client para instalar os pacotes necessários, habilitar e inicializar serviços, criar arquivos, etc.</p>

<p><strong>A</strong> imaginação é o seu limite. ;]</p>

<p><strong>E</strong>m posts futuros pretendo explorar mais a fundo o Chef, bem como outras ferramentas.</p>

<p><strong>H</strong>appy Hacking!</p>
]]></content>
  </entry>
  
</feed>
