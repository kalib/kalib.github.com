
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Marcelo Cavalcante Rocha ~</title>
  <meta name="author" content="Marcelo Cavalcante Rocha - Kalib">

  
  <meta name="description" content="Terraform &ndash; Uma robusta opção para Infraestrutura como Código A Hashicorp é uma empresa de bastante destaque no meio DevOps por ter criado &hellip;">
  

  <!-- https://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://kalib.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Marcelo Cavalcante Rocha ~" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at https://google.com/webfonts -->
<link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42903485-1']);
    _gaq.push(['_setDomainName','marcelocavalcante.net']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'https://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:kalib.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="blue_light">
            Marcelo Cavalcante Rocha ~
        </span>
       
           <span class="blue_dark">
             Hacking the damn life...
           </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Arquivos</a></li>
  <li><a href="/about">Sobre mim</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/10/29/introducao-ao-terraform/">Introdução Ao Terraform</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2018-10-29T21:35:00-04:00" pubdate data-updated="true">Oct 29<span>th</span>, 2018</time>
        
         | <a href="/blog/2018/10/29/introducao-ao-terraform/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="center" src="/imgs/terraform-integrations.png" title="'Terraform'" ></p>

<h2>Terraform &ndash; Uma robusta opção para Infraestrutura como Código</h2>

<p><strong>A</strong> Hashicorp é uma empresa de bastante destaque no meio DevOps por ter criado várias soluções de automação, que englobam uma série de funcionalidades, como o <a href="https://packer.io">Packer</a> para criação de imagens de forma automatizada, conforme apresentado nestes dois posts  do blog (<a href="https://blog.marcelocavalcante.net/blog/2018/07/30/automatizando-a-criacao-de-imagens-com-packer/">1</a>, <a href="https://blog.marcelocavalcante.net/blog/2018/08/11/criando-uma-imagem-aws-ec2-com-packer-e-puppet/">2</a>), <a href="https://vagrant.io">Vagrant</a>, para provisionamento simples e rápido de máquinas, <a href="https://vaultproject.io">Vault</a>, para gerenciamento de senhas/segredos (<em>secrets</em>), <a href="https://consul.io">Consul</a>, para descoberta de serviços, <a href="nomadproject.io">Nomad</a>, para agendamento e automação de deployments, e o <a href="https://terraform.io">Terraform</a>, foco principal deste post, uma robusta ferramenta para criação de infraestrutura como código, ou <em>infrastructure as cdode</em>.</p>

<p><strong>C</strong>aso você não possua uma ideia muito clara de qual a idea por trás do conceito de infraestrutura como código, ou mesmo quais as vantagens de se utilizar esta metodologia de gerenciamento/criação de infraestrutura, sugiro que leia meu <a href="https://blog.marcelocavalcante.net/blog/2018/10/22/infraestrutura-como-codigo-com-terraform/">post anterior</a>, no qual explico alguns dos principais benefícios desta prática, bem como uma breve apresentação do Terraform.</p>

<p><strong>D</strong>e forma resumida, o Terraform é uma ferramenta disponível em formatos Open Source ou Enterprise, cujo intuito é permitir a criação de infraestrutura como código, possibilitando o controle de versões. Suporta diversos provedores tais como AWS, OpenStack, Azure, GCP, etc.</p>

<p><strong>U</strong>ma de suas principais características é a idempotência, termo muito utilizado na matemática ou em ciência da computação para indicar a propriedade que algumas operações têm de poderem ser aplicadas várias vezes sem que o valor do resultado se altere após a aplicação inicial. Ou seja, uma vez aplicado o seu código terraform, você poderá aplicá-lo quantas vezes desejar e nenhuma alteração será feita em sua infraestrutura, a menos que você tenha de fato alterado algo em seu código.</p>

<p><strong>O</strong> Terraform utiliza uma linguagem de alto nível e fácil de se reutilizar, uma vez que podemos criar módulos e utilizar estes módulos em diversos projetos distintos, mesmo que tenhamos módulos em repositórios também distintos.</p>

<p><strong>A</strong> ideia de possuir um &ldquo;plano&rdquo; de execução nos ajuda a identificar falhas em nosso código mais rapidamente, bem como prevenir problemas em nossa infraestrutura, visto que podemos ter uma visão geral de tudo o que será aplicado em nossa infra antes mesmo da execução real de nosso código, nos permitindo ter a certeza de que todas as alterações serão de fato intencionais.</p>

<p><strong>S</strong>empre digo que a melhor forma de se aprender uma nova tecnologia é colocando a mão na massa, portanto vamos escrever algumas linhas de código para entendermos as funcionalidades básicas bem como a sintaxe de código utilizada pelo Terraform.</p>

<p><strong>A</strong>ntes de pensarmos em cenários mais complexos devemos entender o básico, no entanto eu sempre gostei de ver algum resultado como forma de ter uma motivação real para meus estudos. Nunca gostei de apenas ler e escrever códigos que não resultam em nada, e acredito que todos devam sentir a mesma insatisfação ao não ter um uso real e prático para o que quer que esteja estudando.</p>

<p><strong>S</strong>eguindo esta ideia, antes de pensarmos em cenários mais complexos, vamos iniciar pelo básico, porém com algum resultado prático. A ideia para este post é termos um jogo clássico do Mario rodando em um container Docker que seja acessível através de nosso browser.</p>

<h2>Instalação</h2>

<p><strong>P</strong>ara este post precisaremos ter três aplicativos instalados:</p>

<ol>
<li>Um navegador ou browser qualquer; (Imagino que você já tenha algum&hellip;)</li>
<li>Docker;</li>
<li>Terraform</li>
</ol>


<h3>Docker</h3>

<p><strong>O</strong> processo de instalação do Docker varia de acordo com o seu sistema operacional. Caso queira maiores detalhes sobre sua instalação, bem como uma explicação introdutória de como ele funciona, você pode visitar <a href="https://blog.marcelocavalcante.net/blog/2015/08/20/docker-uma-alternativa-elegante-para-containers-no-linux/">este outro post</a>, embora você não precise ter nenhum conhecimento sobre Docker para seguir as instruções deste tutorial, visto que utilizaremos o Terraform para criar nosso container.</p>

<p><strong>N</strong>o <em>Archlinux</em> a instalação pode ser feita através do pacman:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># pacman install docker</span></code></pre></td></tr></table></div></figure>


<p><strong>N</strong>o <em>Windows</em> a instalação pode ser feita através do binário disponível no site oficial: (<a href="https://store.docker.com/editions/community/docker-ce-desktop-windows">https://store.docker.com/editions/community/docker-ce-desktop-windows</a>)</p>

<p><strong>N</strong>o <em>OS X</em>, você também pode baixar o binário diretamente no site oficial, (<a href="https://store.docker.com/editions/community/docker-ce-desktop-mac">https://store.docker.com/editions/community/docker-ce-desktop-mac</a>) ou através do brew:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew install docker</span></code></pre></td></tr></table></div></figure>


<h3>Terraform</h3>

<p><strong>A</strong> instalação do Terraform é tão simples quanto a do Docker.</p>

<p><strong>N</strong>o <em>Archlinux</em> a instalação pode ser feita através do pacman:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># pacman -S terraform</span></code></pre></td></tr></table></div></figure>


<p><strong>N</strong>o <em>Windows</em> e no <em>OS X</em> a instalação pode ser feita através do binário disponível no site oficial do Terraform: (<a href="https://www.terraform.io/downloads.html">https://www.terraform.io/downloads.html</a>)</p>

<p><strong>O</strong>utra opção para OS X é através do brew:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew install terraform</span></code></pre></td></tr></table></div></figure>


<h2>Verificando a instalação</h2>

<p><strong>U</strong>ma vez que você tenha instalado ambos, certifique-se de que a instalação foi bem sucedida e de que o serviço Docker esteja rodando em seu sistema. Para isto, abra algum terminal, console ou prompt do CMD (para usuários Windows) e digite o seguinte:</p>

<p>1- Para termos certeza de que o Terraform está instalado e funcionando:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>terraform -version</span></code></pre></td></tr></table></div></figure>


<p>Você deverá receber algum resultado com a versão do seu Terraform, similar a este:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Terraform v0.11.10</span></code></pre></td></tr></table></div></figure>


<p>2- Para termos certeza de que o Docker está devidamente instalado e rodando, digite:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker ps</span></code></pre></td></tr></table></div></figure>


<p>Você deverá receber algum resultado parecido com o seguinte:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span></code></pre></td></tr></table></div></figure>


<p><strong>N</strong>ão se assuste ou dê importância para este resultado do comando Docker, ele apenas indica o status atual de seu Docker, informando se você possui algum container rodando ou não. Caso você tenha acabado de instalar o mesmo ou iniciado o serviço do Docker, você provavelmente não terá nenhum container rodando.</p>

<p><strong>C</strong>aso o retorno de seu Docker ou Terraform não seja similar aos que apresentei acima, verifique se a instalação foi realmente bem sucedida ou, no caso do Docker, verifique se o mesmo está rodando, afinal ele não apenas precisa ser instalado, mas precisa estar rodando, diferentemente do Terraform que apenas precisa ser instalado.</p>

<h2>Iniciando nosso projeto</h2>

<p><img class="center" src="/imgs/mariodocker.png" title="'Super Mario'" ></p>

<h3>Escopo</h3>

<p><strong>O</strong> primeiro passo de qualquer projeto é identificar alguma espécie de esboço ou escopo para o mesmo.</p>

<p><strong>O</strong> que queremos para o nosso projeto é:</p>

<ol>
<li>Ter um jogo web do Mario;</li>
<li>Queremos que ele rode em um container, pois queremos uma aplicação em uma infraestrutura moderna e que possa ser capaz de rodar em qualquer local, seja em um servidor físico local, uma VM ou mesmo um provedor na nuvem, como AWS, GCP, Azure, etc.;</li>
<li>Como não sabemos onde ou como iremos fazer o deployment deste container, queremos fazer com que seja algo automatizado e portável para facilitar futuros planos, portanto queremos criar este container com o Terraform, para que possamos gerenciar nosso código, versionar, etc.</li>
<li>Não escreveremos a aplicação em si. O jogo do Mario já existe e uma imagem para Docker já está disponível para o mesmo através do seguinte link: (<a href="https://hub.docker.com/r/pengbai/docker-supermario/">https://hub.docker.com/r/pengbai/docker-supermario/</a>) (Mas nós não precisamos nos precoupar com isto agora, pois o Terraform vai cuidar de baixar a imagem para nós. ;])</li>
<li>A aplicação deverá estar acessível via browser local para que possamos ao menos garantir que o jogo está de fato funcionando.</li>
</ol>


<p><strong>E</strong>ste será o nosso escopo básico, portanto vamos começar nosso código.</p>

<h3>Projeto</h3>

<p><strong>O</strong> recurso mais básico em um código ou módulo Terraform é o <em>resource</em>, ou recurso. O Terraform suporta centenas de recursos diferentes, dentre eles o <em>docker_image</em>, que será o recurso de que precisaremos inicialmente.</p>

<p><strong>A</strong> partir deste momento não mais utilizarei a palavra recurso. Uma vez que o Terraform chama os recursos de <em>resources</em>, devemos nos acostumar com sua nomenclatura.</p>

<p><strong>A</strong>ntes de mais nada, vamos criar um diretório para nosso projeto. Chamaremos nosso projeto de Marioweb, visto que se trata de uma versao open source do jogo Mario.</p>

<p><strong>A</strong>qui estarei criando o diretório via linha de comando, mas sinta-se livre para criar um diretório da forma que você preferir. Após criar o diretório, com algum terminal ou console aberto (ou prompt do CMD para usuários do Windows), navegue até este diretório recém criado:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir marioweb
</span><span class='line'>
</span><span class='line'>$ cd marioweb</span></code></pre></td></tr></table></div></figure>


<p><strong>D</strong>entro do diretório <em>marioweb</em> crie um novo arquivo chamado <em>main.tf</em>.</p>

<p><strong>P</strong>ara manter um padrão, os arquivos de código do Terraform costumam utilizar o sufixo/extensão .tf e o principal arquivo em módulos ou projetos Terraform costuma se chamar <em>main.tf</em>, por se tratar do arquivo principal do módulo ou projeto.</p>

<p><strong>P</strong>ara criar este arquivo você poderá utilizar qualquer editor de textos de sua escolha: vim, emacs, vi, notepad, notepad++, sublime, atom, etc.</p>

<p><strong>E</strong>m nosso arquivo <em>main.tf</em> insira o seguinte conteúdo por enquanto:</p>

<p><strong>main.tf</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Baixar a imagem do Projeto Docker-SuperMario
</span><span class='line'>resource "docker_image" "image_id" {
</span><span class='line'>  name = "pengbai/docker-supermario:latest"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>O</strong> que temos no bloco de código acima:</p>

<ol>
<li>A primeira linha é apenas um comentário. Como boa prática, é importante termos comentários ao longo de nosso código para descrever o que pretendemos com aquele determinado trecho de código. E por hora, o que pretendemos é exatamente apenas isso: <em>Baixar a imagem do Projeto Docker-SuperMario</em> para nosso ambiente.</li>
<li>Na linha 2 estamos especificando que queremos utilizar um <em>resource</em>. Cada <em>resource</em> no Terraform leva dois parâmetros, sendo um deles o <em>tipo de resource</em> e o outro um <em>nome qualquer</em> para este resource. Como dito antes, este trecho de código pretende baixar a imagem do projeto SuperMario, portanto precisamos do tipo de <em>resource</em> chamado <em>docker_image</em>. Este é apenas um dos milhares de <em>resources</em> existentes para o Terraform. Em seguida estamos dando o nome <em>image_id</em> para nosso <em>resource</em> de tipo <em>docker_image</em>. O nome poderia ser qualquer um, até mesmo <em>minha_imagem_do_coracao</em>, mas para ficar mais descritiva e mantendo boas práticas, utilizarei <em>image_id</em>. Uma vez que identificamos o tipo de <em>resource</em> e o nome que queremos dar para ele, devemos encerrar a linha abrindo o bloco de código no qual listaremos os atributos deste <em>resource</em>. Para isto, utilizaremos um <em>{</em> para abrir este bloco.</li>
<li>Na linha 3 começamos a definir os atributos do nosso <em>resource</em>. A documentação do Terraform é excelente e lista todos os <em>resources</em> suportados, bem como todos os <em>atributos</em> suportados por cada <em>resource</em>. Neste caso, o único atributo que precisamos no momento é o <em>name</em>, ou nome da imagem que desejamos baixar. Em seguida, indicamos qual o nome da imagem desejada. Por padrão, o Docker adota a nomenclatura <em>&lt;REPOSITÓRIO/IMAGEM:TAG></em> para indicar a imagem desejada. Em nosso caso, o repositório onde a imagem se encontra se chama <em>pengbai</em> e a imagem em si é chamada de <em>docker-supermario</em>, portanto teremos: <em>name = &ldquo;pengbai/super-mario&rdquo;</em>. A <em>tag</em> não é obrigatória. Mas como desejo garantir que utilizaremos sempre a imagem mais recente, utilizarei a tag <em>latest</em> (última).</li>
<li>Uma vez que concluímos a definição de nosso <em>resource</em>, podemos fechar o nosso bloco de código para o mesmo utilizando um <em>}</em> na linha 4.</li>
</ol>


<p><strong>A</strong>gora que temos o início de nosso código, já podemos começar a testá-lo.</p>

<p><strong>D</strong>e volta ao nosso terminal/console, vamos iniciar o nosso ambiente Terraform para este projeto utilizando o comando <em>terraform init</em>. Este comando inicia nosso ambiente e baixa os plugins necessários para nosso projeto. No nosso caso, o Terraform baixará os plugins necessários para que nosso código possa lidar com o Docker.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ terraform init
</span><span class='line'>
</span><span class='line'>Initializing provider plugins...
</span><span class='line'>- Checking for available provider plugins on https://releases.hashicorp.com...
</span><span class='line'>- Downloading plugin for provider "docker" (1.1.0)...
</span><span class='line'>
</span><span class='line'>The following providers do not have any version constraints in configuration,
</span><span class='line'>so the latest version was installed.
</span><span class='line'>
</span><span class='line'>To prevent automatic upgrades to new major versions that may contain breaking
</span><span class='line'>changes, it is recommended to add version = "..." constraints to the
</span><span class='line'>corresponding provider blocks in configuration, with the constraint strings
</span><span class='line'>suggested below.
</span><span class='line'>
</span><span class='line'>* provider.docker: version = "~&gt; 1.1"
</span><span class='line'>
</span><span class='line'>Terraform has been successfully initialized!
</span><span class='line'>
</span><span class='line'>You may now begin working with Terraform. Try running "terraform plan" to see
</span><span class='line'>any changes that are required for your infrastructure. All Terraform commands
</span><span class='line'>should now work.
</span><span class='line'>
</span><span class='line'>If you ever set or change modules or backend configuration for Terraform,
</span><span class='line'>rerun this command to reinitialize your working directory. If you forget, other
</span><span class='line'>commands will detect it and remind you to do so if necessary.</span></code></pre></td></tr></table></div></figure>


<p><strong>S</strong>e você recebeu um retorno parecido com o meu, significa que tudo está como deveria e que seu projeto foi iniciado com sucesso. Caso você liste os arquivos e diretórios ocultos de seu diretório, perceberá que ao rodar o comando <em>terraform init</em>, um diretório oculto chamado <em>terraform</em> foi criado. É nele que ficarão as informações que o Terraform precisa para executar corretamente o seu código, incluindo os plugins que ele necessita. No nosso caso, o plugin para o Docker estará lá.</p>

<p><strong>N</strong>osso próximo passo será executar o <em>planejamento</em> de nosso código. Ao rodar o <em>planejamento</em> o terraform listará exatamente tudo o que ele fará caso nosso código seja de fato executado. Novamente em nosso console/terminal, execute <em>terraform plan</em>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ terraform plan
</span><span class='line'>
</span><span class='line'>Refreshing Terraform state in-memory prior to plan...
</span><span class='line'>The refreshed state will be used to calculate this plan, but will not be
</span><span class='line'>persisted to local or remote state storage.
</span><span class='line'>
</span><span class='line'>ATENÇÃO AQUI:
</span><span class='line'>------------------------------------------------------------------------
</span><span class='line'>
</span><span class='line'>An execution plan has been generated and is shown below.
</span><span class='line'>Resource actions are indicated with the following symbols:
</span><span class='line'>  + create
</span><span class='line'>
</span><span class='line'>Terraform will perform the following actions:
</span><span class='line'>
</span><span class='line'>  + docker_image.image_id
</span><span class='line'>      id:     &lt;computed&gt;
</span><span class='line'>      latest: &lt;computed&gt;
</span><span class='line'>      name:   "pengbai/docker-supermario:latest"
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Plan: 1 to add, 0 to change, 0 to destroy.
</span><span class='line'>
</span><span class='line'>------------------------------------------------------------------------
</span><span class='line'>
</span><span class='line'>Note: You didn't specify an "-out" parameter to save this plan, so Terraform
</span><span class='line'>can't guarantee that exactly these actions will be performed if
</span><span class='line'>"terraform apply" is subsequently run.</span></code></pre></td></tr></table></div></figure>


<p><strong>C</strong>aso você tenha recebido um retorno similar a este, significa que tudo parece correto em seu código e que apenas uma ação será executada, conforme descrito no resumo do plano ao final:</p>

<p><em>Plan: 1 to add, 0 to change, 0 to destroy.</em></p>

<p><strong>O</strong>u seja: Plano: 1 a adicionar, 0 a alterar, 0 a destruir.</p>

<p><strong>E</strong>xatamente o que queremos.</p>

<p><strong>C</strong>aso você tenha recebido uma mensagem de erro, significa que algo em seu código está errado. Por exemplo, se ao invés de utilizarmos <em>docker_image</em> como tipo de resource, utilizarmos <em>docker_images</em>, o resultado de meu <em>terraform plan</em> seria o seguinte:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ terraform plan
</span><span class='line'>
</span><span class='line'>Error: docker_images.image_id: Provider doesn't support resource: docker_images</span></code></pre></td></tr></table></div></figure>


<p><strong>O</strong> erro geralmente é claro e nos indica onde está o erro. No erro acima, o Terraform nos diz que o resource <em>docker_images</em> não é suportado. Se checarmos na documentação, veremos que o nome correto do <em>resource</em> é <em>docker_image</em> (no singular).</p>

<p><strong>U</strong>ma vez que nosso plano foi executado sem erros, chegou a hora de aplicarmos nosso projeto.</p>

<p><strong>E</strong>xecute o seu código através do comando <em>terraform apply</em>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ terraform apply
</span><span class='line'>
</span><span class='line'>An execution plan has been generated and is shown below.
</span><span class='line'>Resource actions are indicated with the following symbols:
</span><span class='line'>  + create
</span><span class='line'>
</span><span class='line'>Terraform will perform the following actions:
</span><span class='line'>
</span><span class='line'>  + docker_image.image_id
</span><span class='line'>      id:     &lt;computed&gt;
</span><span class='line'>      latest: &lt;computed&gt;
</span><span class='line'>      name:   "pengbai/docker-supermario:latest"
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Plan: 1 to add, 0 to change, 0 to destroy.
</span><span class='line'>
</span><span class='line'>Do you want to perform these actions?
</span><span class='line'>  Terraform will perform the actions described above.
</span><span class='line'>  Only 'yes' will be accepted to approve.
</span><span class='line'>
</span><span class='line'>  Enter a value:</span></code></pre></td></tr></table></div></figure>


<p><strong>R</strong>epare que mesmo ao utilizar <em>apply</em> ao invés de <em>plan</em>, uma espécie de planejamento também foi realizado antes da aplicação propriamente dita. O Terraform avaliou o código e nos indicou o que será realizado, perguntando-nos ao final se queremos ou não seguir com a execução. Caso tudo nos pareça correto, basta digitarmos <em>yes</em> e pressionar Enter novamente para que ele siga com a execução de fato.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  Enter a value: yes
</span><span class='line'>
</span><span class='line'>docker_image.image_id: Creating...
</span><span class='line'>  latest: "" =&gt; "&lt;computed&gt;"
</span><span class='line'>  name:   "" =&gt; "pengbai/docker-supermario:latest"
</span><span class='line'>docker_image.image_id: Still creating... (10s elapsed)
</span><span class='line'>docker_image.image_id: Still creating... (20s elapsed)
</span><span class='line'>docker_image.image_id: Still creating... (30s elapsed)
</span><span class='line'>docker_image.image_id: Still creating... (40s elapsed)
</span><span class='line'>docker_image.image_id: Creation complete after 47s (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7...9c3d62pengbai/docker-supermario:latest)
</span><span class='line'>
</span><span class='line'>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</span></code></pre></td></tr></table></div></figure>


<p><strong>A</strong>ssim como no <em>plan</em>, o Terraform ao final nos deu um breve relatório do que foi feito:</p>

<p><em>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</em></p>

<p><strong>O</strong>u seja: Aplicação completa! Recursos: 1 adicionado, 0 alterados, 0 destruídos.</p>

<p><strong>S</strong>e quisermos ter certeza de que de fato o Terraform baixou a imagem Docker de que precisamos, basta digitarmos o comando do Docker que lista as imagens que possúimos em nosso ambiente. A nossa nova imagem do supermario deverá estar lá. Digite <em>docker images</em>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker images
</span><span class='line'>REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
</span><span class='line'>pengbai/docker-supermario   latest              49beaba1c5cc        4 months ago        686MB</span></code></pre></td></tr></table></div></figure>


<p><strong>Ó</strong>timo, nossa imagem está presente em nosso ambiente.</p>

<p><strong>O</strong> Terraform também nos permite saber o que estamos utilizando em termos de <em>resources</em> através do comando <em>terraform show</em>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ terraform show
</span><span class='line'>
</span><span class='line'>docker_image.image_id:
</span><span class='line'>  id = sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62pengbai/docker-supermario:latest
</span><span class='line'>  latest = sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62
</span><span class='line'>  name = pengbai/docker-supermario:latest</span></code></pre></td></tr></table></div></figure>


<p><strong>V</strong>oltemos ao nosso código. Agora que já conseguimos fazer com que nosso código baixe a imagem que utilizaremos via Docker, chegou a hora de fazer algo com ela. Precisamos realizar o <em>deployment</em> da mesma em um container, certo?!</p>

<p><strong>V</strong>amos adicionar mais um <em>resource</em> em nosso código, desta vez um <em>resource</em> de tipo <em>docker_container</em>. Como o nome já diz, este <em>resource</em> lida com o container em si, e não mais apenas com a imagem.</p>

<p><strong>S</strong>eu código agora deverá estar da seguinte forma:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Baixar a imagem do Projeto Docker-SuperMario
</span><span class='line'>resource "docker_image" "image_id" {
</span><span class='line'>  name = "pengbai/docker-supermario:latest"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'># Inicia o Container
</span><span class='line'>resource "docker_container" "container_id" {
</span><span class='line'>  name  = "supermario"
</span><span class='line'>  image = "${docker_image.image_id.latest}"
</span><span class='line'>  ports {
</span><span class='line'>    internal = "8080"
</span><span class='line'>    external = "80"
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>I</strong>gnorando as linhas já descritas anteriormente, vamos descrever as novas linhas de nosso código:</p>

<ol>
<li>Na linha 6 inserimos apenas mais um comentário, indicando que ali começaremos a descrever o código que criará nosso Container.</li>
<li>Na linha 7 indicamos que queremos mais um <em>resource</em>. Desta vez o tipo de <em>resource</em> que queremos é o <em>docker_container</em>, indicando também que queremos dar o nome <em>container_id</em> a este <em>resource</em>. Novamente, ao fim da linha, abriremos o bloco de código para este <em>resource</em> com uma <em>{</em>.</li>
<li>Dentro de nosso bloco, na linha 8, começaremos a listar os atributos deste <em>resource</em>. O primeiro atributo que listaremos é o <em>name</em>, e para ele daremos o nome <em>supermario</em>.</li>
<li>Na linha 9 indicaremos o atributo <em>image</em> e utilizaremos nossa primeira interpolação, onde utilizaremos valores de outra parte de nosso código como se fossem variáveis. No nosso <em>resource</em> anterior, <em>docker_image</em>, nós demos um nome <em>image_id</em>que será utilizado agora. Incluiremos também a tag <em>latest</em>, pois, conforme pudemos ver na saída de nosso comando <em>terraform show</em>, esta foi a tag utilizada pelo terraform para identificar o último status daquele <em>resource</em>. Portanto, aqui utilizaremos a interpolação inserindo o que queremos entre <em>{}</em> seguidas do símbolo <em>$</em>, conforme prega a sintaxe do Terraform para interpolação de valores, portanto teremos: <em>${docker_image.image_id.latest}</em>, onde <em>docker_image</em> é o tipo de resource de onde queremos o valor, <em>image_id</em> é o nome do resource de onde queremos o valor e <em>latest</em> é a tag para dizer que queremos o último valor daquele <em>resource</em>. O único motivo pelo qual temos um tipo de <em>resource</em> e um nome de <em>resource</em> é para facilitar a identificação quando possuímos diversos <em>resources</em> do mesmo tipo. Imagine um projeto em que utilizaremos 5 imagens diferentes do Docker. Teríamos 5 <em>resources</em> do tipo <em>docker_image</em>, porém cada um deles teria um nome diferente, certo?!</li>
<li>Na linha 10 de nosso código iniciamos o bloco de portas, afinal, toda aplicação roda em uma porta específica e com containers não seria diferente.</li>
<li>Nas linhas 11 e 12 indicamos os valores para portas <em>interna</em> e <em>externa</em>, onde a porta <em>intern</em> será a porta utilizada para rodar a aplicação internamente no container, e <em>extern</em> será a porta que o Docker irá mapear em nosso sistema local para que possamos acessar a nossa aplicação. Portanto, em nosso exemplo, a aplicação supermario irá rodar na porta <em>8080</em> internamente no container, e a porta 80 será mapeada para que possamos acessá-la de nosso navegador local.</li>
<li>Nas linhas 13 e 14 apenas fecharemos os dois blocos de código que criamos, sendo estes o bloco <em>ports</em> e o bloco <em>resource</em> do <em>docker_container</em>.</li>
</ol>


<p><strong>N</strong>ovamente, vamos planejar nosso projeto com <em>terraform plan</em>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ terraform plan
</span><span class='line'>Refreshing Terraform state in-memory prior to plan...
</span><span class='line'>The refreshed state will be used to calculate this plan, but will not be
</span><span class='line'>persisted to local or remote state storage.
</span><span class='line'>
</span><span class='line'>docker_image.image_id: Refreshing state... (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7...9c3d62pengbai/docker-supermario:latest)
</span><span class='line'>
</span><span class='line'>------------------------------------------------------------------------
</span><span class='line'>
</span><span class='line'>An execution plan has been generated and is shown below.
</span><span class='line'>Resource actions are indicated with the following symbols:
</span><span class='line'>  + create
</span><span class='line'>
</span><span class='line'>Terraform will perform the following actions:
</span><span class='line'>
</span><span class='line'>  + docker_container.container_id
</span><span class='line'>      id:               &lt;computed&gt;
</span><span class='line'>      attach:           "false"
</span><span class='line'>      bridge:           &lt;computed&gt;
</span><span class='line'>      container_logs:   &lt;computed&gt;
</span><span class='line'>      exit_code:        &lt;computed&gt;
</span><span class='line'>      gateway:          &lt;computed&gt;
</span><span class='line'>      image:            "sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62"
</span><span class='line'>      ip_address:       &lt;computed&gt;
</span><span class='line'>      ip_prefix_length: &lt;computed&gt;
</span><span class='line'>      log_driver:       "json-file"
</span><span class='line'>      logs:             "false"
</span><span class='line'>      must_run:         "true"
</span><span class='line'>      name:             "supermario"
</span><span class='line'>      network_data.#:   &lt;computed&gt;
</span><span class='line'>      ports.#:          "1"
</span><span class='line'>      ports.0.external: "80"
</span><span class='line'>      ports.0.internal: "8080"
</span><span class='line'>      ports.0.ip:       "0.0.0.0"
</span><span class='line'>      ports.0.protocol: "tcp"
</span><span class='line'>      restart:          "no"
</span><span class='line'>      rm:               "false"
</span><span class='line'>      start:            "true"
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Plan: 1 to add, 0 to change, 0 to destroy.
</span><span class='line'>
</span><span class='line'>------------------------------------------------------------------------
</span><span class='line'>
</span><span class='line'>Note: You didn't specify an "-out" parameter to save this plan, so Terraform
</span><span class='line'>can't guarantee that exactly these actions will be performed if
</span><span class='line'>"terraform apply" is subsequently run.</span></code></pre></td></tr></table></div></figure>


<p><strong>R</strong>epare que desta vez apenas 1 ação será executada: a criação do container. Não estamos mais recebendo as informações referentes à ação de baixar a imagem. O motivo para isto é a propriedade de idempotência que citei anteriormente. O Terraform sabe que a imagem já foi baixada, portanto a mesma não precisa ser baixada novamente, a menos que tivéssemos mudado a versão da mesma, nome, repositório, etc.</p>

<p><strong>U</strong>ma vez que o plano esteja de acordo com o que queremos, podemos aplicar nosso código com <em>terraform apply</em>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ terraform apply
</span><span class='line'>docker_image.image_id: Refreshing state... (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7...9c3d62pengbai/docker-supermario:latest)
</span><span class='line'>
</span><span class='line'>An execution plan has been generated and is shown below.
</span><span class='line'>Resource actions are indicated with the following symbols:
</span><span class='line'>  + create
</span><span class='line'>
</span><span class='line'>Terraform will perform the following actions:
</span><span class='line'>
</span><span class='line'>  + docker_container.container_id
</span><span class='line'>      id:               &lt;computed&gt;
</span><span class='line'>      attach:           "false"
</span><span class='line'>      bridge:           &lt;computed&gt;
</span><span class='line'>      container_logs:   &lt;computed&gt;
</span><span class='line'>      exit_code:        &lt;computed&gt;
</span><span class='line'>      gateway:          &lt;computed&gt;
</span><span class='line'>      image:            "sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62"
</span><span class='line'>      ip_address:       &lt;computed&gt;
</span><span class='line'>      ip_prefix_length: &lt;computed&gt;
</span><span class='line'>      log_driver:       "json-file"
</span><span class='line'>      logs:             "false"
</span><span class='line'>      must_run:         "true"
</span><span class='line'>      name:             "supermario"
</span><span class='line'>      network_data.#:   &lt;computed&gt;
</span><span class='line'>      ports.#:          "1"
</span><span class='line'>      ports.0.external: "80"
</span><span class='line'>      ports.0.internal: "8080"
</span><span class='line'>      ports.0.ip:       "0.0.0.0"
</span><span class='line'>      ports.0.protocol: "tcp"
</span><span class='line'>      restart:          "no"
</span><span class='line'>      rm:               "false"
</span><span class='line'>      start:            "true"
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Plan: 1 to add, 0 to change, 0 to destroy.
</span><span class='line'>
</span><span class='line'>Do you want to perform these actions?
</span><span class='line'>  Terraform will perform the actions described above.
</span><span class='line'>  Only 'yes' will be accepted to approve.
</span><span class='line'>
</span><span class='line'>  Enter a value:</span></code></pre></td></tr></table></div></figure>


<p><strong>M</strong>ais uma vez ele nos dá uma visão geral do que será feito e nos perguntará se queremos prosseguir. Digite <em>yes</em> e pressione Enter novamente.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Enter a value: yes
</span><span class='line'>
</span><span class='line'>docker_container.container_id: Creating...
</span><span class='line'>attach:           "" =&gt; "false"
</span><span class='line'>bridge:           "" =&gt; "&lt;computed&gt;"
</span><span class='line'>container_logs:   "" =&gt; "&lt;computed&gt;"
</span><span class='line'>exit_code:        "" =&gt; "&lt;computed&gt;"
</span><span class='line'>gateway:          "" =&gt; "&lt;computed&gt;"
</span><span class='line'>image:            "" =&gt; "sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62"
</span><span class='line'>ip_address:       "" =&gt; "&lt;computed&gt;"
</span><span class='line'>ip_prefix_length: "" =&gt; "&lt;computed&gt;"
</span><span class='line'>log_driver:       "" =&gt; "json-file"
</span><span class='line'>logs:             "" =&gt; "false"
</span><span class='line'>must_run:         "" =&gt; "true"
</span><span class='line'>name:             "" =&gt; "supermario"
</span><span class='line'>network_data.#:   "" =&gt; "&lt;computed&gt;"
</span><span class='line'>ports.#:          "" =&gt; "1"
</span><span class='line'>ports.0.external: "" =&gt; "80"
</span><span class='line'>ports.0.internal: "" =&gt; "8080"
</span><span class='line'>ports.0.ip:       "" =&gt; "0.0.0.0"
</span><span class='line'>ports.0.protocol: "" =&gt; "tcp"
</span><span class='line'>restart:          "" =&gt; "no"
</span><span class='line'>rm:               "" =&gt; "false"
</span><span class='line'>start:            "" =&gt; "true"
</span><span class='line'>docker_container.container_id: Creation complete after 1s (ID: 8c9d35eac2fcdc0c7e530567323167b82e72f33d4645abf20685b99d802e2359)
</span><span class='line'>
</span><span class='line'>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</span></code></pre></td></tr></table></div></figure>


<p><strong>C</strong>onforme o esperado: Aplicaçao completa! <em>Resources</em>: 1 adicionado, 0 alterados, 0 destruídos.</p>

<p><strong>M</strong>ais uma vez podemos verificar se de fato tudo funcionou como o esperado através do Docker. Desta vez, não queremos apenas baixar uma imagem Docker, mas sim criar um container com a mesma abrindo portas específicas que serão mapeadas entre nosso sistema local e nosso container. Execute agora <em>docker ps</em> para ver os containers que estão rodando neste momento:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker ps
</span><span class='line'>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES
</span><span class='line'>8c9d35eac2fc        49beaba1c5cc        "catalina.sh run"   2 minutes ago       Up 2 minutes        0.0.0.0:80-&gt;8080/tcp   supermario</span></code></pre></td></tr></table></div></figure>


<p><strong>C</strong>omo podemos ver, temos um container rodando. Podemos até ver que existe um mapeamento de portas: *80->8080</p>

<p><strong>N</strong>ão está convencido ainda?</p>

<p><strong>A</strong>bra seu navegador e acesse o seguinte endereço: <em>localhost:80</em></p>

<p><strong>C</strong>aso o seu resultado seja algo parecido com a imagem, significa que seu código funcionou conforme o esperado.</p>

<p><img class="center" src="/imgs/mariodocker.png" title="'Super Mario'" ></p>

<p><strong>O</strong> terraform também nos permite destruir a nossa infraestrutura com o comando <em>terraform destroy</em>. Da mesma forma que o <em>apply</em>, o comando <em>destroy</em> também lhe dará uma prévia de o que será destruído e lhe pedirá par aconfirmar com um <em>yes</em> ou <em>no</em>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ terraform destroy
</span><span class='line'>docker_image.image_id: Refreshing state... (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7...9c3d62pengbai/docker-supermario:latest)
</span><span class='line'>docker_container.container_id: Refreshing state... (ID: 8c9d35eac2fcdc0c7e530567323167b82e72f33d4645abf20685b99d802e2359)
</span><span class='line'>
</span><span class='line'>An execution plan has been generated and is shown below.
</span><span class='line'>Resource actions are indicated with the following symbols:
</span><span class='line'>  - destroy
</span><span class='line'>
</span><span class='line'>Terraform will perform the following actions:
</span><span class='line'>
</span><span class='line'>  - docker_container.container_id
</span><span class='line'>
</span><span class='line'>  - docker_image.image_id
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Plan: 0 to add, 0 to change, 2 to destroy.
</span><span class='line'>
</span><span class='line'>Do you really want to destroy all resources?
</span><span class='line'>  Terraform will destroy all your managed infrastructure, as shown above.
</span><span class='line'>  There is no undo. Only 'yes' will be accepted to confirm.
</span><span class='line'>
</span><span class='line'>  Enter a value: yes
</span><span class='line'>
</span><span class='line'>docker_container.container_id: Destroying... (ID: 8c9d35eac2fcdc0c7e530567323167b82e72f33d4645abf20685b99d802e2359)
</span><span class='line'>docker_container.container_id: Destruction complete after 0s
</span><span class='line'>docker_image.image_id: Destroying... (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7...9c3d62pengbai/docker-supermario:latest)
</span><span class='line'>docker_image.image_id: Destruction complete after 2s
</span><span class='line'>
</span><span class='line'>Destroy complete! Resources: 2 destroyed.</span></code></pre></td></tr></table></div></figure>


<p><strong>C</strong>omo podemos ver, o terraform destruiu dois <em>resources</em>. Destruiu tanto nosso container como nossa imagem. Você poderá confirmar isso tentando acessar novamente o jogo pelo seu navegador ou mesmo através dos comandos <em>docker images</em> e <em>docker ls</em> para ver que tanto o container como a imagem foram removidos de nosso sistema:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker ps
</span><span class='line'>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</span><span class='line'>
</span><span class='line'>$ docker images
</span><span class='line'>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></code></pre></td></tr></table></div></figure>


<p><strong>D</strong>e volta ao nosso código, vamos incrementá-lo apenas um pouco mais.</p>

<p><strong>O</strong> terraform nos permite especificar também <em>outputs</em>, ou saídas que nos serão apresentadas ao executarmos nosso código. Apenas informações que podem nos ser úteis.</p>

<p><strong>P</strong>or exemplo, supomos que ao executar nosso código, desejamos que o terraform nos informe o IP do container que foi criado e o nome do mesmo, nosso código agora ficaria assim:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Baixar a imagem do Projeto Docker-SuperMario
</span><span class='line'>resource "docker_image" "image_id" {
</span><span class='line'>  name = "pengbai/docker-supermario:latest"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'># Inicia o Container
</span><span class='line'>resource "docker_container" "container_id" {
</span><span class='line'>  name  = "supermario"
</span><span class='line'>  image = "${docker_image.image_id.latest}"
</span><span class='line'>  ports {
</span><span class='line'>    internal = "8080"
</span><span class='line'>    external = "80"
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'># Nos informa o ip e nome do container criado
</span><span class='line'>output "Endereco IP" {
</span><span class='line'>  value = "${docker_container.container_id.ip_address}"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>output "Nome do Container" {
</span><span class='line'>  value = "${docker_container.container_id.name}"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>N</strong>ovamente, ignorando o código que já descrevemos anteriormente, teremos:</p>

<ol>
<li>Na linha 16 inserimos mais um comentário.</li>
<li>Na linha 17 especificamos que desta vez queremos um <em>output</em>, e não mais um <em>resource</em>. Da mesma forma que fizemos com <em>resources</em>, vamos dar um nome a este <em>output</em>, de forma que possamos facilmente identificá-lo posteriormente. No caso, vamos chamar nosso <em>output</em> de <em>Endereco IP</em>. Em seguida abriremos o bloco de código para este <em>output</em> novamente com <em>{</em>.</li>
<li>Na linha 18 daremos o <em>value</em> ou valor deste output. Novamente utilizaremos interpolação de valores para pegar este valor de nossos <em>resources</em>. Para conseguirmos o endereço ip do container, utilizaremos o atributo <em>ip_address</em>, que é um atributo descrito na documentação do Terraform como parte integrante do resource de tipo <em>docker_container</em>. Portanto, nosso <em>value</em> será: ${docker_container.container_id.ip_address}.</li>
<li>Na linha 19, apenas fechamos o bloco deste <em>output</em>.</li>
<li>Na linha 21 iniciamos nosso segundo <em>output</em>, com o nome <em>Nome do Container</em>. Em seguida, abriremos o bloco de código para este <em>output</em> com um <em>{</em>.</li>
<li>Na linha 22, faremos algo similar ao que fizemos com o <em>value</em> do output anterior. Utilizaremos interpolação para buscar o valor do atributo <em>name</em>, que faz parte do <em>resource</em> <em>docker_container</em>. Nosso <em>value</em> será: ${docker_container.container_id.name}</li>
<li>Na linha 23, apenas fechamos nosso <em>output</em>.</li>
</ol>


<p><strong>V</strong>amos então rodar nosso <em>plan</em> para ver o que aconteceria desta vez:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ terraform plan
</span><span class='line'>Refreshing Terraform state in-memory prior to plan...
</span><span class='line'>The refreshed state will be used to calculate this plan, but will not be
</span><span class='line'>persisted to local or remote state storage.
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>------------------------------------------------------------------------
</span><span class='line'>
</span><span class='line'>An execution plan has been generated and is shown below.
</span><span class='line'>Resource actions are indicated with the following symbols:
</span><span class='line'>  + create
</span><span class='line'>
</span><span class='line'>Terraform will perform the following actions:
</span><span class='line'>
</span><span class='line'>  + docker_container.container_id
</span><span class='line'>      id:               &lt;computed&gt;
</span><span class='line'>      attach:           "false"
</span><span class='line'>      bridge:           &lt;computed&gt;
</span><span class='line'>      container_logs:   &lt;computed&gt;
</span><span class='line'>      exit_code:        &lt;computed&gt;
</span><span class='line'>      gateway:          &lt;computed&gt;
</span><span class='line'>      image:            "${docker_image.image_id.latest}"
</span><span class='line'>      ip_address:       &lt;computed&gt;
</span><span class='line'>      ip_prefix_length: &lt;computed&gt;
</span><span class='line'>      log_driver:       "json-file"
</span><span class='line'>      logs:             "false"
</span><span class='line'>      must_run:         "true"
</span><span class='line'>      name:             "supermario"
</span><span class='line'>      network_data.#:   &lt;computed&gt;
</span><span class='line'>      ports.#:          "1"
</span><span class='line'>      ports.0.external: "80"
</span><span class='line'>      ports.0.internal: "8080"
</span><span class='line'>      ports.0.ip:       "0.0.0.0"
</span><span class='line'>      ports.0.protocol: "tcp"
</span><span class='line'>      restart:          "no"
</span><span class='line'>      rm:               "false"
</span><span class='line'>      start:            "true"
</span><span class='line'>
</span><span class='line'>  + docker_image.image_id
</span><span class='line'>      id:               &lt;computed&gt;
</span><span class='line'>      latest:           &lt;computed&gt;
</span><span class='line'>      name:             "pengbai/docker-supermario:latest"
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Plan: 2 to add, 0 to change, 0 to destroy.
</span><span class='line'>
</span><span class='line'>------------------------------------------------------------------------
</span><span class='line'>
</span><span class='line'>Note: You didn't specify an "-out" parameter to save this plan, so Terraform
</span><span class='line'>can't guarantee that exactly these actions will be performed if
</span><span class='line'>"terraform apply" is subsequently run.</span></code></pre></td></tr></table></div></figure>


<p><strong>D</strong>esta vez podemos ver que ambas as ações serão executadas: A imagem será baixada e o container será criado, afinal nós tínhamos removido tudo com <em>terraform destroy</em> anteriormente.</p>

<p><strong>V</strong>amos aplicar nosso código e confirmar com <em>yes</em>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ terraform apply
</span><span class='line'>
</span><span class='line'>An execution plan has been generated and is shown below.
</span><span class='line'>Resource actions are indicated with the following symbols:
</span><span class='line'>  + create
</span><span class='line'>
</span><span class='line'>Terraform will perform the following actions:
</span><span class='line'>
</span><span class='line'>  + docker_container.container_id
</span><span class='line'>      id:               &lt;computed&gt;
</span><span class='line'>      attach:           "false"
</span><span class='line'>      bridge:           &lt;computed&gt;
</span><span class='line'>      container_logs:   &lt;computed&gt;
</span><span class='line'>      exit_code:        &lt;computed&gt;
</span><span class='line'>      gateway:          &lt;computed&gt;
</span><span class='line'>      image:            "${docker_image.image_id.latest}"
</span><span class='line'>      ip_address:       &lt;computed&gt;
</span><span class='line'>      ip_prefix_length: &lt;computed&gt;
</span><span class='line'>      log_driver:       "json-file"
</span><span class='line'>      logs:             "false"
</span><span class='line'>      must_run:         "true"
</span><span class='line'>      name:             "supermario"
</span><span class='line'>      network_data.#:   &lt;computed&gt;
</span><span class='line'>      ports.#:          "1"
</span><span class='line'>      ports.0.external: "80"
</span><span class='line'>      ports.0.internal: "8080"
</span><span class='line'>      ports.0.ip:       "0.0.0.0"
</span><span class='line'>      ports.0.protocol: "tcp"
</span><span class='line'>      restart:          "no"
</span><span class='line'>      rm:               "false"
</span><span class='line'>      start:            "true"
</span><span class='line'>
</span><span class='line'>  + docker_image.image_id
</span><span class='line'>      id:               &lt;computed&gt;
</span><span class='line'>      latest:           &lt;computed&gt;
</span><span class='line'>      name:             "pengbai/docker-supermario:latest"
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Plan: 2 to add, 0 to change, 0 to destroy.
</span><span class='line'>
</span><span class='line'>Do you want to perform these actions?
</span><span class='line'>  Terraform will perform the actions described above.
</span><span class='line'>  Only 'yes' will be accepted to approve.
</span><span class='line'>
</span><span class='line'>  Enter a value: yes
</span><span class='line'>
</span><span class='line'>docker_image.image_id: Creating...
</span><span class='line'>  latest: "" =&gt; "&lt;computed&gt;"
</span><span class='line'>  name:   "" =&gt; "pengbai/docker-supermario:latest"
</span><span class='line'>docker_image.image_id: Still creating... (10s elapsed)
</span><span class='line'>docker_image.image_id: Still creating... (20s elapsed)
</span><span class='line'>docker_image.image_id: Still creating... (30s elapsed)
</span><span class='line'>docker_image.image_id: Still creating... (40s elapsed)
</span><span class='line'>docker_image.image_id: Still creating... (50s elapsed)
</span><span class='line'>docker_image.image_id: Creation complete after 59s (ID: sha256:49beaba1c5cc49d2fa424ac03a15b0e7...9c3d62pengbai/docker-supermario:latest)
</span><span class='line'>docker_container.container_id: Creating...
</span><span class='line'>  attach:           "" =&gt; "false"
</span><span class='line'>  bridge:           "" =&gt; "&lt;computed&gt;"
</span><span class='line'>  container_logs:   "" =&gt; "&lt;computed&gt;"
</span><span class='line'>  exit_code:        "" =&gt; "&lt;computed&gt;"
</span><span class='line'>  gateway:          "" =&gt; "&lt;computed&gt;"
</span><span class='line'>  image:            "" =&gt; "sha256:49beaba1c5cc49d2fa424ac03a15b0e761f637e835c1ed4d8108cc247a9c3d62"
</span><span class='line'>  ip_address:       "" =&gt; "&lt;computed&gt;"
</span><span class='line'>  ip_prefix_length: "" =&gt; "&lt;computed&gt;"
</span><span class='line'>  log_driver:       "" =&gt; "json-file"
</span><span class='line'>  logs:             "" =&gt; "false"
</span><span class='line'>  must_run:         "" =&gt; "true"
</span><span class='line'>  name:             "" =&gt; "supermario"
</span><span class='line'>  network_data.#:   "" =&gt; "&lt;computed&gt;"
</span><span class='line'>  ports.#:          "" =&gt; "1"
</span><span class='line'>  ports.0.external: "" =&gt; "80"
</span><span class='line'>  ports.0.internal: "" =&gt; "8080"
</span><span class='line'>  ports.0.ip:       "" =&gt; "0.0.0.0"
</span><span class='line'>  ports.0.protocol: "" =&gt; "tcp"
</span><span class='line'>  restart:          "" =&gt; "no"
</span><span class='line'>  rm:               "" =&gt; "false"
</span><span class='line'>  start:            "" =&gt; "true"
</span><span class='line'>docker_container.container_id: Creation complete after 0s (ID: 655604d672af8ff76c10aca4cd169a6aa284dcca17f0e0215374fb18c86660fd)
</span><span class='line'>
</span><span class='line'>Apply complete! Resources: 2 added, 0 changed, 0 destroyed.
</span><span class='line'>
</span><span class='line'>Outputs:
</span><span class='line'>
</span><span class='line'>Endereco IP = 172.17.0.2
</span><span class='line'>Nome do Container = supermario</span></code></pre></td></tr></table></div></figure>


<p><strong>R</strong>epare que tudo o que queríamos foi executado e que, ao final, recebemos duas saídas ou <em>outputs</em>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Apply complete! Resources: 2 added, 0 changed, 0 destroyed.
</span><span class='line'>
</span><span class='line'>Outputs:
</span><span class='line'>
</span><span class='line'>Endereco IP = 172.17.0.2
</span><span class='line'>Nome do Container = supermario</span></code></pre></td></tr></table></div></figure>


<p><strong>N</strong>ovamente, se você acessar em seu navegador o endereço <em>localhost:80</em>, ou utilizar os comandos <em>docker ps</em>, perceberá que sua aplicação está novamente rodando.</p>

<p><strong>N</strong>ão é complicado, certo?!</p>

<p><strong>O</strong>bviamente, isto é apenas um exemplo extremamente simplista de uso do Terraform para criar uma pequena infraestrutura como código, que em nosso caso é apenas um container.</p>

<p><strong>N</strong>o próximo post pretendo alterar um pouco este nosso código para utilizar algumas melhores práticas propostas pelo Terraform, como a utilização de variáveis e outputs em arquivos distintos, já que não utilizamos variáveis neste post.</p>

<p><strong>U</strong>m passo de cada vez, certo?!</p>

<p><strong>H</strong>appy Hacking!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/10/22/infraestrutura-como-codigo-com-terraform/">Infraestrutura Como Código Com Terraform</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2018-10-22T21:26:00-04:00" pubdate data-updated="true">Oct 22<span>nd</span>, 2018</time>
        
         | <a href="/blog/2018/10/22/infraestrutura-como-codigo-com-terraform/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="center" src="/imgs/terraform.png" title="'Terraform'" ></p>

<h2>Infraestrutura como Código (IAC &ndash; Infrastructure as Code)</h2>

<p><strong>I</strong>nfraestrutura como código &ndash; IaC (ou infrastructure as code em inglês) &ndash; é o processo de gerenciamento e provisionamento de recursos de infraestrutura através de códigos ou arquivos de configuração que descrevem o estado desejado para tal infraestrutura ou recursos de infraestrutura. A principal característica de IaC é o uso de scripts ou definições declarativas ao invés de processos manuais, mas o termo é utilizado com mais frequência para promover abordagens declarativas. Como se tratam de arquivos de código, as definições podem ser armazenadas em um sistema de controle de versões, tal como o Git.</p>

<p><strong>A</strong>bordagens IaC são comumente promovidas para computação em nuvem e, às vezes, são comercializadas como infraestrutura como serviço (infrastructure as a service, IaaS). IaC suporta IaaS, mas os dois conceitos não devem ser confundidos.</p>

<h2>IaC e DevOps</h2>

<p><strong>I</strong>aC, ou Infraestrutura como Código, é um conceito bastante ligado à filosofia DevOps, visto que com práticas de implementação de uma infraestrutura baseada em códigos declarativos podemos aproximar as equipes de Operações e Desenvolvimento, fazendo com que os desenvolvedores tornem-se mais envolvidos nas configurações de máquinas ou recursos de infraestrutura como um todo, enquanto que os profissionais de Operações se envolvem mais cedo no processo de desenvolvimento. Além disso, agora ambas as equipes podem armazenar seu código em um mesmo ambiente, como por exemplo repositórios Git.</p>

<p><strong>I</strong>nfraestrutura como código mostrou-se uma excelente solução para livrar equipes de tarefas enfadonhas do cotidiano realizadas manualmente. Além de tomarem muito tempo e serem tarefas extremamente repetitivas, os corriqueiros processos manuais estão sujeitos a erros e podem colocar as operações em risco.</p>

<h4>Algumas vantagens da utilização de IaC</h4>

<ul>
<li><p><strong>Elimina tarefas repetitivas</strong> &ndash; Se você precisa criar 3 clusters Kubernetes em seu provedor de cloud (GCP ou AWS, por exemplo), você não precisa repetir os mesmos passos 3 vezes. Escreve um bloco de código que define a criação de um cluster e poderá aplicar este mesmo código quantas vezes forem necessárias;</p></li>
<li><p><strong>Documentação simplificada</strong> &ndash; Não há necessidade de logar-se em um servidor ou provedor de cloud para tentar vasculhar tudo o que foi configurado (está tudo no código);</p></li>
<li><p><strong>Reaproveitamento</strong> &ndash; Uma vez que tudo está codificado e separado em módulos, fica fácil reaproveitar módulos e código para futuras implementações;</p></li>
<li><p><strong>Simples manutenção</strong> &ndash; Mudanças na configuração, versões, regras e demais definições podem ser implementadas e aplicadas rapidamente com pequenas alterações no código;</p></li>
<li><p><strong>Versionamento</strong> &ndash; Ao abordar nossa infraestrutura como código passamos a ter diversos benefícios já rotineiros para desenvolvedores, como por exemplo a possibilidade de gerenciar nosso código em sistemas de versionamento como o Git, de forma a facilitar o trabalho em equipes, controle de versões, mudanças, etc;</p></li>
<li><p><strong>Agilidade</strong> &ndash; Se preciso trocar a faixa de endereços IP de uma VPC ou subnet, alterar uma linha de código é muito mais rápido do que logar em uma dashboard, procurar tal recurso e alterar manualmente os valores desejados;</p></li>
<li><p><strong>Possibilidade de soluções agnósticas</strong> &ndash; Em um mundo tecnológico que muda constantemente não são raras as ocasiões em que temos de mudar completamente nossa infraestrutura, seja deixando de usar servidores físicos para passar a utilizar VMs, ou migrando de VMs locais para a nuvem, ou de VMs na nuvem para containers, etc. Independente de qual seja o cenário de mudança, uma vez que sua infraestrutura está definida em código, dependendo das ferramentas escolhidas para codificar sua infra, o mesmo código poderia ser utilizado para um ambiente VMWare, AWS, Azure, GCP, etc, com poucas modificações. (Já citei agilidade e Simples manutenção, certo?!);</p></li>
<li><p><strong>Fácil replicar</strong> &ndash; Em um ambiente não codificado ou automatizado, geralmente repetimos as mesmas configurações para criarmos ambientes distintos como Produção, Teste, Desenvolvimento, etc. Uma vez que sua infra está codificada, você aplica o mesmo código para criar quantos ambientes desejar;</p></li>
<li><p><strong>Recuperação de Desastres ou Disaster Recovery</strong> &ndash; Desastres acontecem. Imagine um problema grande em sua infraestrutura. Em um cenário de virtualização, imagine que seu host VMWare simplesmente parou de funcionar pois seu disco queimou. Ou que o storage onde se encontravam as suas VMs simplesmente foi destruído. Ou, em um ambiente de cloud, imagine que sua senha de administrador da nuvem vazou e seu ambiente foi completamente excluído. Ou mesmo que o próprio data center ou região na qual se encontra a sua infra estrutura teve algum problema sério e toda a sua infra caiu. Claro, as boas práticas já pregam há muito tempo que sempre devemos ter backups de todos os servidores e sistemas, mas backups nada mais são do que arquivos. E a infraestrutura de fato? Você precisa ter uma infraestrutura ativa antes de conseguir restaurar backups, certo? Rede, firewall, VPCs, Clusters, Servidores, etc.. Se você possui toda a sua infraestrutura em código, recuperar tudo isso é tão simples quanto executar um único comando.</p></li>
<li><p><strong>Planejamento (plan) e Testes</strong> &ndash; Práticas como planejamento e testes fazem parte (ou ao menos deveríam fazer) da rotina de praticamente qualquer desenvolvedor. Profissionais de infraestrutura sempre tiveram uma desvantagem em relação a isso, pois era complicado fazer testes de infraestrutura. Teste basicamente significava instalar exatamente a mesma infraestrutura em um ambiente isolado para testes. Ainda possível, porém pouco confiável e com altas chances de falhas, pois, por ser um processo manual e lento, não há qualquer garantia de que todos os mesmos passos serão executados no ambiente de produção tal como foram executados no ambiente de teste. Com infraestrutura como código, fica fácil utilizar-se das mesmas técnicas de planejamento e testes automatizados há muito utilizadas por desenvolvedores. Agora você consegue executar testes no código de sua infraestrutura que, literalmente, irão avaliar cada bloco de seu código e simular a execução de cada expressão ou descrição, dando-lhe assim uma visão geral sobre o que acontecerá, o que funcionará e o que falhará, garantindo uma integradade fiel entre teste e implantação em produção ou demais ambientes.</p></li>
</ul>


<p><strong>L</strong>indo, não? Lembro de meus tempos de faculdade, quando costumava dizer a meus colegas que todos os profissionais de TI deveríam saber programar, independente de desejarem ou não trabalhar com programação. Na ocasião, em meados de 2006, a maioria deles dizia que isso era loucura. &ldquo;Porque aprender a programar se vou trabalhar com infraestrutura?&rdquo; Bom, tudo o que posso dizer hoje é: Bem vindos à era DevOps.</p>

<p><strong>Q</strong>uando falamos em infraestrutura como código, existem diversas ferramentas que trabalham em cima deste conceito, e muitas delas atuam juntas para englobar soluções mais completas, mas uma de minhas favoritas é o <a href="https://www.terraform.io">Terraform</a>, da <a href="https://www.hashicorp.com/">Hashicorp</a>.</p>

<h2>Escolha da ferramenta ideal para IAC</h2>

<p><strong>C</strong>om uma simples busca no Google pelo termo &ldquo;ïnfraestrutura como código&rdquo; ou &ldquo;IAC&rdquo;, será extremamente fácil encontrar diversas ferramentas, dentre as mais populares estão Chef, Puppet, Ansible, SaltStack, Terraform, CloudFormation, etc.</p>

<p><strong>U</strong>m problema comum para quem inicia no mundo DevOps ou simplesmente deseja começar a utilizar infraestrutura como código é justamente a escolha. Qual a melhor ferramenta? Qual devo utilizar?</p>

<p><strong>E</strong>esta é uma dificuldade comum e inerante ao fato de se ter muitas opções. Se em uma sorveteria você só possui os sabores chocolate e baunilha, é extremamente simples optar por um, outro ou nenhum dos dois. No entanto, em uma sorveteria com 50 sabores, você provavelmente perderá alguns minutos apenas lendo todas as opções, do contrário irá apostar na sorte e escolher o primeiro que lhe parecer apetitoso, correndo o risco de descartar algum que não chegou a ver, mas que poderia ser muito melhor e refrescante para um dia quente como os do nordeste cearense.</p>

<p><strong>O</strong> mais importante é sempre realizar uma pesquisa sobre pontos fortes e fracos de cada uma delas antes de tomar uma decisão, tendo em mente alguns aspectos:</p>

<ul>
<li><p>A escolha não deve (ou não deveria) ser puramente pessoal. A melhor ferramenta dificilmente será a que você gostou mais de utilizar. A melhor ferramenta será a que melhor atende as necessidades do seu projeto ou negócio;</p></li>
<li><p>A análise deve ser feita em diversos aspectos, e não apenas em um ou dois. Supondo que você pesquise por exemplo quais possuem mais módulos gratuitos e quais delas possuem uma comunidade mais ativa na internet para dúvidas, mas esqueceu de ponderar o preço para ter acesso a suporte corporativo, você pode ter feito uma boa ou uma má escolha. Em caso de ser uma pequena empresa, com prazos relativamente longos para entregas de projetos e maior flexibilidade em termos de tempo fora do ar (downtime), o suporte corporativo pode não ser um fator decisivo. No entanto, em uma empresa de ambiente mais crítico, como um banco, demais sistemas financeiros, governamentais, etc., o suporte corporativo se torna um fator mais importante, portanto escolher uma ferramenta sem ponderar o valor de seu suporte corporativo acaba sendo um tiro no pé, o que reforça a ideia de que sempre devemos avaliar o máximo de aspectos possíveis e relevantes ao nosso projeto ou ambiente;</p></li>
<li><p>Outro fator fundamental e, em meu ver o mais importante, é entender que não necessariamente a escolha será exclusiva. Imagine que você precisa montar uma mesa que veio toda desmontada: tábuas, parafusos, gavetas, etc. Você tem algumas ferramentas a disposição, como chave de fendas, martelo, régua, serra, furadeira, etc. Você pode ser uma espécie de rambo e gostar de resolver as coisas com uma ferramenta só e, sinceramente, você pode até ser capaz de conseguir montar a mesa inteira apenas utilizando o martelo, parabéns por isso. Mas será que essa é a forma mais eficiente de resolver o problema? Será que não seria mais rápido e organizado utilizando um martelo e uma chave de fendas? Afinal, temos parafusos também, certo?!</p></li>
</ul>


<p><strong>C</strong>onforme descrito acima, o ideal é sempre avaliar o projeto ou ambiente no qual se irá trabalhar, sem a necessidade de escolher apenas uma ferramenta.</p>

<p><strong>S</strong>im, Chef, Puppet e Ansible são ferramentas de Infraestrutura como Código, no entanto elas possuem tarefas mais específicas, nas quais possuem mais desempenho, como por exemplo o gerenciamento de configurações, para não listar todas as suas funções.</p>

<p><strong>E</strong>, claro, o CloudFormation é uma excelente ferramenta da Amazon para criação de infraestrutura como código, no entanto ela fica restrita ao ambiente de cloud da Amazon, o AWS. E se meu projeto estiver utilizando VMs em um ambiente VMWare? Ou se eu utilizar Google Cloud? Ou mesmo um ambiente mais heterogênio, com VMWare, Google Cloud e Amazon AWS? O CloudCloudFormation não seria a melhor opção, por ser restrito ao ambiente AWS.</p>

<p><strong>S</strong>empre fui a favor de utilizar as ferramentas corretas para cada tarefa em específico, portanto porque utilizar apenas uma se tenho outras disponíveis?</p>

<p><strong>O</strong> <a href="https://www.terraform.io">Terraform</a>, por outro lado, é específico para a criação da infraestrutura base, se saindo muito melhor do que Chef, Ansible ou Puppet nesta tarefa, mas nada impede (e eu encorajo e o faço) que você utilize Chef, Puppet ou Ansible, para gerenciar configurações, bootstraping ou deployments na infraestrutura criada pelo Terraform.</p>

<p><strong>A</strong>lém do mais, diferente do CloudFormation, o Terraform é uma solução agnóstica, permitindo-lhe criar infraestrutura em praticamente qualquer ambiente, seja ele em Cloud (Amazon AWS, Microsoft Azure, Google GCP, IBM Cloud, Digital Ocean, etc.), ambiente virtualizado, local ou em Data Centers (VMWare, Xen, Virtual Box, etc.), Docker, Kubernetes, além de recursos diversos de infraestrutura e softwares, tais como Redes (CloudFlare, DNS, DNSimple, F5 BIG-IP, Palo Alto Networks,etc.), Bancos de Dados (InfluxDB, MySQl ou PostgreSQL), dentre muitas outras coisas.</p>

<h2>Terraform</h2>

<p><strong>O</strong> Terraform, da Hashicorp, lhe permite criar, alterar e melhorar sua infraestrutura de forma segura e previsível. É uma ferramenta Open Source que codifica APIs em arquivos de configuração declarativos que podem ser compartilhados entre membros de um time, tratados como código, editados, revisados e versionados.</p>

<p><img class="center" src="/imgs/terraform-flow.png" title="'Terraform Flow'" ></p>

<p><strong>A</strong> imagem acima descreve bem o fluxo básico da utilização de Terraform para codificar sua infraestrutura, na qual o fluxo mais simplista é:</p>

<ul>
<li>Escrever o código de sua infraestrutura;</li>
<li>Planejar a execução do seu código, de forma que você receba informações antecipadamente de tudo o que acontecerá quando você aplicar o seu código;</li>
<li>Crie uma infraestrutura reproduzível ao aplicar seu código.</li>
</ul>


<p><strong>A</strong>pesar de este ser o fluxo mais simplista, com a utilização de infraestrutura como código você pode melhorar seu fluxo inserindo colaboração e compartilhamento, armazenando e gereciando seu código em um repositório git, por exemplo, além de ter assim um registro completo das mudanças e evoluções de sua infraestrutura, facilitando a automação em fluxos mais complexos, como por exemplo em pipelines de Integração Contínua.</p>

<p><strong>O</strong> Terraform funciona basicamente através de recursos, ou resources, que definem o tipo de infraestrutura você estará criando bem como seus atributos. Além disso, conforme dito anteriormente, o Terraform também pode ser utilizado em paralelo com diversas outras ferramentas de automação em forma de provedores, ou providers, como Puppet, Chef, Ansible, etc.</p>

<p><strong>P</strong>or estarmos tentando aplicar para a infraestrutura um conceito que seja mais próximo do que já era utilizado por desenvolvedores há muito tempo, o Terraform possui também uma abordagem que lhe permite reaproveitamento de código, através de módulos. Existem diversos módulos criados e disponibilizados gratuitamente, mas você pode também criar seus próprios módulos de forma a melhor organizar e reaproveitar seu próprio código em diversos projetos.</p>

<p><strong>A</strong>rquivos de configuração descrevem ao Terraform os componentes necessários para rodar uma única aplicação que representa todo o seu datacenter. O Terraform gera um plano de execução descrevendo o que fará para alcançar o estado desejado, e em seguida, caso aprovado, o executará para criar a infraestrutura desejada. Conforme a configuração muda, o Terraform será capaz de determinar o que mudou e criará planos de execução incrementais que podem ser aplicados.</p>

<p><strong>V</strong>ejamos o seguinte diagrama que descreve uma simples infraesturura. Imaginemos que esta é a infraestrutura que queremos rodar em nossa conta no Google Cloud para termos um site de e-commerce:</p>

<p><img class="center" src="/imgs/diagrama-ecommerce.png" title="'Kalib Ecommerce'" ></p>

<p>O diagrama acima possui diversos elementos:</p>

<ol>
<li>Uma organização no Google Cloud chamada Kalib Avante;</li>
<li>Um diretório ou Folder (como chamado no Google Cloud) chamado Projetos;</li>
<li>Um projeto chamado E-Commerce;</li>
<li>Um projeto chamado Zebra Feliz;</li>
<li>Dentro do projeto E-Commerce temos dois ambientes: Produção e Teste</li>
<li>Repare que o projeto Zebra Feliz está incompleto e sem ambientes distintos, como Produção, teste, etc. Bom, trata-se de um projeto piloto ainda em desenvolvimento e planejamento, portanto os recursos não foram ainda criados por completo. Mas o Terraform nos permite incrementar recursos quando necessário, certo? Portanto, sem problemas com isto por enquanto.</li>
</ol>


<p><strong>E</strong>sta é a estrutura básica, já em termos de recursos temos Firewalls, clusters kubernetes com Nodes, buckets de storage para conservar o status ou state do Terraform e por consequência de sua infraestrutura, Discos persistentes, Container Registry (repositório de imagens Docker), VPCs, Load Balancer, VMs, etc.</p>

<p><strong>C</strong>aso esteja se perguntando, sim o Terraform lhe permite criar esta infraestrutura inteira, bem como outras bem mais complexas, com mais projetos, mais ambientes, mais recursos, etc.</p>

<p><strong>D</strong>esta forma podemos ter um código terraform dividido em alguns módulos, armazenado em um repositório Git, por exemplo, e criar toda essa infraestrutura, desde a Organização vazia, ao diretório de projetos, aos 2 projetos em si, buckets, clusters kubernetes, DNS, IAM, load balancer, VMs por trás do Load Balancer, etc. Tudo isto com um único comando:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>terraform apply</span></code></pre></td></tr></table></div></figure>


<p><strong>L</strong>embrando um pouco do que falamos lá em cima, sobre ser simples reproduzir, ou se recuperar de desastres&hellip; imagine que uma região inteira caiu no Google, onde temos nossa infraestrutura. Sim, eu sei que isso é extremamente raro, mas vamos imaginar os cenários mais absurdos e raros também. Imagine que perdi toda a minha infraestrutura. Imagine ter que recriar tudo isso (projetos, diretórios, storages, DNS, IAM, clusters, Load Balancer, VMs, etc, etc..) manualmente..? Demoraria bastante, certo?! Mas, como fomos espertos e criamos tudo via terraform, um simples <strong>terraform apply</strong> irá criar tudo novamente para nós, exatamente como era antes.</p>

<p><strong>O</strong> mesmo se dá caso precisemos recriar toda essa mesma infraestrutura em uma nova região do Google, ou caso queiramos destruir nossa infra e recriá-la em outra zona, por algum motivo.</p>

<p><strong>A</strong>qui estamos lidando apenas com a Infraestrutura pois, conforme dito antes, o Terraform é excelente para criar a infraestrutura, mas o ideal ainda é utilizar outros softwares para provisionamento e deployment. Por exemplo, uma vez que temos nossa infraestrutura inteira criada, podemos começar a provisionar os sistemas e softwares através de outras ferrmentas, como Helm (para deployment dentro dos clusters Kubernetes), Chef, Puppet, Ansible, etc.</p>

<p><strong>A</strong> ideia deste post é apenas dar uma introdução teórica, uma ideia de como infraestrutura como código funciona, e de como o Terraform é capaz de fazer tudo isso de forma segura e robusta. (Embora eu já veja uma enorme barra de rolagem aqui ao lado e sei que lhe fiz ler bastante, supondo que leu até aqui. :p)</p>

<p><strong>E</strong>m meu próximo post pretendo fazer uma abordagem mais prática e com mão na massa, utilizando de fato o Terraform para criar uma simples infraestrutura via código.</p>

<p><strong>H</strong>appy Hacking!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/08/11/criando-uma-imagem-aws-ec2-com-packer-e-puppet/">Criando Uma Imagem AWS EC2 Com Packer E Puppet</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2018-08-11T09:12:00-04:00" pubdate data-updated="true">Aug 11<span>th</span>, 2018</time>
        
         | <a href="/blog/2018/08/11/criando-uma-imagem-aws-ec2-com-packer-e-puppet/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="center" src="/imgs/packer_puppet_aws_bash.png" title="'Packer_Puppet_Bash_AWS'" ></p>

<h2>Packer, Puppet, Bash e AWS</h2>

<p><strong>A</strong> plataforma AWS da Amazon é atualmente uma das maiores e mais populares quando o assunto é Cloud e automação em nuvem, permitindo o uso de soluções de infra estrutura completamente na nuvem, sem a necessidade de termos Hardware físico, otimizando custos e nos dando mais flexibilidade.</p>

<p><strong>A</strong> própria plataforma nos disponibiliza diversos recursos para facilitar a implementação de nossas soluções e tornar nossas tarefas rotineiras mais simples. Por exemplo, para a criação de VMs, ou instâncias, no AWS de forma mais rápida, podemos utilizar uma imagem previamente criada, de forma que possamos evitar alguns passos e configurações repetitivas.</p>

<p><strong>U</strong>ma vez que eu identifico uma necessidade para minha aplicação e sei que preciso de uma máquina virtual com configurações e aplicações específicas para poder rodar minha aplicação, eu posso criar uma imagem com todos estes pré-requisitos de forma que ao resolver criar uma nova VM, eu não precise realizar todos estes passos manualmente. Além de evitar trabalho repetitivo, nos garante uma maior flexibilidade ao ter nossa infraestrutura como código, de forma que podemos literalmente ter as instruções que compõem nossa infraestrutura em um repositório Git, por exemplo, além de nos permitir realizar alterações nesta imagem também de forma simples e rápida para a geração de novas imagens de instâncias com as nossas alterações em poucos segundos ou minutos, dependendo da quantidade de alterações envolvdidas.</p>

<p><strong>S</strong>e você ainda não faz ideia de o que seja o Packer ou o que ele é capaz de fazer, sugiro que volte uma casa e leia meu <a href="https://blog.marcelocavalcante.net/blog/2018/07/30/automatizando-a-criacao-de-imagens-com-packer/">post anterior</a>, onde explico o que é o Packer e apresento um simples exemplo de seu uso para a criação de imagens para o Docker.</p>

<p><strong>O</strong> intuito deste post é mostrar como podemos estruturar um simples código para que possamos criar uma imagem no AWS que poderá ser utilizada posteriormente para a criação de instâncias. Esta imagem será criada através do Packer e, para incrementar ainda mais nossa imagem, utilizaremos o recurso de provisioners (ou provisionadores/provedores) disponível no Packer. Utilizaremos dois provisioners como recursos externos para o provisionamento e configuração de nossa imagem, sendo eles bash script e <a href="https://puppet.com/">Puppet</a>.</p>

<h2>AWS</h2>

<p><strong>U</strong>ma vez que estou assumindo que você já possui o Packer instalado, bem como que você já possui uma ideia de como ele funciona, vamos iniciar pelo AWS. (Ainda não possui o Packer e não sabe o que ele faz? Novamente, <a href="https://blog.marcelocavalcante.net/blog/2018/07/30/automatizando-a-criacao-de-imagens-com-packer/">volte uma casa</a>.)</p>

<p><strong>O</strong> primeiro pré-requisito para este post/tutorial é uma conta no AWS. Caso você não possua uma e queira repetir os passos aqui descritos, siga e crie uma. Lembrando que o AWS lhe dá uma série de recursos que podem ser utilizados gratuitamente no que eles chamam de &ldquo;Free Tier&rdquo;. Uma vez que utilizaremos apenas recursos simples aqui, você não deverá ser cobrado por nada ao seguir os exemplos deste post. O ideal é que você exclua os recursos ou encerre sua conta após o término deste exercício para evitar ser cobrado por algo. Caso não o faça e resolva continuar testando algumas coisas no AWS, você pode ser cobrado em alguns centavos ou reais, dependendo de o que resolva testar e por quanto. (Sua responsabilidade, claro.)</p>

<p><strong>A</strong> conta no AWS pode ser criada aqui: <a href="https://aws.amazon.com/free/">https://aws.amazon.com/free/</a></p>

<p><strong>U</strong>ma vez que a conta no AWS esteja criada e pronta para uso, o primeiro passo será de fato conseguir uma chave para que possamos nos comunicar com o AWS via CLI através de uma API. Durante a criação de nosso código com o Packer precisaremos utilizar esta chave de acesso, portanto vá em frente e crie uma através deste link: <a href="https://console.aws.amazon.com/iam/home?#security_credential">https://console.aws.amazon.com/iam/home?#security_credential</a></p>

<p><strong>C</strong>lique na opção Access Keys, ou Chaves de Acesso, e crie uma nova. <strong>É extremamente importante</strong> que você esteja atento neste momento, pois ele apenas lhe mostrará o ID e senha para a chave uma única vez, portanto esteja pronto para copiar e salvar ambos os valores. Será algo similar a isto:</p>

<p><img class="center" src="/imgs/aws_key.png" title="'AWS Key'" ></p>

<p><strong>É</strong> claro que eu já excluí essa chave&hellip; :p Não perca seu tempo&hellip; >]</p>

<p><strong>U</strong>ma vez que você tenha salvo ambos os valores, vamos tratar da identificação/autenticação com o AWS.</p>

<p><strong>O</strong> mecanismo padrão do Packer de autenticação neste caso seria através de duas variáveis em nosso arquivo json:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "builders": [{
</span><span class='line'>    "type": "amazon-ebs",
</span><span class='line'>    "access_key": "SUA ACCESS KEY AQUI",
</span><span class='line'>    "secret_key": "SUA SECRET ACCESS KEY AQUI",
</span><span class='line'>... ... ...</span></code></pre></td></tr></table></div></figure>


<p><strong>E</strong>mbora seja a forma mais simples, não a utilizaremos. Fica claro que não é uma forma muito segura, certo?! Quando se pensa em infraestrutura como código, um dos principais objetivos é podermos versionar e hospedar nosso código em um repositório Git, por exemplo. Ter nossa chave como parte do código não é nada seguro, especialmente se vamos compartilhar este código em um repositório Git.</p>

<p><strong>A</strong> forma mais simples de lidarmos com isso é salvando nossa chave e senha como variáveis de ambiente e, em nosso arquivo json, importarmos estas variáveis de ambiente diretamente.</p>

<p><strong>E</strong>m Linux ou OS X, digite o seguinte em um terminal ou console:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export AWS_ACCESS_KEY_ID=SUA ACCESS KEY AQUI
</span><span class='line'>$ export AWS_SECRET_ACCESS_KEY=SUA SECRET ACCESS KEY AQUI</span></code></pre></td></tr></table></div></figure>


<p><strong>C</strong>ertifique-se de que os valores foram definidos corretamente:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo $AWS_ACCESS_KEY_ID
</span><span class='line'>$ echo $AWS_SECRET_ACCESS_KEY</span></code></pre></td></tr></table></div></figure>


<p>Por hora isso é tudo de que precisaremos para o AWS.</p>

<h2>Packer</h2>

<p><strong>H</strong>ora de começarmos a escrever nosso código que será utilizado pelo Packer para a criação de nossa imagem.</p>

<p><strong>D</strong>esta vez estaremos criando uma imagem EC2 para o AWS, portanto alguns provisioners e parâmetros serão diferentes dos utilizados no <a href="https://blog.marcelocavalcante.net/blog/2018/07/30/automatizando-a-criacao-de-imagens-com-packer/">post anterior</a>, onde criamos uma imagem para o Docker.</p>

<p><strong>C</strong>omecemos criando um arquivo json vazio. Chamarei meu arquivo de <em>ubuntuaws.json</em>.</p>

<p><strong>A</strong> primeira coisa que faremos é incluir as credenciais de nossa conta no AWS. Como criamos duas variáveis de ambiente em nosso host, chamadas <em>AWS_ACCESS_KEY_ID</em> e <em>AWS_SECRET_ACCESS_KEY</em>, invocaremos estas duas variáveis da seguinte forma no início de nosso arquivo: <em>env `AWS_ACCESS_KEY_ID`</em>, etc&hellip; Vamos ao código.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "variables": {
</span><span class='line'>    "aws_access_key": "{{env `AWS_ACCESS_KEY_ID`}}",
</span><span class='line'>    "aws_secret_key": "{{env `AWS_SECRET_ACCESS_KEY`}}",
</span><span class='line'>    "region": "us-east-1"
</span><span class='line'>  },
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>N</strong>ormalmente uma varíavel poderia ser declarada apenas com <em>&ldquo;aws_access_key&rdquo;: &ldquo;sua_chave&rdquo;</em>, conforme fizemos com a variável <em>region</em> acima, no entanto, por questões de segurança, não queremos ter nossa chave exposta no código, certo?! Portanto, estamos trazendo os valores diretamente das variáveis de ambiente que criamos. A utilização do parâmetro <em>env</em> é o que indica ao Packer que ele deverá buscar estas variáveis em nosso <em>env</em> (environment).</p>

<p><strong>É</strong> importante lembrar que o aws possui datacenters e recursos em diversas regiões do mundo. Você não precisa obrigatoriamente utilizar a região <em>us-east-1</em>. Optei por utilizar esta região em meu código pelo fato de eu morar em Toronto, o que faz desta região uma boa escolha para meus recursos de nuvem por conta da proximidade (menor delay).</p>

<p><strong>S</strong>e você está no Brasil, provavelmente a melhor opção seja <em>sa-east-1</em>, a qual se encontra em São Paulo. De qualquer forma, você pode verificar a lista de regiões disponíveis no AWS através <a href="https://docs.aws.amazon.com/pt_br/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">deste link</a>.</p>

<p><strong>A</strong>té então nosso código está simples e não faz basicamente nada além de definir as duas variáves para nossa autenticação, mas ainda assim é importante termos certeza de que não cometemos nenhum erro de sintaxe:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ packer validate ubuntuaws.json
</span><span class='line'>Error initializing core: 1 error(s) occurred:
</span><span class='line'>
</span><span class='line'>* at least one builder must be defined</span></code></pre></td></tr></table></div></figure>


<p><strong>P</strong>or enquanto ignore este erro, nossa sintaxe esta correta. O Packer apenas está nos dizendo que não conseguiu iniciar o projeto pois ao menos um builder deve ser definido e, até então, nós não definimos nenhum. Este será o nosso próximo passo. Desta vez, ao invés de utilizarmos um builder do tipo Docker, utilizaremos um do tipo <em>amazon-ebs</em>. Começaremos inserindo uma vírgula ao fim do bloco de variáveis e nosso código agora ficará da seguinte forma:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "variables": {
</span><span class='line'>    "aws_access_key": "{{env `AWS_ACCESS_KEY_ID`}}",
</span><span class='line'>    "aws_secret_key": "{{env `AWS_SECRET_ACCESS_KEY`}}",
</span><span class='line'>    "region": "us-east-1"
</span><span class='line'>  },
</span><span class='line'>"builders": [{
</span><span class='line'>    "type": "amazon-ebs",
</span><span class='line'>    "access_key": "{{user `aws_access_key`}}",
</span><span class='line'>    "secret_key": "{{user `aws_secret_key`}}",
</span><span class='line'>    "region": "{{user `region`}},
</span><span class='line'>    "source_ami_filter": {
</span><span class='line'>      "filters": {
</span><span class='line'>      "virtualization-type": "hvm",
</span><span class='line'>      "name": "ubuntu/images/*ubuntu-xenial-16.04-amd64-server-*",
</span><span class='line'>      "root-device-type": "ebs"
</span><span class='line'>      },
</span><span class='line'>      "owners": ["099720109477"],
</span><span class='line'>      "most_recent": true
</span><span class='line'>    },
</span><span class='line'>    "instance_type": "t2.micro",
</span><span class='line'>    "ssh_username": "ubuntu",
</span><span class='line'>    "ami_name": "packer-example {{timestamp}}"
</span><span class='line'>  }]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>O</strong> que temos agora:</p>

<p><em>builders:</em> Inciamos nosso bloco de builders com as intruções ou parâmetros que definirão as especificações mais básicas para a criação de nossa imagem no AWS.</p>

<p><em>type:</em> Aqui indicamos o tipo de builders que utilizaremos. No caso do EC2 do AWS, o tipo se chama <em>amazon-ebs</em>. Basicamente este builder irá utilizar uma imagem previamente existente, como as fornecidas por padrão pela Amazon, para criar uma nova imagem que poderá ser futuramente utilizada para provisionar suas instâncias EC2 com EBS (Elastic Block Storage).</p>

<p><em>access_key:</em> e <em>secret_key:</em> Aqui apenas indicamos que queremos utilizar o valor das variáveis que criamos mais acima. É importante lembrar que quando as definimos, utilizamos <em>env</em>, para indicar que a origem delas estava em nossas variáveis de ambiente. Agora estamos utilizando <em>user</em> para indicar que são variáveis criadas em nosso código mesmo (usuário).</p>

<p><em>region:</em> Novamente, assim como com as chaves, anteriormente nós declaramos esta variável e agora estamos inserindo-a em nosso código como uma variável de usuário <em>user</em>.</p>

<p><em>source_ami_filter:</em> Neste bloco iremos passar as informações básicas sobre a imagem que será utilizada como origem ou <em>source</em> base para nossa imagem. Lembrando novamente de que utilizaremos uma AMI (Amazon Machine Image) já existente por padrão no AWS.</p>

<p><em>filters:</em> Utilizaremos alguns filtros para definir a nossa imagem <em>source</em>.</p>

<p><em>virtualization_type:</em> Nosso primeiro parâmetro de filtro será o tipo de virtualização que desejamos utilizar. Se você já utilizou AWS antes, provavelmente reparou que você possui algumas formas de virtualização disponíveis, como HVM e PV. Utilizaremos HVM em nosso código.</p>

<p><em>name:</em> Aqui indicamos o nome da imagem <em>source</em> que queremos utilizar como base de nossa imagem. Como a Canonical vive atualizando suas imagens no marketplace do AWS, não utilizaremos um nome exato aqui, pois correríamos o risco de esta imagem ter sido descontinuada ou mesmo de estar desatualizada quando você estiver lendo e executando este tutorial, portanto utilizaremos um coringa (asterísco) e indicaremos um parâmetro extra para dizer que queremos utilizar a mais recente. Para nome, utilizaremos apenas: <em>ubuntu/images/*ubuntu-xenial-16.04-amd64-server-*</em> onde o asterísco do final indica que não nos importa o final do nome, e qualquer coisa será válida.</p>

<p><em>root-device-type:</em> Indicamos <em>ebs</em> como tipo de storage para nossa imagem e tipo de instância.</p>

<p><em>owners:</em> Indicamos o dono da imagem. Na página do AWS, cada imagem é vinculada a um dono, conforme imagem abaixo:</p>

<p><img class="center" src="/imgs/aws_ubuntu_ami.png" title="'AWS Ubuntu AMI'" ></p>

<p><em>most_recent:</em> Este é o parâmetro que, quando definido como <em>true</em>, fará com que seja utilizada a imagem mais recente que atenda aos demais filtros utilizados para a imagem.</p>

<p><em>instance_type:</em> Indica o tipo de instância que será utilizada no AWS. O AWS possui dezenas de categorias de instâncias, onde cada categoria ou tipo possui uma quantidade diferente de memória, CPU, etc.</p>

<p><em>ami_name:</em> Finalmente, aqui indicamos o nome que queremos atribuir à nossa imagem ao final da criação da mesma.</p>

<p><strong>A</strong>gora que possuímos um código mais completo e que realmente conseguirá fazer algo, vamos validar o código e executá-lo em seguida para criarmos nossa primeira imagem no AWS.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ packer validate ubuntuaws.json
</span><span class='line'>Template validated successfully.</span></code></pre></td></tr></table></div></figure>


<p><strong>C</strong>ódigo validado e sem erros.</p>

<p><strong>É</strong> importante entender o que realmente acontece durante a criação de uma imagem. O Packer não tem como executar as instruções e rodar o que queremos para criar a imagem de forma estática e mágica, portanto o que vai acontecer na verdade será o seguinte:</p>

<ol>
<li>Primeiramente o Packer irá buscar a imagem que definimos que será utilizada como fonte;</li>
<li>O packer irá criar literalmente uma instância no AWS utilizando as propriedades que definimos em nosso código para executar nossas instruções e garantir que tudo funcionará. Uma vez que todas as instruções sejam realizadas com sucesso, ele irá desligar e remover esta instância ou máquina virtual e irá salvar a imagem gerada;</li>
</ol>


<p><strong>S</strong>e durante a execução do Packer build você verificar o painel de instâncias EC2 no AWS, ficará claro que o Packer cria uma instância temporária durante a criação da imagem.</p>

<p><strong>H</strong>ora do build:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ packer build ubuntuaws.json
</span><span class='line'>amazon-ebs output will be in this color.
</span><span class='line'>
</span><span class='line'>==&gt; amazon-ebs: Prevalidating AMI Name: packer-example 1534022746
</span><span class='line'>    amazon-ebs: Found Image ID: ami-5c150e23
</span><span class='line'>==&gt; amazon-ebs: Creating temporary keypair: packer_5b6f545a-8955-2f4f-b66a-8fd752d75bee
</span><span class='line'>==&gt; amazon-ebs: Creating temporary security group for this instance: packer_5b6f545c-0f04-553a-7944-a70d081be39d
</span><span class='line'>==&gt; amazon-ebs: Authorizing access to port 22 from 0.0.0.0/0 in the temporary security group...
</span><span class='line'>==&gt; amazon-ebs: Launching a source AWS instance...
</span><span class='line'>==&gt; amazon-ebs: Adding tags to source instance
</span><span class='line'>    amazon-ebs: Adding tag: "Name": "Packer Builder"
</span><span class='line'>    amazon-ebs: Instance ID: i-0ef4a6036aebd0d56
</span><span class='line'>==&gt; amazon-ebs: Waiting for instance (i-0ef4a6036aebd0d56) to become ready...
</span><span class='line'>==&gt; amazon-ebs: Waiting for SSH to become available...
</span><span class='line'>==&gt; amazon-ebs: Connected to SSH!
</span><span class='line'>==&gt; amazon-ebs: Stopping the source instance...
</span><span class='line'>    amazon-ebs: Stopping instance, attempt 1
</span><span class='line'>==&gt; amazon-ebs: Waiting for the instance to stop...
</span><span class='line'>==&gt; amazon-ebs: Creating the AMI: packer-example 1534022746
</span><span class='line'>    amazon-ebs: AMI: ami-0bbd7494d2e6cee71
</span><span class='line'>==&gt; amazon-ebs: Waiting for AMI to become ready...
</span><span class='line'>==&gt; amazon-ebs: Terminating the source AWS instance...
</span><span class='line'>==&gt; amazon-ebs: Cleaning up any extra volumes...
</span><span class='line'>==&gt; amazon-ebs: No volumes to clean up, skipping
</span><span class='line'>==&gt; amazon-ebs: Deleting temporary security group...
</span><span class='line'>==&gt; amazon-ebs: Deleting temporary keypair...
</span><span class='line'>Build 'amazon-ebs' finished.
</span><span class='line'>
</span><span class='line'>==&gt; Builds finished. The artifacts of successful builds are:
</span><span class='line'>--&gt; amazon-ebs: AMIs were created:
</span><span class='line'>us-east-1: ami-0bbd7494d2e6cee71</span></code></pre></td></tr></table></div></figure>


<p><strong>V</strong>erificando em minha interface de instâncias da região que escolhi (us-east-1) posso ver que existe uma instância que foi criada mas que já foi terminada ou deletada. Esta é a instância que o Packer criou automaticamente para dar início à criação de nossa imagem:</p>

<p><img class="center" src="/imgs/packer_aws_instance1.png" title="'Packer Instance'" ></p>

<p><strong>D</strong>a mesma forma, se formos na interface de imagens (AMI), veremos a nossa imagem recém criada:</p>

<p><img class="center" src="/imgs/packer_aws_image1.png" title="'Packer Image'" ></p>

<p><strong>D</strong>e certa forma não fizemos nada aqui, visto que utilizamos uma imagem base do Ubuntu com o Packer e salvamos uma nova imagem sem mudar absolutamente nada neste Ubuntu, portanto basicamente criamos apenas uma cópia da imagem original. Nada empolgante&hellip;</p>

<p><strong>V</strong>amos incrementar um pouco nossa imagem realizando mudanças em nosso Ubuntu. De nada nos valeria criar uma imagem se ela não tiver nenhuma customização, certo?!</p>

<p><strong>C</strong>omeçaremos criando um simples shell script chamado <em>setup.sh</em> com o seguinte conteúdo:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>
</span><span class='line'>sudo apt-get update
</span><span class='line'>
</span><span class='line'>sudo apt-get upgrade -y
</span><span class='line'>
</span><span class='line'>sudo apt-get install puppet -y</span></code></pre></td></tr></table></div></figure>


<p><strong>T</strong>rata-se de um simples script que basicamente irá atualizar o sistema operacional e em seguida instalar o Puppet no mesmo.</p>

<p><strong>V</strong>oltando ao nosso arquivo ubuntuaws.json, vamos incluir um bloco de código <em>provisioner</em> ou provisionador. Existem diversos tipos de provisioners, mas para este momento utilizaremos apenas um, chamado <em>shell</em> pois desejamos executar um shell script. Nosso código agora estará assim:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "variables": {
</span><span class='line'>    "aws_access_key": "{{env `AWS_ACCESS_KEY_ID`}}",
</span><span class='line'>    "aws_secret_key": "{{env `AWS_SECRET_ACCESS_KEY`}}",
</span><span class='line'>    "region": "us-east-1"
</span><span class='line'>  },
</span><span class='line'>  "builders": [{
</span><span class='line'>    "type": "amazon-ebs",
</span><span class='line'>    "access_key": "{{user `aws_access_key`}}",
</span><span class='line'>    "secret_key": "{{user `aws_secret_key`}}",
</span><span class='line'>    "region": "{{user `region`}},
</span><span class='line'>    "source_ami_filter": {
</span><span class='line'>      "filters": {
</span><span class='line'>      "virtualization-type": "hvm",
</span><span class='line'>      "name": "ubuntu/images/*ubuntu-xenial-16.04-amd64-server-*",
</span><span class='line'>      "root-device-type": "ebs"
</span><span class='line'>      },
</span><span class='line'>      "owners": ["099720109477"],
</span><span class='line'>      "most_recent": true
</span><span class='line'>    },
</span><span class='line'>    "instance_type": "t2.micro",
</span><span class='line'>    "ssh_username": "ubuntu",
</span><span class='line'>    "ami_name": "packer-example {{timestamp}}"
</span><span class='line'>  }],
</span><span class='line'>  "provisioners": [
</span><span class='line'>    {
</span><span class='line'>      "type": "shell",
</span><span class='line'>      "script": "./setup.sh"
</span><span class='line'>    }
</span><span class='line'>  ]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>A</strong>ntes de entrarmos em maiores detalhes e na utilização do Puppet em si para nossa imagem, vamos testar nosso código e aplicá-lo novamente:</p>

<p><strong>I</strong>ncluímos aqui:</p>

<p><em>provisioners:</em> Para indicar que utilizaremos provisioners</p>

<p><em>type:</em> Tipo de provisioner. Neste exemplo, será <em>bash</em></p>

<p><em>script:</em> Com o provisioner bash nós podemos declarar diretamente os comandos que queremos executar na imagem ou indicar um script com os comandos. Neste caso, optei por utilizar um script.</p>

<p><strong>V</strong>alidando e executando nosso código:
(PS: Como a saída dos comandos apt-get update e apt-get upgrade são muito extensas, cortarei a maior parte aqui&hellip;)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ packer validate ubuntuaws.json
</span><span class='line'>Template validated successfully.
</span><span class='line'>
</span><span class='line'>$ packer build ubuntuaws.json
</span><span class='line'>amazon-ebs output will be in this color.
</span><span class='line'>
</span><span class='line'>==&gt; amazon-ebs: Prevalidating AMI Name: packer-example 1534024952
</span><span class='line'>    amazon-ebs: Found Image ID: ami-5c150e23
</span><span class='line'>==&gt; amazon-ebs: Creating temporary keypair: packer_5b6f5cf9-dedc-aec2-ad77-acb29d37e8f9
</span><span class='line'>==&gt; amazon-ebs: Creating temporary security group for this instance: packer_5b6f5cfa-d35c-ff6c-aaad-cf02cedf8e74
</span><span class='line'>==&gt; amazon-ebs: Authorizing access to port 22 from 0.0.0.0/0 in the temporary security group...
</span><span class='line'>==&gt; amazon-ebs: Launching a source AWS instance...
</span><span class='line'>==&gt; amazon-ebs: Adding tags to source instance
</span><span class='line'>    amazon-ebs: Adding tag: "Name": "Packer Builder"
</span><span class='line'>    amazon-ebs: Instance ID: i-0bbf230a251f76393
</span><span class='line'>==&gt; amazon-ebs: Waiting for instance (i-0bbf230a251f76393) to become ready...
</span><span class='line'>==&gt; amazon-ebs: Waiting for SSH to become available...
</span><span class='line'>==&gt; amazon-ebs: Connected to SSH!
</span><span class='line'>
</span><span class='line'>######
</span><span class='line'>---&gt;&gt;&gt; REPARE A SEGUIR QUANDO O PACKER COMEÇA A EXECUTAR NOSSO SCRIPT SETUP.SH &lt;&lt;&lt;---
</span><span class='line'>######
</span><span class='line'>
</span><span class='line'>==&gt; amazon-ebs: Provisioning with shell script: ./setup.sh
</span><span class='line'>    amazon-ebs: Hit:1 https://us-east-1.ec2.archive.ubuntu.com/ubuntu xenial InRelease
</span><span class='line'>    amazon-ebs: Get:2 https://us-east-1.ec2.archive.ubuntu.com/ubuntu xenial-updates InRelease [109 kB]
</span><span class='line'>
</span><span class='line'>######
</span><span class='line'>---&gt;&gt;&gt; NESTE MOMENTO O COMANDO "SUDO APT-GET UPDATE" ESTÁ SENDO EXECUTADO &lt;&lt;&lt;---
</span><span class='line'>######
</span><span class='line'>...
</span><span class='line'>...
</span><span class='line'>
</span><span class='line'>######
</span><span class='line'>---&gt;&gt;&gt; A PARTIR DAQUI O COMANDO "SUDO APT-GET UPGRADE -Y" ESTÁ SENDO EXECUTADO &lt;&lt;&lt;---
</span><span class='line'>######
</span><span class='line'>
</span><span class='line'>amazon-ebs: Calculating upgrade...
</span><span class='line'>amazon-ebs: The following packages will be upgraded:
</span><span class='line'>amazon-ebs:   cloud-init gnupg gpgv grub-legacy-ec2
</span><span class='line'>amazon-ebs: 4 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
</span><span class='line'>amazon-ebs: Need to get 1,188 kB of archives.
</span><span class='line'>amazon-ebs: After this operation, 76.8 kB of additional disk space will be used.
</span><span class='line'>amazon-ebs: Get:1 https://us-east-1.ec2.archive.ubuntu.com/ubuntu xenial-updates/main amd64 gpgv amd64 1.4.20-1ubuntu3.3 [165 kB]
</span><span class='line'>amazon-ebs: Get:2 https://us-east-1.ec2.archive.ubuntu.com/ubuntu xenial-updates/main amd64 gnupg amd64 1.4.20-1ubuntu3.3 [626 kB]
</span><span class='line'>
</span><span class='line'>...
</span><span class='line'>...
</span><span class='line'>
</span><span class='line'>######
</span><span class='line'>---&gt;&gt;&gt; A PARTIR DAQUI O COMANDO "SUDO APT-GET INSTALL PUPPET -Y" ESTÁ SENDO EXECUTADO &lt;&lt;&lt;---
</span><span class='line'>######
</span><span class='line'>
</span><span class='line'>amazon-ebs: The following additional packages will be installed:
</span><span class='line'> amazon-ebs:   augeas-lenses debconf-utils facter fonts-lato hiera javascript-common
</span><span class='line'> amazon-ebs:   libaugeas0 libjs-jquery libruby2.3 puppet-common rake ruby ruby-augeas
</span><span class='line'> amazon-ebs:   ruby-deep-merge ruby-did-you-mean ruby-json ruby-minitest ruby-net-telnet
</span><span class='line'> amazon-ebs:   ruby-nokogiri ruby-power-assert ruby-rgen ruby-safe-yaml ruby-selinux
</span><span class='line'> amazon-ebs:   ruby-shadow ruby-test-unit ruby2.3 rubygems-integration unzip virt-what zip
</span><span class='line'> amazon-ebs: Suggested packages:
</span><span class='line'> amazon-ebs:   augeas-doc mcollective-common apache2 | lighttpd | httpd augeas-tools
</span><span class='line'> amazon-ebs:   puppet-el vim-puppet etckeeper ruby-rrd ri ruby-dev bundler
</span><span class='line'> amazon-ebs: The following NEW packages will be installed:
</span><span class='line'> amazon-ebs:   augeas-lenses debconf-utils facter fonts-lato hiera javascript-common
</span><span class='line'> amazon-ebs:   libaugeas0 libjs-jquery libruby2.3 puppet puppet-common rake ruby
</span><span class='line'> amazon-ebs:   ruby-augeas ruby-deep-merge ruby-did-you-mean ruby-json ruby-minitest
</span><span class='line'> amazon-ebs:   ruby-net-telnet ruby-nokogiri ruby-power-assert ruby-rgen ruby-safe-yaml
</span><span class='line'> amazon-ebs:   ruby-selinux ruby-shadow ruby-test-unit ruby2.3 rubygems-integration unzip
</span><span class='line'> amazon-ebs:   virt-what zip
</span><span class='line'> amazon-ebs: 0 upgraded, 31 newly installed, 0 to remove and 0 not upgraded.
</span><span class='line'> amazon-ebs: Need to get 8,267 kB of archives.
</span><span class='line'> amazon-ebs: After this operation, 38.2 MB of additional disk space will be used.
</span><span class='line'> amazon-ebs: Get:1 https://us-east-1.ec2.archive.ubuntu.com/ubuntu xenial/main amd64 fonts-lato all 2.0-1 [2,693 kB]
</span><span class='line'>...
</span><span class='line'>...
</span><span class='line'>
</span><span class='line'>######
</span><span class='line'>---&gt;&gt;&gt;  E O PROCESSO SE ENCERRA &lt;&lt;&lt;---
</span><span class='line'>######
</span><span class='line'>
</span><span class='line'>==&gt; amazon-ebs: Stopping the source instance...
</span><span class='line'>    amazon-ebs: Stopping instance, attempt 1
</span><span class='line'>==&gt; amazon-ebs: Waiting for the instance to stop...
</span><span class='line'>==&gt; amazon-ebs: Creating the AMI: packer-example 1534024952
</span><span class='line'>    amazon-ebs: AMI: ami-06fe27bd22afcaa71
</span><span class='line'>==&gt; amazon-ebs: Waiting for AMI to become ready...
</span><span class='line'>==&gt; amazon-ebs: Terminating the source AWS instance...
</span><span class='line'>==&gt; amazon-ebs: Cleaning up any extra volumes...
</span><span class='line'>==&gt; amazon-ebs: No volumes to clean up, skipping
</span><span class='line'>==&gt; amazon-ebs: Deleting temporary security group...
</span><span class='line'>==&gt; amazon-ebs: Deleting temporary keypair...
</span><span class='line'>Build 'amazon-ebs' finished.
</span><span class='line'>
</span><span class='line'>==&gt; Builds finished. The artifacts of successful builds are:
</span><span class='line'>--&gt; amazon-ebs: AMIs were created:
</span><span class='line'>us-east-1: ami-06fe27bd22afcaa71</span></code></pre></td></tr></table></div></figure>


<p><strong>A</strong> partir deste momento já temos duas imagens criadas. Uma vez que a primeira não tinha nada de diferente do Ubuntu convencional e padrão do AWS, poderíamos muito bem deletá-la. Já a segunda imagem, é um pouco diferente da imagem padrão, visto que ela já conta com um sistema mais atualizado (apt-get upgrade), bem como possui o puppet já instalado nela.</p>

<p><strong>D</strong>esta mesma maneira seria possível fazer um deployment bem mais complexo de acordo com suas necessidades e, sempre que lhe fosse necessário atualizar ou modificar algo, você poderia gerar uma nova imagem e aplicá-la onde desejasse.</p>

<p><strong>M</strong>as vamos incrementar um pouco mais nossa imagem, desta vez com o puppet como segundo provisioner.</p>

<p><strong>Puppet</strong></p>

<p><strong>U</strong>ma vez que o objetivo deste post não é apresentar o <a href="https://puppet.com">Puppet</a> em si, por hora ficaremos apenas com a informação de que o Puppet é uma ferramenta open source para gerenciamento de configurações (CM Tool &ndash; Configuration Management Tool) muito robusta e flexível.</p>

<p><strong>E</strong>m futuros posts pretendo apresentar mais detalhes e explicações sobre o Puppet em si, mas para este post o objetivo é apenas demonstrar a flexibilidade do Packer para a criação de imagens, mesmo quando integramos diversos elementos a ele, como bash script e Puppet.</p>

<p><strong>C</strong>rie um novo arquivo chamado <em>deployment.pp</em>. O Puppet chama seus arquivos de configuração ou instruções de manifests (manifestos) e estes sempre possuem a extensão .pp.</p>

<p><strong>I</strong>nsira o seguinte conteúdo em seu arquivo <em>deployment.pp</em>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>exec { 'apt-update':
</span><span class='line'>  command =&gt; '/usr/bin/apt-get update'
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>package { 'apache2':
</span><span class='line'>  ensure =&gt; installed,
</span><span class='line'>  before =&gt; Service['apache2'],
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>service { 'apache2':
</span><span class='line'>  ensure =&gt; running,
</span><span class='line'>  before =&gt; Package['mysql-server'],
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>package { 'mysql-server':
</span><span class='line'>  ensure =&gt; installed,
</span><span class='line'>  before =&gt; Service['mysql'],
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>service { 'mysql':
</span><span class='line'>  ensure =&gt; running,
</span><span class='line'>  before =&gt; Package['php'],
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>package { 'php':
</span><span class='line'>  ensure =&gt; installed,
</span><span class='line'>  before =&gt; File['/var/www/html/info.php'],
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>file { '/var/www/html/info.php':
</span><span class='line'>  ensure =&gt; file,
</span><span class='line'>  content =&gt; '&lt;?php  phpinfo(); ?&gt;',
</span><span class='line'>  require =&gt; Package['apache2'],
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>E</strong>ste manifesto Puppet tem a tarefa de instalar um servidor web LAMP em nossa imagem Ubuntu, com Apache, Mysql e PHP, bem como expor uma página de informações do php default (php.info).</p>

<p><strong>C</strong>omo puppet não é o foco para este post, não entrarei em detalhes sobre as linhas contidas neste manifesto <em>deployment.pp</em>.</p>

<p><strong>PS:</strong> Também estou assumindo que você já possui o puppet instalado em sua máquina. ;] (sudo apt-get install puppet -y)</p>

<p><strong>V</strong>amos primeiramente validar nosso código puppet para garantirmos que está tudo em ordem:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ puppet parser validate deployment.pp</span></code></pre></td></tr></table></div></figure>


<p><strong>S</strong>e nada for apresentado na tela, significa que está tudo certo.</p>

<p><strong>A</strong>gora vamos voltar ao nosso código packer e editar o arquivo <em>ubuntuaws.json</em> para inserir nosso segundo provisioner (Puppet):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "variables": {
</span><span class='line'>    "aws_access_key": "{{env `AWS_ACCESS_KEY_ID`}}",
</span><span class='line'>    "aws_secret_key": "{{env `AWS_SECRET_ACCESS_KEY`}}",
</span><span class='line'>    "region": "us-east-1"
</span><span class='line'>  },
</span><span class='line'>  "builders": [{
</span><span class='line'>    "type": "amazon-ebs",
</span><span class='line'>    "access_key": "{{user `aws_access_key`}}",
</span><span class='line'>    "secret_key": "{{user `aws_secret_key`}}",
</span><span class='line'>    "region": "{{user `region`}},
</span><span class='line'>    "source_ami_filter": {
</span><span class='line'>      "filters": {
</span><span class='line'>      "virtualization-type": "hvm",
</span><span class='line'>      "name": "ubuntu/images/*ubuntu-xenial-16.04-amd64-server-*",
</span><span class='line'>      "root-device-type": "ebs"
</span><span class='line'>      },
</span><span class='line'>      "owners": ["099720109477"],
</span><span class='line'>      "most_recent": true
</span><span class='line'>    },
</span><span class='line'>    "instance_type": "t2.micro",
</span><span class='line'>    "ssh_username": "ubuntu",
</span><span class='line'>    "ami_name": "packer-example {{timestamp}}"
</span><span class='line'>  }],
</span><span class='line'>  "provisioners": [
</span><span class='line'>    {
</span><span class='line'>      "type": "shell",
</span><span class='line'>      "script": "./setup.sh"
</span><span class='line'>    },
</span><span class='line'>    {
</span><span class='line'>      "type": "puppet-masterless",
</span><span class='line'>      "manifest_file": "deployment.pp"
</span><span class='line'>    }
</span><span class='line'>  ]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>O</strong> que incluímos? Apenas mais um item dentro do bloco provisioners, porém desta vez com o tipo <em>puppet-masterless</em>:</p>

<p><em>type:</em> Indicamos que o tipo deste provisioner é <em>puppet-masterless</em>. O Puppet pode funcionar de forma cliente/servidor, ou de forma autônoma, sem um master. Aqui queremos que ele funcione de forma autônoma e independente, portanto utilizaremos <em>puppet-masterless</em> (puppet sem master).</p>

<p><em>manifest_file:</em> Indicamos que arquivo(s) de manifesto(s) do puppet devem ser executados. Neste caso, iremos apenas apontar para nosso <em>deployment.pp</em>.</p>

<p><strong>V</strong>alidando nosso código:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ packer validate ubuntuaws.json
</span><span class='line'>Template validated successfully.</span></code></pre></td></tr></table></div></figure>


<p><strong>T</strong>udo certo com nosso código, portanto vamos executar novamente nosso build. Desta vez o Packer irá criar nossa imagem Ubuntu executando ambos, o shell script e o manifesto puppet, portanto nossa saída será bastante extensa. Como já vimos os detalhes nas execuções anteriores, irei cortar a saída aqui para focar na execução do manifesto puppet em si:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ packer build ubuntuaws.json
</span><span class='line'>amazon-ebs output will be in this color.
</span><span class='line'>
</span><span class='line'>==&gt; amazon-ebs: Prevalidating AMI Name: packer-example 1534028156
</span><span class='line'>    amazon-ebs: Found Image ID: ami-5c150e23
</span><span class='line'>==&gt; amazon-ebs: Creating temporary keypair: packer_5b6f697c-9aa2-4a5b-0554-255f223460ce
</span><span class='line'>==&gt; amazon-ebs: Creating temporary security group for this instance: packer_5b6f697e-92da-f29d-8688-92b3d787afff
</span><span class='line'>==&gt; amazon-ebs: Authorizing access to port 22 from 0.0.0.0/0 in the temporary security group...
</span><span class='line'>==&gt; amazon-ebs: Launching a source AWS instance...
</span><span class='line'>==&gt; amazon-ebs: Adding tags to source instance
</span><span class='line'>    amazon-ebs: Adding tag: "Name": "Packer Builder"
</span><span class='line'>    amazon-ebs: Instance ID: i-01b0ccb4a7d4462ae
</span><span class='line'>...
</span><span class='line'>...
</span><span class='line'>...
</span><span class='line'>
</span><span class='line'>#####
</span><span class='line'>---&gt;&gt;&gt; A PARTIR DAQUI O PACKER INICIA A EXECUÇÃO DO MANIFESTO COM O PUPPET &lt;&lt;&lt;---
</span><span class='line'>#####
</span><span class='line'>
</span><span class='line'>==&gt; amazon-ebs: Provisioning with Puppet...
</span><span class='line'>    amazon-ebs: Creating Puppet staging directory...
</span><span class='line'>    amazon-ebs: Creating directory: /tmp/packer-puppet-masterless
</span><span class='line'>    amazon-ebs: Uploading manifests...
</span><span class='line'>    amazon-ebs: Creating directory: /tmp/packer-puppet-masterless/manifests
</span><span class='line'>    amazon-ebs: Uploading manifest file from: deployment.pp
</span><span class='line'>    amazon-ebs: Running Puppet: cd /tmp/packer-puppet-masterless && FACTER_packer_build_name='amazon-ebs' FACTER_packer_builder_type='amazon-ebs' sudo -E puppet apply --detailed-exitcodes /tmp/packer-puppet-masterless/manifests/deployment.pp
</span><span class='line'>    amazon-ebs: Notice: Compiled catalog for ip-172-31-91-36.ec2.internal in environment production in 0.43 seconds
</span><span class='line'>    amazon-ebs: Notice: /Stage[main]/Main/Exec[apt-update]/returns: executed successfully
</span><span class='line'>    amazon-ebs: Notice: /Stage[main]/Main/Package[apache2]/ensure: ensure changed 'purged' to 'present'
</span><span class='line'>    amazon-ebs: Notice: /Stage[main]/Main/Package[mysql-server]/ensure: ensure changed 'purged' to 'present'
</span><span class='line'>    amazon-ebs: Notice: /Stage[main]/Main/Package[php]/ensure: ensure changed 'purged' to 'present'
</span><span class='line'>    amazon-ebs: Notice: /Stage[main]/Main/File[/var/www/html/info.php]/ensure: defined content as '{md5}d9c0c977ee96604e48b81d795236619a'
</span><span class='line'>    amazon-ebs: Notice: Finished catalog run in 35.64 seconds
</span><span class='line'>
</span><span class='line'>#####
</span><span class='line'>---&gt;&gt;&gt; FINALIZOU A EXECUÇÃO DO MANIFESTO PUPPET &lt;&lt;&lt;---
</span><span class='line'>#####
</span><span class='line'>
</span><span class='line'>==&gt; amazon-ebs: Stopping the source instance...
</span><span class='line'>    amazon-ebs: Stopping instance, attempt 1
</span><span class='line'>==&gt; amazon-ebs: Waiting for the instance to stop...
</span><span class='line'>==&gt; amazon-ebs: Creating the AMI: packer-example 1534031735
</span><span class='line'>    amazon-ebs: AMI: ami-04b480ee18474759c
</span><span class='line'>==&gt; amazon-ebs: Waiting for AMI to become ready...
</span><span class='line'>==&gt; amazon-ebs: Terminating the source AWS instance...
</span><span class='line'>==&gt; amazon-ebs: Cleaning up any extra volumes...
</span><span class='line'>==&gt; amazon-ebs: No volumes to clean up, skipping
</span><span class='line'>==&gt; amazon-ebs: Deleting temporary security group...
</span><span class='line'>==&gt; amazon-ebs: Deleting temporary keypair...
</span><span class='line'>Build 'amazon-ebs' finished.
</span><span class='line'>
</span><span class='line'>==&gt; Builds finished. The artifacts of successful builds are:
</span><span class='line'>--&gt; amazon-ebs: AMIs were created:
</span><span class='line'>us-east-1: ami-04b480ee18474759c</span></code></pre></td></tr></table></div></figure>


<p><strong>E</strong> nossa imagem foi criada com sucesso.</p>

<p><strong>A</strong> partir deste momento você decide o que fazer. As possibilidades são infinitas, dependendo do que se deseja conseguir ou arquitetar e como deseja que sua pipeline funcione.</p>

<p><strong>P</strong>or exemplo, você poderia ter uma pipeline no <em>Jenkins</em> que iniciasse o build de uma nova imagem atualizada, que por sua vez chamasse shell script e puppet para provisionamento e configuração desta imagem, em seguida o Jenkins poderia chamar o terraform para criar uma instância ou múltiplas instâncias em um cluster por trás de um load balancer utilizando a imagem que foi criada pelo Packer, etc..etc..etc.. Sua criatividade será o seu limite.</p>

<p><strong>P</strong>ara confirmarmos que nosso código completo funcionou e que nossa imagem foi gerada com sucesso, você pode criar manualmente uma instância a partir do AWS com esta sua nova imagem.</p>

<h2>Testando sua imagem</h2>

<p>1- Efetue login em sua conta do AWS;</p>

<p>2- Vá ao menu de Serviços/Services &ndash;> Imagens/Images &ndash;> AMIs;</p>

<p>3- Na lista de imagens disponíveis, selecione a sua mais recente, para ter certeza de que está escolhendo a que foi criada por último, pois ela será a imagem que contém o deployment via puppet por completo (Repare a data de criação para ter certeza);</p>

<p>4- Ao selecionar a imagem, clique em Lançar/Launch, conforme imagem abaixo:</p>

<p><img class="center" src="/imgs/packer_aws_image2.png" title="'Packer Image'" ></p>

<p>5- Selecione o tipo de instância padrão que pode ser utilizada gratuitamente para este exemplo, <em>t2.micro</em>, em seguida clique em <em>Próximo/Next</em>, conforme imagem abaixo:</p>

<p><img class="center" src="/imgs/packer_aws_image3.png" title="'Packer Image'" ></p>

<p>6- Na tela seguinte, deixe tudo como está <strong>exceto</strong> a opção de <em>Atribuir Ip Público/Auto-Assign Public IP</em>. Ative esta opção, em seguida clique em <em>Próximo</em>, conforme imagem abaixo:</p>

<p><img class="center" src="/imgs/packer_aws_image4.png" title="'Packer Image'" ></p>

<p>7- Na tela seguinte, pode manter o padrão de 8GB de disco/storage e clicar em <em>Próximo</em>;</p>

<p>8- Na parte de Tags, pode novamente manter tudo vazio para este exemplo e clicar em <em>Próximo</em>;</p>

<p>9- Nas configurações de Grupo de Segurança/Security Group, pode manter o padrão, mas certifique-se de <strong>inserir mais uma regra de firewall</strong> para que possamos testar o servidor web. Por padrão o AWS já apresentará a porta 22 (SSH) aberta, portanto vamos abrir também a porta 80, conforme imagem abaixo. Em seguida, clique em Revisar e Lançar/Review and Launch;</p>

<p><img class="center" src="/imgs/packer_aws_image5.png" title="'Packer Image'" ></p>

<p>10- Em seguida, confirme novamente e clique em <em>Lançar/Launch</em>;</p>

<p>11- Uma janela popup será apresentada lhe perguntando se você deseja criar um par de chaves. Fica a seu critério. Caso deseje se conectar a esta instância via ssh, crie uma chave, do contrário, pode prosseguir sem criar uma chave. Como eu apenas quero testar se o servidor web estará rodando, e já abrimos a porta 80 no firewall, poderemos confirmar isto através de nosso navegador, portanto ignorarei a chave e clicarei em Lançar Instância/Launch Instance;</p>

<p>12- O AWS lhe informará que sua instância está sendo criada. Como se trata de uma instância Linux, costuma ser um processo rápido, geralmente leva algo entre 1 e 2 minutos. Você pode ir para a página principal de instâncias e aguardar sua instância estar com status <em>running</em>;</p>

<p>13- Copie o IP público ou externo que o AWS atribuiu à sua instância conforme imagem abaixo:</p>

<p><img class="center" src="/imgs/packer_aws_image6.png" title="'Packer Image'" ></p>

<p>14- Agora cole o ip em qualquer browser e você deverá ver uma página default do apache que está rodando em seu novo servidor web:</p>

<p><img class="center" src="/imgs/packer_aws_image7.png" title="'Packer Image'" ></p>

<p><strong>F</strong>inalizado.</p>

<p><strong>L</strong>embre-se de excluir os recursos no AWS para evitar ser cobrado:</p>

<ul>
<li>Instâncias</li>
<li>Volumes</li>
<li>Imagens</li>
<li>Security Groups</li>
</ul>


<p>&hellip; ou o que mais você tiver criado em seus testes caso não os vá mais utilizar.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Anteriores</a>
    
    <a href="/blog/archives">Arquivos do Blog</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1 align="left">Marcelo Cavalcante</h1>
  <p><img class="right" src="https://www.marcelocavalcante.net/imgs/kalib_picture_pq_circle_pq.png" title="'kalib'" ><p align=rght>Engenheiro DevOps dinâmico, escrupulosamente curioso, reservadamente convencional, multitarefa, command line heavy-user, estudante e pesquisador, surfista por prazer, leitor inquieto e apaixonado por vinhos.<br>Me conheça melhor <a href="https://blog.marcelocavalcante.net/about">clicando aqui</a>.</p></p>
</section>
<section>
  <h1>Posts Recentes</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2018/10/29/introducao-ao-terraform/">Introdução ao Terraform</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/10/22/infraestrutura-como-codigo-com-terraform/">Infraestrutura como Código com Terraform</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/08/11/criando-uma-imagem-aws-ec2-com-packer-e-puppet/">Criando uma Imagem AWS EC2 com Packer e Puppet</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/07/30/automatizando-a-criacao-de-imagens-com-packer/">Automatizando a Criação de Imagens com Packer</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/04/16/10-anos-d/">10 anos! :D</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Estou lendo</h1>
  <img align="center" src="/imgs/livros/outsider.jpg">
</section>
<section>
  <h1> Eu apoio
</h1>
  <span>
    <a href='https://ansible.com'><img style='padding: .5em; margin: .5em;' src='/images/stickers/ansible.com.png'></a><a href='https://archlinux.org'><img style='padding: .5em; margin: .5em;' src='/images/stickers/archlinux.org.png'></a><a href='https://asterisk.org'><img style='padding: .5em; margin: .5em;' src='/images/stickers/asterisk.org.png'></a><a href='https://atom.io'><img style='padding: .5em; margin: .5em;' src='/images/stickers/atom.io.png'></a><a href='https://chef.io'><img style='padding: .5em; margin: .5em;' src='/images/stickers/chef.io.png'></a><a href='https://djangoproject.com'><img style='padding: .5em; margin: .5em;' src='/images/stickers/djangoproject.com.png'></a><a href='https://docker.com'><img style='padding: .5em; margin: .5em;' src='/images/stickers/docker.com.png'></a><a href='https://github.com'><img style='padding: .5em; margin: .5em;' src='/images/stickers/github.com.png'></a><img style='padding: .5em; margin: .5em;' src='/images/stickers/glider.png' ><a href='https://jenkins.io'><img style='padding: .5em; margin: .5em;' src='/images/stickers/jenkins.io.png'></a><a href='https://kde.org'><img style='padding: .5em; margin: .5em;' src='/images/stickers/kde.org.png'></a><a href='https://kubernetes.io'><img style='padding: .5em; margin: .5em;' src='/images/stickers/kubernetes.io.png'></a><a href='https://linux.org'><img style='padding: .5em; margin: .5em;' src='/images/stickers/linux.org.png'></a><a href='https://octopress.org'><img style='padding: .5em; margin: .5em;' src='/images/stickers/octopress.org.png'></a><a href='https://opensource.org'><img style='padding: .5em; margin: .5em;' src='/images/stickers/opensource.org.png'></a><a href='https://packer.io'><img style='padding: .5em; margin: .5em;' src='/images/stickers/packer.io.png'></a><a href='https://puppet.com'><img style='padding: .5em; margin: .5em;' src='/images/stickers/puppet.com.png'></a><a href='https://python.org'><img style='padding: .5em; margin: .5em;' src='/images/stickers/python.org.png'></a><a href='https://raspberrypi.org'><img style='padding: .5em; margin: .5em;' src='/images/stickers/raspberrypi.org.png'></a><a href='https://ruby-lang.org'><img style='padding: .5em; margin: .5em;' src='/images/stickers/ruby-lang.org.png'></a><a href='https://terraform.io'><img style='padding: .5em; margin: .5em;' src='/images/stickers/terraform.io.png'></a><a href='https://vagrantup.com'><img style='padding: .5em; margin: .5em;' src='/images/stickers/vagrantup.com.png'></a>
  </span>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2018 - Marcelo Cavalcante Rocha - Kalib -
  <span class="credit">Powered by <a href="https://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'marcelocavalcante';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'https://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'https://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
